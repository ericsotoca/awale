<!DOCTYPE html>
<!-- lang attribute will be set dynamically by JS -->
<html lang="fr">
<head>
	<link rel="manifest" href="/manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be set dynamically by JS -->
    <title>Dans la T√™te d'un Champion</title>
    <style>
        /* Styles CSS (Identiques - Aucune modification n√©cessaire ici) */
        html, body { height: 100%; margin: 0; padding: 0; box-sizing: border-box; }
        body { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; min-height: 100vh; padding: 10px 0; transition: background-color 0.3s, color 0.3s; font-family: sans-serif; overflow-x: hidden; }
        *, *:before, *:after { box-sizing: inherit; }
        .dark-mode { background-color: #333; color: #fff; }
        .dark-mode .hole { color: #fff; }
        .dark-mode #bet-pot-info, .dark-mode #success-rate { background-color: #555; border-color: #777; color: #fff; }
        .dark-mode #title, .dark-mode #move-info, .dark-mode #played-moves, .dark-mode #result, .dark-mode #turn-indicator { color: #fff; }
        .dark-mode #help-modal, .dark-mode #secret-modal, .dark-mode #comment-modal, .dark-mode #history-modal, .dark-mode #premium-info-modal { background: #444; color: #fff; }
        .dark-mode .history-entry summary { background-color: #555; }
        .dark-mode .history-entry { border-color: #777; }
        .dark-mode .hole.player1-hole { background-color: #a0522d; color: white; }
        .dark-mode .hole.player2-hole { background-color: #5c4033; color: white; }
        .dark-mode .selected-bet { animation: blink-dark 0.6s infinite; }
        .dark-mode #turn-indicator.player-turn { color: #90ee90; background-color: #385038; }
        .dark-mode #turn-indicator.opponent-turn { color: #ffa0a0; background-color: #5a3030; }
        .dark-mode .comment-entry::before, .dark-mode .error-entry::before { color: #bbb; }
        .dark-mode .comment-options { color: #ddd; }
        .dark-mode .error-detail { color: #ff6b6b;}
        .dark-mode #theme-toggle { background: url('https://img.icons8.com/ios-filled/24/ffffff/light-off.png') no-repeat center; background-size: 60%; }
        .dark-mode .highlight-capture-enabled { animation: blink-orange-dark 0.6s infinite; }
        .dark-mode .highlight-pressure-enabled { border: 3px dashed #ff8c00 !important; box-shadow: 0 0 8px #ff8c00; }
        .dark-mode #cross-toggle-btn { background: #555; border-color: #777; color: #ff6b6b; }
        .dark-mode .highlight-start { background-color: rgba(0, 200, 255, 0.5) !important; }
        #game-area { width: 90vw; max-width: 700px; padding: 1vh 5px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; gap: 1vh; margin-top: 10px; }
        #title { color: #333; text-align: center; font-size: clamp(1.4em, 5vw, 1.8em); margin: 0 0 0.5vh 0; user-select: none; cursor: help; }
        #turn-indicator { font-weight: bold; margin-bottom: 8px; text-align: center; padding: 5px; border-radius: 4px; min-height: 1.2em; width: 90%; max-width: 300px; }
        #turn-indicator.player-turn { color: #006400; background-color: #e8f5e9; }
        #turn-indicator.opponent-turn { color: #b71c1c; background-color: #ffebee; }
        .button-yellow, .button-next, .button-small, .button-save, .button-copy, .button-reset, .button-close { padding: 10px 18px; font-size: clamp(0.9em, 2.5vw, 1em); border-radius: 5px; cursor: pointer; transition: transform 0.2s, background-color 0.2s; border: none; font-weight: bold; margin: 5px 4px; white-space: nowrap; }
        .button-yellow:active, .button-next:active { transform: scale(0.95); }
        .button-yellow { background-color: #ffc107; color: #000; border: 2px solid #e0a800; }
        .button-yellow:hover { background-color: #e0a800; }
        .button-next { background-color: #28a745; color: white; border: 2px solid #218838; }
        .button-next:hover { background-color: #218838; }
        .button-small { background-color: #17a2b8; color: white; border: 2px solid #138496; padding: 8px 12px; font-size: clamp(0.8em, 2.2vw, 0.9em); }
        .button-small:hover { background-color: #138496; }
        .button-small.history { background-color: #6f42c1; border: 2px solid #5a32a3; }
        .button-small.history:hover { background-color: #5a32a3; }
        .button-save { background-color: #28a745; color: white; border: 2px solid #218838; }
        .button-save:hover { background-color: #218838; }
        .button-copy { background-color: #007bff; color: white; border: 2px solid #0056b3; }
        .button-copy:hover { background-color: #0056b3; }
        .button-reset { background-color: #dc3545; color: white; border: 2px solid #c82333; }
        .button-reset:hover { background-color: #c82333; }
        .button-close { background-color: #6c757d; color: white; border: 2px solid #5a6268; }
        .button-close:hover { background-color: #5a6268; }
        .logo-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin: 1vh auto; flex-direction: column; }
        .logo-row { display: flex; align-items: center; gap: clamp(10px, 3vw, 20px); }
        .logo { width: clamp(100px, 25vw, 150px); height: auto; }
        #theme-toggle, #help-btn { width: clamp(30px, 8vw, 40px); height: clamp(30px, 8vw, 40px); border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; background-color: #eee; }
        #theme-toggle { background: url('https://img.icons8.com/ios-filled/24/000000/light-on.png') no-repeat center; background-size: 60%;}
        #help-btn { background-color: #007bff; color: white; font-size: clamp(1em, 4vw, 1.4em); font-weight: bold; }
        #cross-toggle-btn { color: red; font-weight: bold; font-size: clamp(1.8em, 7vw, 2.4em); line-height: 1; padding: 0 5px 4px 5px; background: #eee; border: 1px solid #ccc; border-radius: 50%; width: clamp(30px, 8vw, 40px); height: clamp(30px, 8vw, 40px); cursor: pointer; display: flex; align-items: center; justify-content: center; user-select: none; }
        .selector-container { display: flex; justify-content: center; gap: clamp(10px, 4vw, 25px); margin: 1.5vh 0; flex-wrap: wrap; }
        .selector-container > div { display: flex; align-items: center; gap: 5px;}
        .selector-container label, .selector-container select { font-size: clamp(0.85em, 2.8vw, 1em); }
        #board { position: relative; width: 100%; display: flex; flex-direction: column; align-items: center; margin: 1vh 0; padding: 5px 0; box-sizing: border-box; border: 1px solid #eee; background-color: #f9f9f9; border-radius: 8px; }
        .dark-mode #board { border: 1px solid #555; background-color: #404040; }
        .board-row { display: flex; justify-content: center; width: 100%; padding: 0 5px; box-sizing: border-box; }
        .board-label { flex: 0 0 auto; width: 13vw; max-width: 70px; height: auto; margin: 0.5vw; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: clamp(0.8em, 3vw, 1.3em); text-align: center; color: #666; user-select: none; }
        .dark-mode .board-label { color: #ccc; }
        .hole { flex: 0 0 auto; width: 13vw; height: 13vw; max-width: 70px; max-height: 70px; color: black; display: flex; align-items: center; justify-content: center; border-radius: 50%; margin: 0.5vw; font-weight: bold; font-size: clamp(1em, 4vw, 1.8em); transition: background-color 0.3s, box-shadow 0.3s, border 0.2s, color 0.3s; box-sizing: border-box; border: 2px solid transparent; position: relative; overflow: hidden; cursor: default; user-select: none; }
        .hole.player1-hole { background-color: #d2b48c; color: #333; }
        .hole.player2-hole { background-color: #8b4513; color: white; }
        .hole.player1-hole.clickable { cursor: pointer; }
        .hole.disabled { cursor: not-allowed !important; opacity: 0.7; }
        .highlight-incorrect { border: 3px solid red !important; box-shadow: 0 0 10px red; }
        .highlight-correct { border: 3px solid limegreen !important; box-shadow: 0 0 10px limegreen; }
        .highlight-start { background-color: rgba(0, 200, 255, 0.7) !important; }
        .highlight-end { background-color: rgba(210, 180, 222, 0.7) !important; }
        .selected-bet { animation: blink 0.6s infinite; }
        @keyframes blink { 0%, 100% { background-color: #4682b4; border-color: #1e90ff; box-shadow: 0 0 8px #1e90ff; } 50% { background-color: #add8e6; border-color: #4682b4; box-shadow: 0 0 12px #4682b4; } }
        @keyframes blink-dark { 0%, 100% { background-color: #1e90ff; border-color: #4682b4; box-shadow: 0 0 8px #4682b4; } 50% { background-color: #4682b4; border-color: #1e90ff; box-shadow: 0 0 12px #1e90ff;} }
        .highlight-capture-enabled { animation: blink-orange 0.6s infinite; }
        @keyframes blink-orange { 0%, 100% { background-color: #ffcc80; border: 2px solid orange; box-shadow: 0 0 6px orange; } 50% { background-color: #ffa726; border: 2px solid darkorange; box-shadow: 0 0 10px darkorange; } }
        @keyframes blink-orange-dark { 0%, 100% { background-color: #e69500; border: 2px solid #ff8c00; box-shadow: 0 0 6px #ff8c00; } 50% { background-color: #ffae42; border: 2px solid #ffa500; box-shadow: 0 0 10px #ffa500; } }
        .highlight-pressure-enabled { border: 3px dashed orange !important; box-shadow: 0 0 8px orange; }
        .dark-mode .highlight-pressure-enabled { border: 3px dashed #ff8c00 !important; box-shadow: 0 0 8px #ff8c00; }
        #red-cross { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; justify-content: center; align-items: center; overflow: hidden; }
        .cross-line { position: absolute; background-color: transparent; opacity: 0.7; }
        .cross-line.horizontal { width: 96%; height: 2px; top: 50%; left: 2%; transform: translateY(-50%); border-top: 2px dashed red; }
        .cross-line.vertical { width: 2px; height: 90%; left: 50%; top: 5%; transform: translateX(-50%); border-left: 2px dashed red; }
        #move-info { text-align: center; margin-bottom: 5px; font-size: clamp(0.9em, 3vw, 1.1em);}
        .pot-container { display: flex; align-items: center; justify-content: center; gap: clamp(8px, 3vw, 15px); margin: 1vh 0; }
        #bet-pot-info, #success-rate { background-color: #fff3cd; border: 1px solid #e0a800; padding: 6px 12px; border-radius: 5px; display: inline-block; text-align: center; font-size: clamp(0.85em, 2.8vw, 1em);}
        #played-moves { text-align: center; margin-top: 5px; font-size: clamp(0.8em, 2.5vw, 0.9em); color: #555; width: 90%; word-wrap: break-word;}
        .dark-mode #played-moves { color: #ccc; }
        #result { text-align: center; font-weight: bold; min-height: 1.2em; margin: 8px 0; font-size: clamp(0.95em, 3.2vw, 1.1em); }
        .betting-area { margin-top: 1.5vh; display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        .bet-selection { display: flex; align-items: center; justify-content: center; gap: 5px; flex-wrap: wrap; margin-bottom: 10px; }
        .bet-selection label, .bet-selection select, .bet-selection span { font-size: clamp(0.9em, 2.8vw, 1em); }
        .bet-buttons { display: flex; justify-content: center; align-items: center; gap: clamp(5px, 2vw, 10px); flex-wrap: wrap; }
        #help-modal, #secret-modal, #comment-modal, #history-modal, #premium-info-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1000; max-width: 90%; width: 500px; max-height: 85vh; overflow-y: auto; }
        #help-modal button, #secret-modal button, #comment-modal button, #history-modal button:not(.history-buttons button), #premium-info-modal button { margin-top: 15px; }
        /* --- MODIF: Ajuster la hauteur min si n√©cessaire pour les 11 options --- */
        #comment-modal { height: auto; min-height: 480px; /* Augment√© pour plus d'espace */ }
        .comment-section { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        #comment-input { width: calc(100% - 10px); height: 80px; /* L√©g√®rement r√©duit pour compenser la hauteur des checkboxes */ resize: vertical; padding: 5px; margin-bottom: 5px; border: 1px solid #ccc;}
        .checkbox-section { margin-top: 5px; }
        .checkbox-section label { display: flex; align-items: center; margin-bottom: 6px; cursor: pointer;}
        .checkbox-section input[type="checkbox"] { margin-right: 8px;}
        #history-content { margin-bottom: 10px; font-family: monospace; }
        .history-buttons { display: flex; justify-content: space-between; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .history-entry { border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; background-color: #f9f9f9; }
        .history-entry summary { padding: 10px; font-weight: bold; cursor: pointer; background-color: #eee; border-radius: 5px 5px 0 0; outline: none; display: flex; justify-content: space-between; align-items: center;}
        .history-entry summary::before { content: '‚ñ∂ '; display: inline-block; margin-right: 5px; transition: transform 0.2s; order: -1;}
        .history-entry summary::-webkit-details-marker { display: none; }
        .history-entry[open] summary::before { transform: rotate(90deg); }
        .history-details { padding: 10px; border-top: 1px solid #ddd; }
        .history-details h4 { margin-top: 0; margin-bottom: 5px; font-size: 1em; }
        .comment-entry, .error-entry { margin-bottom: 8px; padding-left: 15px; position: relative; font-size: 0.9em; line-height: 1.4; word-break: break-word; }
        .comment-entry::before, .error-entry::before { content: '‚Ä¢'; position: absolute; left: 0; color: #555; }
        .comment-options { font-style: italic; color: #333; margin-left: 5px; }
        .error-detail { color: #c00; font-weight: bold;}
        .confetti { position: fixed; width: 8px; height: 8px; pointer-events: none; animation: fall 3s ease-out forwards; border-radius: 50%; transform: rotate(0deg); z-index: 9999; }
        @keyframes fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        #premium-info-modal ul { list-style: disc; margin-left: 25px; margin-top: 10px;}
        #premium-info-modal li { margin-bottom: 8px; }
        #help-modal ul { list-style: disc; margin-left: 25px; margin-top: 10px;}
        #help-modal li { margin-bottom: 8px; }

        @media (max-width: 480px) { body { padding: 5px 0; } #game-area { width: 95vw; gap: 0.8vh;} .logo-row { gap: 10px; } .button-yellow, .button-next, .button-small { padding: 8px 10px; font-size: 0.9em; margin: 3px; } .bet-buttons { gap: 5px; } .history-buttons { justify-content: center; } .pot-container { gap: 8px; } #bet-pot-info, #success-rate { padding: 5px 8px; } #help-modal, #secret-modal, #comment-modal, #history-modal, #premium-info-modal { width: 95%; max-height: 80vh; } .hole, .board-label { width: 14vw; max-width: 60px; height: 14vw; max-height: 60px; margin: 0.4vw; font-size: clamp(0.9em, 3.5vw, 1.6em); } }
    </style>
</head>
<body>
    <!-- Structure HTML (Identique) -->
     <div class="logo-container">
        <div id="secret-message"></div>
        <div class="logo-row">
            <img src="logo.jpg" alt="Logo" class="logo" onerror="this.style.display='none'">
            <button id="theme-toggle"></button>
            <button id="help-btn">i</button>
            <button id="cross-toggle-btn">+</button>
        </div>
    </div>
    <div class="selector-container">
        <div>
            <label for="language-select" id="language-label"></label>
            <select id="language-select" onchange="updateLanguage()">
                <option value="fr">Fran√ßais</option>
                <option value="en">English</option>
                <option value="es">Espa√±ol</option>
                <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                <option value="zh">‰∏≠Êñá</option>
            </select>
        </div>
        <div>
            <label for="level-select" id="level-label"></label>
            <select id="level-select" onchange="changeLevel()"></select>
        </div>
    </div>
    <div id="game-area">
        <h1 id="title"></h1>
        <div id="turn-indicator"></div>
        <div id="board">
            <div class="board-row"> <div class="board-label">f</div><div class="board-label">e</div><div class="board-label">d</div><div class="board-label">c</div><div class="board-label">b</div><div class="board-label">a</div> </div>
            <div id="player2-row" class="board-row"></div>
            <div id="player1-row" class="board-row"></div>
            <div class="board-row"> <div class="board-label">A</div><div class="board-label">B</div><div class="board-label">C</div><div class="board-label">D</div><div class="board-label">E</div><div class="board-label">F</div> </div>
            <div id="red-cross"> <div class="cross-line horizontal"></div> <div class="cross-line vertical"></div> </div>
        </div>
        <div id="move-info"></div>
        <div class="pot-container">
            <div id="bet-pot-info"></div>
            <div id="success-rate"></div>
        </div>
        <div id="played-moves"></div>
        <div id="result"></div>
        <div class="betting-area">
            <div class="bet-selection">
                <label id="bet-label" for="bet-amount"></label>
                <select id="bet-amount">
                    <option value="25">25 %</option>
                    <option value="50">50 %</option>
                    <option value="75">75 %</option>
                    <option value="100">100 %</option>
                </select>
                <span>‚Ç¨</span>
                <label id="bet-case-label" for="bet-input"></label>
                <select id="bet-input">
                    <option value="A">A</option><option value="B">B</option><option value="C">C</option>
                    <option value="D">D</option><option value="E">E</option><option value="F">F</option>
                </select>
            </div>
            <div class="bet-buttons">
                <button id="bet-and-verify-btn" class="button-yellow" onclick="betAndVerify()"></button>
                <button id="next-btn" class="button-next" onclick="moveNext()"></button>
                <button id="record-btn" class="button-small" onclick="openCommentModal()" style="display: none;"></button>
                <button id="history-btn" class="button-small history" onclick="openHistoryModal()" style="display: none;"></button>
            </div>
        </div>
    </div>

    <!-- Modals (structure identique, sauf #comment-modal) -->
     <div id="help-modal">
        <h2 id="help-title"></h2>
        <div id="help-text"></div>
        <button onclick="closeModal('help-modal')" class="button-close" id="help-modal-close"></button>
    </div>
    <div id="secret-modal">
        <h2 id="secret-tips-title"></h2>
        <ul id="secret-tips"></ul>
        <button onclick="closeModal('secret-modal')" class="button-close" id="secret-modal-close"></button>
    </div>
    <!-- MODIFICATION: #comment-modal structure des checkboxes -->
    <div id="comment-modal">
        <h3 id="comment-title"></h3>
        <div class="comment-section">
            <textarea id="comment-input" placeholder=""></textarea>
             <div class="checkbox-section">
                <label><input type="checkbox" name="comment-option" value="NoSeedsBC"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="OffensiveCapture"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="BuildKrouOffensive"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="BuildKrouDefensive"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="BlockCounterKrou"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="Build2Krous"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="CaptureLimit3"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="CaptureMax5"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="Accelerate"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="SlowDown"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="TechErrorSelect"> <span class="checkbox-label-text"></span></label>
            </div>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="button-save" onclick="saveComment()" id="comment-save-btn"></button>
            <button class="button-close" onclick="closeModal('comment-modal')" id="comment-cancel-btn"></button>
        </div>
    </div>
    <!-- FIN MODIFICATION #comment-modal -->
    <div id="history-modal">
        <h3 id="history-title"></h3>
        <div id="history-content"></div>
        <div class="history-buttons">
            <button class="button-copy" onclick="copyHistoryContent()" id="history-copy-btn"></button>
            <button class="button-reset" onclick="resetHistory()" id="history-reset-btn"></button>
            <button class="button-close" onclick="closeModal('history-modal')" id="history-close-btn"></button>
        </div>
    </div>
    <div id="premium-info-modal">
        <h2 id="premium-modal-title"></h2>
        <p id="premium-modal-text"></p>
        <p><strong id="premium-modal-benefits-title"></strong></p>
        <ul>
            <li id="premium-benefit-levels"></li>
            <li id="premium-benefit-history"></li>
            <li id="premium-benefit-record"></li>
            <li id="premium-benefit-aids"></li>
            <li id="premium-benefit-cross"></li>
            <li id="premium-benefit-secrets"></li>
        </ul>
        <p id="premium-modal-howto"></p>
        <p style="text-align: center; margin-top:15px;">
            <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer" class="button-yellow" style="text-decoration: none;" id="premium-modal-action-link"></a>
        </p>
        <button onclick="closeModal('premium-info-modal')" class="button-close" id="premium-modal-close"></button>
    </div>

    <script>
        // !!! LOGIQUE DE JEU MISE A JOUR !!!
        // simulateMove ne modifie plus l'√©tat global directement.

        // --- Variables Globales (Identiques) ---
        let isPremium = false;
        let areAidesEnabled = false;
        let isCrossVisible = false;
        const initialBoard = () => ({ player1: [4, 4, 4, 4, 4, 4], player2: [4, 4, 4, 4, 4, 4] });
        const initialScores = () => ({ player1: 0, player2: 0 });
        let board = {};
        let scores = {};
        const games = [ "FfCdAbBaDbCdDcBdAaBbDcCdDeEeDdCfEeFdBeFaD", "FfBaCfAbAfBdCfBcAfCeBfDfCeBdCeEfDbEcAdCaEbF", "FfBaCaAaCfBbAcCaBbCcAfAdAfCaBeDfEeBfAaEbCaEbF", "FfCcBbAaFaDaAcBdDbCfDaCdBcDbCcAeFdBeCfFaCbDaFbE", "FfBdBfDdAbAdDaBdDbAfAeAbDaBbDcEeDdBfAeCfEaDbEcBdF", "FfCcBbAcBbFaCfCeCcBbDfAcDdCfEfBeAfDbEcCdEeAaDbEcBdCeDfEaAbF", "FfBcEeBcDcCcEbAeDbCcBaEfDeEdEcDbCaEdDcEbFfEdFfAaBbCeAcCdDeBf", "FfCcBbAfFdAaEaFaCaEbBeEcCdAfEeCbDdAfAeAfEaCbBbEaDcAdCbEcDdEeAfFfCdBeAfDaE", "FfBaCbBdFbDbFdCfCcFdDfFaCdDcBdDbEfFbAaEdFaCaDfFaAcAeEaAdDbEeCdEfCcEeFbAcDfAeAfEdBcDaCbF", "FfCbDeDcCbAfAeFfAcDbEfFeCcDaAcEdCcEdDaEbBdDbCcAdBeBcEcDfDdCeAcDdBbEbFfEeBfCaFaAeCbBcCdEeAfD", "FfCbDbFbBeAfCcAaDaCeDbBdBcDaEeDfEaCaBbAcCdBeEfDaAbBcEdCeDfEaFfEeDdCcBeDdCeDfFaEaBbCcDdAeBfEaF", "FfCaFdBcFdDaFaBdAfFeFfDcCdDeBbBaDcAfAdAeCbAfDcAdBeCfFbAcDdEeBfFbDaCcDdEeAaFaBbDcEdCeDfFaBbCcAdBeCf", "FfBaCbBeDbCfCeDaBcCfDeEfAcDaBeEfCdAaEcDbAfAeAdBcCeEdDeFfEaDbCdBeAcCdBeCfFbEaDcBeAdCaFaEeBbDcCdDeEaF", "FfBcFbBdAeBbCcAdDbCeDdCeDaFaBaEeBfFbEdBfFeDfEbFaAfAaCeAfEbDcEeFaDbCeEdCcDfDeCdDeEfFaBaDbCcAdBeDfFaEaAbBcCdDeEaFfAaBbCcDdEeFf" ];
        let currentGame = [];
        let currentMoveIndex = -1;
        let moveHistory = [];
        let currentBet = null;
        let playedMoves = [];
        let betAmount = 0;
        let pot = 100;
        let currentLanguage = "fr"; // Default language
        let successfulBets = 0;
        let totalPlayer1Bets = 0;
        let isBetLocked = false;
        let lockedBetPercentage = null;
        let isSuccessGuaranteed = false;
        let perfectGamesCount = 0;
        let currentGameIndex = 0;
        let gameStartTime = null;
        let errorLog = [];
        let lastIncorrectGuess = null;
        let lastCorrectMove = null;
        let highlightStartHole = null;
        let highlightEndHole = null;
        let animationTimeout = null;
        let gameRecords = [];
        let currentGameRecord = {};
        const holeMap = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5 };
        const opponentHoleCodes = ['a', 'b', 'c', 'd', 'e', 'f'];
        const playerHoleCodes = ['A', 'B', 'C', 'D', 'E', 'F'];
        let isGameOver = { confettiShown: false };

        // --- Objet Translations (MODIFI√â pour les nouvelles options de commentaire) ---
        const translations = {
             fr: {
                 pageTitle: "Dans la T√™te d'un Champion",
                 languageLabel: "Langue :",
                 levelLabel: "Partie :",
                 title: "Dans la T√™te d'un Champion !",
                 moveInfo: (p1, p2) => `Joueur üòä ‚Üì: ${p1} | Joueur üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `Cagnotte:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `R√©ussite:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | Derniers jeux: ${moves}`,
                 betLabel: "Je mise",
                 betCaseLabel: "sur",
                 betButton: "Je parie !",
                 nextButton: "Suivant",
                 recordButtonShort: "Enr",
                 historyButtonShort: "Histo",
                 closeButton: "Fermer",
                 saveButton: "Sauver",
                 cancelButton: "Annuler",
                 copyButton: "Copier (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Votre argent virtuel actuel",
                 tooltipSuccessRate: "Pourcentage de paris corrects sur cette partie",
                 tooltipRecord: "Enregistrer un commentaire pour ce coup (Premium)",
                 tooltipHistory: "Voir l'historique des parties jou√©es (Premium)",
                 tooltipHelp: "Afficher l'aide / R√®gles",
                 tooltipTheme: "Mode Sombre/Clair",
                 tooltipCross: "Options Premium (Croix / Aides)",
                 resultInvalidBet: "Mise invalide !",
                 resultWin: "Gagn√© !",
                 resultLose: "Perdu !",
                 resultGameOver: "Partie termin√©e !",
                 resetMessage: "Jeu r√©initialis√© !",
                 premiumUnlockedMessage: "Version Premium activ√©e ! Fonctionnalit√©s d√©bloqu√©es.",
                 successOnMessage: "Succ√®s garanti ACTIV√â",
                 successOffMessage: "Succ√®s garanti D√âSACTIV√â",
                 betLockedMessage: (pct) => `Mise verrouill√©e (${pct}%)`,
                 betUnlockedMessage: "Mise d√©verrouill√©e",
                 backMessage: "Retour arri√®re effectu√©",
                 opponentTurnMessage: "Clic Suivant (tour adverse)",
                 playerTurnIndicator: "√Ä vous : S√©lectionnez & misez !",
                 opponentTurnIndicator: "Tour adverse (Clic Suivant)",
                 emptyHoleMessage: "Case vide !",
                 notYourTurnMessage: "Pas votre tour ! Cliquez sur 'Suivant'.",
                 invalidHoleMessage: "Case invalide ou vide !",
                 internalErrorMessage: "Erreur interne de simulation.",
                 aidesEnabled: "Aides visuelles activ√©es",
                 aidesDisabled: "Aides visuelles d√©sactiv√©es",
                 crossEnabled: "Croix rouge activ√©e",
                 crossDisabled: "Croix rouge d√©sactiv√©e",
                 errorDisplayMessage: "Erreur d'affichage. Rechargez.",
                 confirmResetHistory: "Voulez-vous vraiment r√©initialiser tout l'historique ? Cette action est irr√©versible.",
                 historyResetSuccess: "Historique r√©initialis√© !",
                 copySuccess: "Contenu de l'historique copi√© !",
                 copyError: "Erreur lors de la copie.",
                 copyPrepareError: "Erreur lors de la pr√©paration de la copie.",
                 noHistory: "Aucun historique de partie enregistr√©.",
                 helpTitle: "Aide & Objectif",
                 helpTextStandard: `<strong>Bienvenue dans l'entra√Ænement c√©r√©bral Awal√© !</strong><br><br>Votre objectif est de <strong>penser comme un champion</strong> en devinant le coup qu'il a jou√© dans une partie r√©elle √† chaque fois que c'est votre tour (Joueur üòä ‚Üì).<br><br><strong>Comment jouer :</strong><br>1. Choisissez une langue et l'une des 3 premi√®res parties disponibles.<br>2. Quand c'est votre tour (üòä ‚Üì), observez le plateau.<br>3. Cliquez sur une de vos cases (A-F) contenant des graines pour la s√©lectionner.<br>4. Choisissez le pourcentage de votre cagnotte virtuelle √† miser sur ce choix.<br>5. Cliquez sur 'Je parie !'. Si votre choix est correct, vous gagnez votre mise. Sinon, vous la perdez.<br>6. Quand c'est le tour de l'adversaire (üòî ‚Üë), cliquez sur 'Suivant'.<br><br><strong>Passez √† la Version Premium !</strong><br>Pour une exp√©rience compl√®te et soutenir notre association, adh√©rez √† <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. La version Premium d√©bloque les fonctionnalit√©s suivantes :<ul><li>L'acc√®s √† <strong>toutes les parties</strong> d'entra√Ænement.</li><li>Les boutons <strong>"Histo"</strong> (historique) et <strong>"Enr"</strong> (prise de notes).</li><li>L'activation des <strong>aides visuelles</strong> (indications de capture/pression).</li><li>L'activation de la <strong>croix rouge</strong> d'alignement.</li><li>L'acc√®s aux <strong>astuces secr√®tes</strong>.</li></ul>`,
                 helpTextPremium: `<strong>Bienvenue dans la version Premium !</strong><br><br>Vous avez acc√®s √† toutes les fonctionnalit√©s pour vous entra√Æner √† penser comme un champion.<br><br><strong>Fonctionnalit√©s Premium :</strong><br><ul><li><strong>Toutes les Parties :</strong> Acc√©dez √† l'ensemble des parties via le s√©lecteur.</li><li><strong>Historique ("Histo") :</strong> Consultez vos parties pr√©c√©dentes, statistiques et commentaires.</li><li><strong>Coaching par IA via Export JSON :</strong> Utilisez le bouton "Copier (JSON)" dans l'historique. Collez le texte copi√© dans une Intelligence Artificielle conversationnelle (comme ChatGPT, Gemini, Mistral, etc.). Le prompt inclus demandera √† l'IA d'analyser vos parties (erreurs, commentaires) et de vous donner des conseils de coaching personnalis√©s, directement dans la langue s√©lectionn√©e dans l'application !</li><li><strong>Enregistrement ("Enr") :</strong> Ajoutez des notes strat√©giques √† chaque coup jou√©.</li><li><strong>Aides Visuelles :</strong><ul><li>Activation/D√©sactivation : Appui long (3s) sur le bouton <strong>+</strong> en haut √† droite.</li><li>Case adverse orange clignotante : Votre coup s√©lectionn√© capture directement.</li><li>Case adverse avec bordure orange : Pression pour capture future possible.</li><li>Votre case avec bordure orange pointill√©e : Menace de capture par l'adversaire.</li></ul></li><li><strong>Croix Rouge :</strong><ul><li>Activation/D√©sactivation : Clic simple sur le bouton <strong>+</strong> en haut √† droite.</li><li>Aide √† visualiser les alignements de cases.</li></ul></li></ul><strong>Astuces Secr√®tes Activables :</strong><br><ul><li><strong>Logo x3 clics :</strong> R√©initialise la partie en cours.</li><li><strong>Cagnotte x3 clics :</strong> Active/D√©sactive le mode "Succ√®s Garanti" (tous les paris r√©ussissent).</li><li><strong>Texte "Je mise" x3 clics :</strong> Verrouille/D√©verrouille le pourcentage de mise s√©lectionn√©.</li><li><strong>Case 'a' adverse (appui 2s) :</strong> Annule le dernier coup jou√© (retour arri√®re).</li><li><strong>Cases 'f' + 'a' adverses (appui 3s simultan√©) :</strong> Affiche la liste des astuces secr√®tes.</li></ul>`,
                 secretMessage: "Bonjour",
                 secretTipsTitle: "Astuces Secr√®tes (Premium)",
                 secretTips: [ "Logo x3 clics : Reset partie", "Cagnotte x3 clics : Succ√®s garanti ON/OFF", "'Je mise' x3 clics : Verrouille/D√©verrouille mise (%)", "Case 'f' adverse (appui 2s) : Bonjour", "Case 'a' adverse (appui 2s) : Retour arri√®re (annule dernier coup)", "Cases 'f' + 'a' adverses (appui 3s simultan√©) : Montre cette liste" ],
                 commentModalTitle: "Ajouter un Commentaire",
                 commentInputPlaceholder: "Votre note strat√©gique ici...",
                 // --- NOUVELLES OPTIONS COMMENTAIRE ---
                 commentOptionNoSeedsBC: "Aucune graines en case B et C",
                 commentOptionOffensiveCapture: "Etre Offensif (capture) > D√©fensif (√©chapp√©)",
                 commentOptionBuildKrouOffensive: "Construire Krou Offensif (D/E/F) > D√©fensif",
                 commentOptionBuildKrouDefensive: "Construire Krou D√©fensif (C/D/E) > Offensif",
                 commentOptionBlockCounterKrou: "Bloquer le Contre-Krou Adverse",
                 commentOptionBuild2Krous: "Construire 2 Krous en m√™me temps",
                 commentOptionCaptureLimit3: "Capture multiple limit√© √† 3 cases",
                 commentOptionCaptureMax5: "Capture multiple max (5 cases)",
                 commentOptionAccelerate: "Acc√©l√©rer le jeu",
                 commentOptionSlowDown: "Ralentir le jeu",
                 commentOptionTechErrorSelect: "Erreur technique de s√©lection de case",
                 // --- FIN NOUVELLES OPTIONS ---
                 historyTitle: "Historique des Parties",
                 historyRecordTitle: (name, date) => `Partie: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `R√©ussite: ${rate}% | Pot final: ${pot}‚Ç¨ | Dur√©e: ${duration}s`,
                 historyCommentsTitle: "Commentaires Enregistr√©s",
                 historyErrorsTitle: "Erreurs de Pari",
                 historyNoComments: "Aucun commentaire enregistr√© pour cette partie.",
                 historyNoErrors: "Aucune erreur de pari enregistr√©e pour cette partie.",
                 historyInProgress: "(En cours)",
                 historyMoveLabel: "Coup",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Pari√© <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pot ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "Fonctionnalit√© Premium",
                 premiumModalText: "Cette fonctionnalit√©, ainsi que d'autres avantages, sont r√©serv√©s aux membres Premium.",
                 premiumModalBenefitsTitle: "Avantages Premium :",
                 premiumBenefitLevels: "Acc√®s √† toutes les parties d'entra√Ænement.",
                 premiumBenefitHistory: "Bouton 'Histo' pour voir et analyser vos parties pr√©c√©dentes.",
                 premiumBenefitRecord: "Bouton 'Enr' pour ajouter des commentaires strat√©giques.",
                 premiumBenefitAids: "Activation des aides visuelles (captures/pression).",
                 premiumBenefitCross: "Activation de la croix rouge d'alignement.",
                 premiumBenefitSecrets: "Acc√®s aux astuces secr√®tes.",
                 premiumModalHowto: "Pour d√©bloquer la version Premium et soutenir notre association, devenez membre de <strong>Jeux Nomades France</strong> :",
                 premiumModalActionLink: "Adh√©rer √† l'association",
                 gameDropdownFormat: (index, moves) => `Partie ${index} (${moves} coups)`,
                 encouragingMessages: [ "Bravo!", "Super!", "Excellent!", "Continue!", "Impressionnant!", "Magnifique!", "Dou√©!", "Formidable!", "Incroyable!", "G√©nial!", "Parfait!", "√âpoustouflant!", "√âtoile montante!", "Sensationnel!", "Triomphe!", "Ma√Ætre!", "L√©gendaire!", "G√©nie!", "Champion!", "Immortel!" ]
             },
              en: {
                 pageTitle: "Inside the Mind of a Champion",
                 languageLabel: "Language:",
                 levelLabel: "Game:",
                 title: "Inside the Mind of a Champion!",
                 moveInfo: (p1, p2) => `Player üòä ‚Üì: ${p1} | Player üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `Pot:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `Success:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | Last plays: ${moves}`,
                 betLabel: "I bet",
                 betCaseLabel: "on",
                 betButton: "Place Bet!",
                 nextButton: "Next",
                 recordButtonShort: "Rec",
                 historyButtonShort: "Hist",
                 closeButton: "Close",
                 saveButton: "Save",
                 cancelButton: "Cancel",
                 copyButton: "Copy (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Your current virtual money",
                 tooltipSuccessRate: "Percentage of correct bets in this game",
                 tooltipRecord: "Record a comment for this move (Premium)",
                 tooltipHistory: "View history of played games (Premium)",
                 tooltipHelp: "Show Help / Rules",
                 tooltipTheme: "Dark/Light Mode",
                 tooltipCross: "Premium Options (Cross / Aids)",
                 resultInvalidBet: "Invalid bet!",
                 resultWin: "Won!",
                 resultLose: "Lost!",
                 resultGameOver: "Game over!",
                 resetMessage: "Game reset!",
                 premiumUnlockedMessage: "Premium Version activated! Features unlocked.",
                 successOnMessage: "Guaranteed Success ON",
                 successOffMessage: "Guaranteed Success OFF",
                 betLockedMessage: (pct) => `Bet locked (${pct}%)`,
                 betUnlockedMessage: "Bet unlocked",
                 backMessage: "Undo successful",
                 opponentTurnMessage: "Click Next (opponent's turn)",
                 playerTurnIndicator: "Your turn: Select & bet!",
                 opponentTurnIndicator: "Opponent's turn (Click Next)",
                 emptyHoleMessage: "Empty hole!",
                 notYourTurnMessage: "Not your turn! Click 'Next'.",
                 invalidHoleMessage: "Invalid or empty hole!",
                 internalErrorMessage: "Internal simulation error.",
                 aidesEnabled: "Visual aids enabled",
                 aidesDisabled: "Visual aids disabled",
                 crossEnabled: "Red cross enabled",
                 crossDisabled: "Red cross disabled",
                 errorDisplayMessage: "Display error. Please reload.",
                 confirmResetHistory: "Are you sure you want to reset the entire history? This action is irreversible.",
                 historyResetSuccess: "History reset!",
                 copySuccess: "History content copied!",
                 copyError: "Error copying.",
                 copyPrepareError: "Error preparing copy.",
                 noHistory: "No game history recorded.",
                 helpTitle: "Help & Objective",
                 helpTextStandard: `<strong>Welcome to Awale Brain Training!</strong><br><br>Your goal is to <strong>think like a champion</strong> by guessing the move they played in a real game each time it's your turn (Player üòä ‚Üì).<br><br><strong>How to play:</strong><br>1. Choose a language and one of the first 3 available games.<br>2. When it's your turn (üòä ‚Üì), observe the board.<br>3. Click on one of your holes (A-F) containing seeds to select it.<br>4. Choose the percentage of your virtual pot to bet on this choice.<br>5. Click 'Place Bet!'. If your choice is correct, you win your bet. Otherwise, you lose it.<br>6. When it's the opponent's turn (üòî ‚Üë), click 'Next'.<br><br><strong>Upgrade to Premium!</strong><br>For a complete experience and to support our association, join <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. The Premium version unlocks the following features:<ul><li>Access to <strong>all training games</strong>.</li><li>The <strong>"Hist"</strong> (history) and <strong>"Rec"</strong> (record notes) buttons.</li><li>Activation of <strong>visual aids</strong> (capture/pressure indicators).</li><li>Activation of the <strong>red alignment cross</strong>.</li><li>Access to <strong>secret tips</strong>.</li></ul>`,
                 helpTextPremium: `<strong>Welcome to the Premium version!</strong><br><br>You have access to all features to train yourself to think like a champion.<br><br><strong>Premium Features:</strong><br><ul><li><strong>All Games:</strong> Access all games via the selector.</li><li><strong>History ("Hist"):</strong> Review your past games, statistics, and comments.</li><li><strong>AI Coaching via JSON Export:</strong> Use the "Copy (JSON)" button in the history. Paste the copied text into a conversational AI (like ChatGPT, Gemini, Mistral, etc.). The included prompt will ask the AI to analyze your games (errors, comments) and give you personalized coaching advice, directly in the language selected in the app!</li><li><strong>Recording ("Rec"):</strong> Add strategic notes to each move played.</li><li><strong>Visual Aids:</strong><ul><li>Activation/Deactivation: Long press (3s) the <strong>+</strong> button at the top right.</li><li>Flashing orange opponent hole: Your selected move captures directly.</li><li>Opponent hole with orange border: Pressure for possible future capture.</li><li>Your hole with dashed orange border: Threat of capture by the opponent.</li></ul></li><li><strong>Red Cross:</strong><ul><li>Activation/Deactivation: Single click the <strong>+</strong> button at the top right.</li><li>Helps visualize hole alignments.</li></ul></li></ul><strong>Activatable Secret Tips:</strong><br><ul><li><strong>Logo x3 clicks:</strong> Resets the current game.</li><li><strong>Pot x3 clicks:</strong> Toggles "Guaranteed Success" mode (all bets win).</li><li><strong>"I bet" text x3 clicks:</strong> Locks/Unlocks the selected bet percentage.</li><li><strong>Opponent 'a' hole (2s press):</strong> Undoes the last move played.</li><li><strong>Opponent 'f' + 'a' holes (3s simultaneous press):</strong> Shows the secret tips list.</li></ul>`,
                 secretMessage: "Hello",
                 secretTipsTitle: "Secret Tips (Premium)",
                 secretTips: [ "Logo x3 clicks: Reset game", "Pot x3 clicks: Guaranteed Success ON/OFF", "'I bet' x3 clicks: Lock/Unlock bet (%)", "Opponent 'f' hole (2s press): Hello", "Opponent 'a' hole (2s press): Undo last move", "Opponent 'f' + 'a' holes (3s simultaneous press): Show this list" ],
                 commentModalTitle: "Add a Comment",
                 commentInputPlaceholder: "Your strategic note here...",
                 // --- NEW COMMENT OPTIONS ---
                 commentOptionNoSeedsBC: "No seeds in holes B and C",
                 commentOptionOffensiveCapture: "Be Offensive (capture) > Defensive (escape)",
                 commentOptionBuildKrouOffensive: "Build Offensive Krou (D/E/F) > Defensive",
                 commentOptionBuildKrouDefensive: "Build Defensive Krou (C/D/E) > Offensive",
                 commentOptionBlockCounterKrou: "Block Opponent's Counter-Krou",
                 commentOptionBuild2Krous: "Build 2 Krous Simultaneously",
                 commentOptionCaptureLimit3: "Multiple Capture Limited to 3 Holes",
                 commentOptionCaptureMax5: "Max Multiple Capture (5 Holes)",
                 commentOptionAccelerate: "Speed Up the Game",
                 commentOptionSlowDown: "Slow Down the Game",
                 commentOptionTechErrorSelect: "Technical Hole Selection Error",
                 // --- END NEW OPTIONS ---
                 historyTitle: "Game History",
                 historyRecordTitle: (name, date) => `Game: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `Success: ${rate}% | Final Pot: ${pot}‚Ç¨ | Duration: ${duration}s`,
                 historyCommentsTitle: "Recorded Comments",
                 historyErrorsTitle: "Betting Errors",
                 historyNoComments: "No comments recorded for this game.",
                 historyNoErrors: "No betting errors recorded for this game.",
                 historyInProgress: "(In Progress)",
                 historyMoveLabel: "Move",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Bet <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pot ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "Premium Feature",
                 premiumModalText: "This feature, along with other benefits, is reserved for Premium members.",
                 premiumModalBenefitsTitle: "Premium Benefits:",
                 premiumBenefitLevels: "Access to all training games.",
                 premiumBenefitHistory: "'Hist' button to view and analyze your past games.",
                 premiumBenefitRecord: "'Rec' button to add strategic comments.",
                 premiumBenefitAids: "Activation of visual aids (captures/pressure).",
                 premiumBenefitCross: "Activation of the red alignment cross.",
                 premiumBenefitSecrets: "Access to secret tips.",
                 premiumModalHowto: "To unlock the Premium version and support our association, become a member of <strong>Jeux Nomades France</strong>:",
                 premiumModalActionLink: "Join the association",
                 gameDropdownFormat: (index, moves) => `Game ${index} (${moves} moves)`,
                 encouragingMessages: [ "Bravo!", "Great!", "Excellent!", "Keep it up!", "Impressive!", "Magnificent!", "Skilled!", "Wonderful!", "Incredible!", "Awesome!", "Perfect!", "Breathtaking!", "Rising Star!", "Sensational!", "Triumph!", "Master!", "Legendary!", "Genius!", "Champion!", "Immortal!" ]
             },
              es: {
                 pageTitle: "En la Mente de un Campe√≥n",
                 languageLabel: "Idioma:",
                 levelLabel: "Partida:",
                 title: "¬°En la Mente de un Campe√≥n!",
                 moveInfo: (p1, p2) => `Jugador üòä ‚Üì: ${p1} | Jugador üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `Pozo:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `√âxito:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | √öltimas jugadas: ${moves}`,
                 betLabel: "Apuesto",
                 betCaseLabel: "a",
                 betButton: "¬°Apostar!",
                 nextButton: "Siguiente",
                 recordButtonShort: "Grabar",
                 historyButtonShort: "Histo",
                 closeButton: "Cerrar",
                 saveButton: "Guardar",
                 cancelButton: "Cancelar",
                 copyButton: "Copiar (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Tu dinero virtual actual",
                 tooltipSuccessRate: "Porcentaje de apuestas correctas en esta partida",
                 tooltipRecord: "Grabar un comentario para esta jugada (Premium)",
                 tooltipHistory: "Ver el historial de partidas jugadas (Premium)",
                 tooltipHelp: "Mostrar Ayuda / Reglas",
                 tooltipTheme: "Modo Oscuro/Claro",
                 tooltipCross: "Opciones Premium (Cruz / Ayudas)",
                 resultInvalidBet: "¬°Apuesta inv√°lida!",
                 resultWin: "¬°Ganado!",
                 resultLose: "¬°Perdido!",
                 resultGameOver: "¬°Partida terminada!",
                 resetMessage: "¬°Juego reiniciado!",
                 premiumUnlockedMessage: "¬°Versi√≥n Premium activada! Funcionalidades desbloqueadas.",
                 successOnMessage: "√âxito garantizado ACTIVADO",
                 successOffMessage: "√âxito garantizado DESACTIVADO",
                 betLockedMessage: (pct) => `Apuesta bloqueada (${pct}%)`,
                 betUnlockedMessage: "Apuesta desbloqueada",
                 backMessage: "Deshacer realizado",
                 opponentTurnMessage: "Clic Siguiente (turno del oponente)",
                 playerTurnIndicator: "Tu turno: ¬°Selecciona y apuesta!",
                 opponentTurnIndicator: "Turno del oponente (Clic Siguiente)",
                 emptyHoleMessage: "¬°Casilla vac√≠a!",
                 notYourTurnMessage: "¬°No es tu turno! Haz clic en 'Siguiente'.",
                 invalidHoleMessage: "¬°Casilla inv√°lida o vac√≠a!",
                 internalErrorMessage: "Error interno de simulaci√≥n.",
                 aidesEnabled: "Ayudas visuales activadas",
                 aidesDisabled: "Ayudas visuales desactivadas",
                 crossEnabled: "Cruz roja activada",
                 crossDisabled: "Cruz roja desactivada",
                 errorDisplayMessage: "Error de visualizaci√≥n. Recarga.",
                 confirmResetHistory: "¬øEst√°s seguro de que quieres reiniciar todo el historial? Esta acci√≥n es irreversible.",
                 historyResetSuccess: "¬°Historial reiniciado!",
                 copySuccess: "¬°Contenido del historial copiado!",
                 copyError: "Error al copiar.",
                 copyPrepareError: "Error al preparar la copia.",
                 noHistory: "No hay historial de partidas guardado.",
                 helpTitle: "Ayuda y Objetivo",
                 helpTextStandard: `<strong>¬°Bienvenido al entrenamiento cerebral Awal√©!</strong><br><br>Tu objetivo es <strong>pensar como un campe√≥n</strong> adivinando la jugada que hizo en una partida real cada vez que sea tu turno (Jugador üòä ‚Üì).<br><br><strong>C√≥mo jugar:</strong><br>1. Elige un idioma y una de las 3 primeras partidas disponibles.<br>2. Cuando sea tu turno (üòä ‚Üì), observa el tablero.<br>3. Haz clic en una de tus casillas (A-F) que contenga semillas para seleccionarla.<br>4. Elige el porcentaje de tu pozo virtual a apostar por esta elecci√≥n.<br>5. Haz clic en '¬°Apostar!'. Si tu elecci√≥n es correcta, ganas tu apuesta. Si no, la pierdes.<br>6. Cuando sea el turno del oponente (üòî ‚Üë), haz clic en 'Siguiente'.<br><br><strong>¬°P√°sate a la Versi√≥n Premium!</strong><br>Para una experiencia completa y apoyar a nuestra asociaci√≥n, √∫nete a <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. La versi√≥n Premium desbloquea las siguientes funcionalidades:<ul><li>Acceso a <strong>todas las partidas</strong> de entrenamiento.</li><li>Los botones <strong>"Histo"</strong> (historial) y <strong>"Grabar"</strong> (toma de notas).</li><li>Activaci√≥n de las <strong>ayudas visuales</strong> (indicaciones de captura/presi√≥n).</li><li>Activaci√≥n de la <strong>cruz roja</strong> de alineaci√≥n.</li><li>Acceso a los <strong>trucos secretos</strong>.</li></ul>`,
                 helpTextPremium: `<strong>¬°Bienvenido a la versi√≥n Premium!</strong><br><br>Tienes acceso a todas las funcionalidades para entrenarte a pensar como un campe√≥n.<br><br><strong>Funcionalidades Premium:</strong><br><ul><li><strong>Todas las Partidas:</strong> Accede a todas las partidas mediante el selector.</li><li><strong>Historial ("Histo"):</strong> Consulta tus partidas anteriores, estad√≠sticas y comentarios.</li><li><strong>Coaching por IA v√≠a Exportar JSON:</strong> Utiliza el bot√≥n "Copiar (JSON)" en el historial. Pega el texto copiado en una Inteligencia Artificial conversacional (como ChatGPT, Gemini, Mistral, etc.). El prompt incluido le pedir√° a la IA que analice tus partidas (errores, comentarios) y te d√© consejos de coaching personalizados, ¬°directamente en el idioma seleccionado en la aplicaci√≥n!</li><li><strong>Grabaci√≥n ("Grabar"):</strong> A√±ade notas estrat√©gicas a cada jugada realizada.</li><li><strong>Ayudas Visuales:</strong><ul><li>Activaci√≥n/Desactivaci√≥n: Pulsaci√≥n larga (3s) en el bot√≥n <strong>+</strong> arriba a la derecha.</li><li>Casilla del oponente naranja parpadeante: Tu jugada seleccionada captura directamente.</li><li>Casilla del oponente con borde naranja: Presi√≥n para posible captura futura.</li><li>Tu casilla con borde naranja discontinuo: Amenaza de captura por el oponente.</li></ul></li><li><strong>Cruz Roja:</strong><ul><li>Activaci√≥n/Desactivaci√≥n: Clic simple en el bot√≥n <strong>+</strong> arriba a la derecha.</li><li>Ayuda a visualizar las alineaciones de casillas.</li></ul></li></ul><strong>Trucos Secretos Activables:</strong><br><ul><li><strong>Logo x3 clics:</strong> Reinicia la partida actual.</li><li><strong>Pozo x3 clics:</strong> Activa/Desactiva el modo "√âxito Garantizado" (todas las apuestas ganan).</li><li><strong>Texto "Apuesto" x3 clics:</strong> Bloquea/Desbloquea el porcentaje de apuesta seleccionado.</li><li><strong>Casilla 'a' del oponente (pulsaci√≥n 2s):</strong> Deshace la √∫ltima jugada realizada.</li><li><strong>Casillas 'f' + 'a' del oponente (pulsaci√≥n 3s simult√°nea):</strong> Muestra la lista de trucos secretos.</li></ul>`,
                 secretMessage: "Hola",
                 secretTipsTitle: "Trucos Secretos (Premium)",
                 secretTips: [ "Logo x3 clics: Reset partida", "Pozo x3 clics: √âxito garantizado ON/OFF", "'Apuesto' x3 clics: Bloquear/Desbloquear apuesta (%)", "Casilla 'f' oponente (pulsaci√≥n 2s): Hola", "Casilla 'a' oponente (pulsaci√≥n 2s): Deshacer √∫ltima jugada", "Casillas 'f' + 'a' oponentes (pulsaci√≥n 3s simult√°nea): Muestra esta lista" ],
                 commentModalTitle: "A√±adir un Comentario",
                 commentInputPlaceholder: "Tu nota estrat√©gica aqu√≠...",
                 // --- NUEVAS OPCIONES COMENTARIO ---
                 commentOptionNoSeedsBC: "Sin semillas en las casillas B y C",
                 commentOptionOffensiveCapture: "Ser Ofensivo (captura) > Defensivo (escape)",
                 commentOptionBuildKrouOffensive: "Construir Krou Ofensivo (D/E/F) > Defensivo",
                 commentOptionBuildKrouDefensive: "Construir Krou Defensivo (C/D/E) > Ofensivo",
                 commentOptionBlockCounterKrou: "Bloquear el Contra-Krou Adversario",
                 commentOptionBuild2Krous: "Construir 2 Krous al mismo tiempo",
                 commentOptionCaptureLimit3: "Captura m√∫ltiple limitada a 3 casillas",
                 commentOptionCaptureMax5: "Captura m√∫ltiple m√°xima (5 casillas)",
                 commentOptionAccelerate: "Acelerar el juego",
                 commentOptionSlowDown: "Ralentizar el juego",
                 commentOptionTechErrorSelect: "Error t√©cnico de selecci√≥n de casilla",
                 // --- FIN NUEVAS OPCIONES ---
                 historyTitle: "Historial de Partidas",
                 historyRecordTitle: (name, date) => `Partida: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `√âxito: ${rate}% | Pozo final: ${pot}‚Ç¨ | Duraci√≥n: ${duration}s`,
                 historyCommentsTitle: "Comentarios Guardados",
                 historyErrorsTitle: "Errores de Apuesta",
                 historyNoComments: "No hay comentarios guardados para esta partida.",
                 historyNoErrors: "No hay errores de apuesta guardados para esta partida.",
                 historyInProgress: "(En curso)",
                 historyMoveLabel: "Jugada",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Apostado <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pozo ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "Funcionalidad Premium",
                 premiumModalText: "Esta funcionalidad, junto con otros beneficios, est√° reservada para miembros Premium.",
                 premiumModalBenefitsTitle: "Beneficios Premium:",
                 premiumBenefitLevels: "Acceso a todas las partidas de entrenamiento.",
                 premiumBenefitHistory: "Bot√≥n 'Histo' para ver y analizar tus partidas anteriores.",
                 premiumBenefitRecord: "Bot√≥n 'Grabar' para a√±adir comentarios estrat√©gicos.",
                 premiumBenefitAids: "Activaci√≥n de ayudas visuales (capturas/presi√≥n).",
                 premiumBenefitCross: "Activaci√≥n de la cruz roja de alineaci√≥n.",
                 premiumBenefitSecrets: "Acceso a trucos secretos.",
                 premiumModalHowto: "Para desbloquear la versi√≥n Premium y apoyar a nuestra asociaci√≥n, hazte miembro de <strong>Jeux Nomades France</strong>:",
                 premiumModalActionLink: "Unirse a la asociaci√≥n",
                 gameDropdownFormat: (index, moves) => `Partida ${index} (${moves} jugadas)`,
                 encouragingMessages: [ "¬°Bravo!", "¬°Genial!", "¬°Excelente!", "¬°Sigue as√≠!", "¬°Impresionante!", "¬°Magn√≠fico!", "¬°H√°bil!", "¬°Maravilloso!", "¬°Incre√≠ble!", "¬°Asombroso!", "¬°Perfecto!", "¬°Impresionante!", "¬°Estrella en ascenso!", "¬°Sensacional!", "¬°Triunfo!", "¬°Maestro!", "¬°Legendario!", "¬°Genio!", "¬°Campe√≥n!", "¬°Inmortal!" ]
             },
             ru: {
                 pageTitle: "–í –£–º–µ –ß–µ–º–ø–∏–æ–Ω–∞",
                 languageLabel: "–Ø–∑—ã–∫:",
                 levelLabel: "–ò–≥—Ä–∞:",
                 title: "–í –£–º–µ –ß–µ–º–ø–∏–æ–Ω–∞!",
                 moveInfo: (p1, p2) => `–ò–≥—Ä–æ–∫ üòä ‚Üì: ${p1} | –ò–≥—Ä–æ–∫ üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `–ë–∞–Ω–∫:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `–£—Å–ø–µ—Ö:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ö–æ–¥—ã: ${moves}`,
                 betLabel: "–°—Ç–∞–≤–∫–∞",
                 betCaseLabel: "–Ω–∞",
                 betButton: "–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É!",
                 nextButton: "–°–ª–µ–¥—É—é—â–∏–π",
                 recordButtonShort: "–ó–∞–ø",
                 historyButtonShort: "–ò—Å—Ç",
                 closeButton: "–ó–∞–∫—Ä—ã—Ç—å",
                 saveButton: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
                 cancelButton: "–û—Ç–º–µ–Ω–∞",
                 copyButton: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å (JSON)",
                 resetButton: "–°–±—Ä–æ—Å",
                 tooltipPot: "–í–∞—à–∏ —Ç–µ–∫—É—â–∏–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ –¥–µ–Ω—å–≥–∏",
                 tooltipSuccessRate: "–ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å—Ç–∞–≤–æ–∫ –≤ —ç—Ç–æ–π –∏–≥—Ä–µ",
                 tooltipRecord: "–ó–∞–ø–∏—Å–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —ç—Ç–æ–º—É —Ö–æ–¥—É (–ü—Ä–µ–º–∏—É–º)",
                 tooltipHistory: "–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –∏–≥—Ä (–ü—Ä–µ–º–∏—É–º)",
                 tooltipHelp: "–ü–æ–∫–∞–∑–∞—Ç—å –°–ø—Ä–∞–≤–∫—É / –ü—Ä–∞–≤–∏–ª–∞",
                 tooltipTheme: "–¢–µ–º–Ω—ã–π/–°–≤–µ—Ç–ª—ã–π —Ä–µ–∂–∏–º",
                 tooltipCross: "–ü—Ä–µ–º–∏—É–º –û–ø—Ü–∏–∏ (–ö—Ä–µ—Å—Ç / –ü–æ–º–æ—â—å)",
                 resultInvalidBet: "–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–∞–≤–∫–∞!",
                 resultWin: "–í—ã–∏–≥—Ä–∞–ª!",
                 resultLose: "–ü—Ä–æ–∏–≥—Ä–∞–ª!",
                 resultGameOver: "–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!",
                 resetMessage: "–ò–≥—Ä–∞ —Å–±—Ä–æ—à–µ–Ω–∞!",
                 premiumUnlockedMessage: "–ü—Ä–µ–º–∏—É–º –í–µ—Ä—Å–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞! –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.",
                 successOnMessage: "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–ö–õ",
                 successOffMessage: "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–´–ö–õ",
                 betLockedMessage: (pct) => `–°—Ç–∞–≤–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ (${pct}%)`,
                 betUnlockedMessage: "–°—Ç–∞–≤–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞",
                 backMessage: "–•–æ–¥ –æ—Ç–º–µ–Ω–µ–Ω",
                 opponentTurnMessage: "–ù–∞–∂–º–∏—Ç–µ –°–ª–µ–¥—É—é—â–∏–π (—Ö–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞)",
                 playerTurnIndicator: "–í–∞—à —Ö–æ–¥: –í—ã–±–µ—Ä–∏—Ç–µ –∏ —Å–¥–µ–ª–∞–π—Ç–µ —Å—Ç–∞–≤–∫—É!",
                 opponentTurnIndicator: "–•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–ù–∞–∂–º–∏—Ç–µ –°–ª–µ–¥—É—é—â–∏–π)",
                 emptyHoleMessage: "–ü—É—Å—Ç–∞—è –ª—É–Ω–∫–∞!",
                 notYourTurnMessage: "–ù–µ –≤–∞—à —Ö–æ–¥! –ù–∞–∂–º–∏—Ç–µ '–°–ª–µ–¥—É—é—â–∏–π'.",
                 invalidHoleMessage: "–ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ –ø—É—Å—Ç–∞—è –ª—É–Ω–∫–∞!",
                 internalErrorMessage: "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–∏–º—É–ª—è—Ü–∏–∏.",
                 aidesEnabled: "–í–∏–∑—É–∞–ª—å–Ω–∞—è –ø–æ–º–æ—â—å –≤–∫–ª—é—á–µ–Ω–∞",
                 aidesDisabled: "–í–∏–∑—É–∞–ª—å–Ω–∞—è –ø–æ–º–æ—â—å –≤—ã–∫–ª—é—á–µ–Ω–∞",
                 crossEnabled: "–ö—Ä–∞—Å–Ω—ã–π –∫—Ä–µ—Å—Ç –≤–∫–ª—é—á–µ–Ω",
                 crossDisabled: "–ö—Ä–∞—Å–Ω—ã–π –∫—Ä–µ—Å—Ç –≤—ã–∫–ª—é—á–µ–Ω",
                 errorDisplayMessage: "–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ.",
                 confirmResetHistory: "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.",
                 historyResetSuccess: "–ò—Å—Ç–æ—Ä–∏—è —Å–±—Ä–æ—à–µ–Ω–∞!",
                 copySuccess: "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏—Å—Ç–æ—Ä–∏–∏ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!",
                 copyError: "–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è.",
                 copyPrepareError: "–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∫ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—é.",
                 noHistory: "–ò—Å—Ç–æ—Ä–∏—è –∏–≥—Ä –Ω–µ –∑–∞–ø–∏—Å–∞–Ω–∞.",
                 helpTitle: "–°–ø—Ä–∞–≤–∫–∞ –∏ –¶–µ–ª—å",
                 helpTextStandard: `<strong>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É –º–æ–∑–≥–∞ –ê–≤–∞–ª–µ!</strong><br><br>–í–∞—à–∞ —Ü–µ–ª—å - <strong>–¥—É–º–∞—Ç—å –∫–∞–∫ —á–µ–º–ø–∏–æ–Ω</strong>, —É–≥–∞–¥—ã–≤–∞—è —Ö–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –æ–Ω —Å–¥–µ–ª–∞–ª –≤ —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ, –∫–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –≤–∞—à–∞ –æ—á–µ—Ä–µ–¥—å (–ò–≥—Ä–æ–∫ üòä ‚Üì).<br><br><strong>–ö–∞–∫ –∏–≥—Ä–∞—Ç—å:</strong><br>1. –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∏ –æ–¥–Ω—É –∏–∑ –ø–µ—Ä–≤—ã—Ö 3 –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–≥—Ä.<br>2. –ö–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –≤–∞—à–∞ –æ—á–µ—Ä–µ–¥—å (üòä ‚Üì), –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –¥–æ—Å–∫—É.<br>3. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –æ–¥–Ω—É –∏–∑ –≤–∞—à–∏—Ö –ª—É–Ω–æ–∫ (A-F), —Å–æ–¥–µ—Ä–∂–∞—â—É—é —Å–µ–º–µ–Ω–∞, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –µ–µ.<br>4. –í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ—Ü–µ–Ω—Ç –≤–∞—à–µ–≥–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –±–∞–Ω–∫–∞ –¥–ª—è —Å—Ç–∞–≤–∫–∏ –Ω–∞ —ç—Ç–æ—Ç –≤—ã–±–æ—Ä.<br>5. –ù–∞–∂–º–∏—Ç–µ '–°–¥–µ–ª–∞—Ç—å —Å—Ç–∞–≤–∫—É!'. –ï—Å–ª–∏ –≤–∞—à –≤—ã–±–æ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π, –≤—ã –≤—ã–∏–≥—Ä—ã–≤–∞–µ—Ç–µ —Å—Ç–∞–≤–∫—É. –ò–Ω–∞—á–µ - –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç–µ.<br>6. –ö–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –æ—á–µ—Ä–µ–¥—å –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (üòî ‚Üë), –Ω–∞–∂–º–∏—Ç–µ '–°–ª–µ–¥—É—é—â–∏–π'.<br><br><strong>–ü–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞ –ü—Ä–µ–º–∏—É–º!</strong><br>–î–ª—è –ø–æ–ª–Ω–æ–≥–æ –æ–ø—ã—Ç–∞ –∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –Ω–∞—à–µ–π –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏, –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç —Å–ª–µ–¥—É—é—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏:<ul><li>–î–æ—Å—Ç—É–ø –∫–æ <strong>–≤—Å–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º –∏–≥—Ä–∞–º</strong>.</li><li>–ö–Ω–æ–ø–∫–∏ <strong>"–ò—Å—Ç"</strong> (–∏—Å—Ç–æ—Ä–∏—è) –∏ <strong>"–ó–∞–ø"</strong> (–∑–∞–ø–∏—Å—å –∑–∞–º–µ—Ç–æ–∫).</li><li>–ê–∫—Ç–∏–≤–∞—Ü–∏—è <strong>–≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø–æ–º–æ—â–∏</strong> (–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∑–∞—Ö–≤–∞—Ç–∞/–¥–∞–≤–ª–µ–Ω–∏—è).</li><li>–ê–∫—Ç–∏–≤–∞—Ü–∏—è <strong>–∫—Ä–∞—Å–Ω–æ–≥–æ –∫—Ä–µ—Å—Ç–∞</strong> –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è.</li><li>–î–æ—Å—Ç—É–ø –∫ <strong>—Å–µ–∫—Ä–µ—Ç–Ω—ã–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º</strong>.</li></ul>`,
                 helpTextPremium: `<strong>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—é!</strong><br><br>–£ –≤–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º, —á—Ç–æ–±—ã —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è –¥—É–º–∞—Ç—å –∫–∞–∫ —á–µ–º–ø–∏–æ–Ω.<br><br><strong>–ü—Ä–µ–º–∏—É–º –§—É–Ω–∫—Ü–∏–∏:</strong><br><ul><li><strong>–í—Å–µ –ò–≥—Ä—ã:</strong> –î–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∏–≥—Ä–∞–º —á–µ—Ä–µ–∑ —Å–µ–ª–µ–∫—Ç–æ—Ä.</li><li><strong>–ò—Å—Ç–æ—Ä–∏—è ("–ò—Å—Ç"):</strong> –ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ —Å–≤–æ–∏ –ø—Ä–æ—à–ª—ã–µ –∏–≥—Ä—ã, —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏.</li><li><strong>–ö–æ—É—á–∏–Ω–≥ –ò–ò —á–µ—Ä–µ–∑ –≠–∫—Å–ø–æ—Ä—Ç JSON:</strong> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å (JSON)" –≤ –∏—Å—Ç–æ—Ä–∏–∏. –í—Å—Ç–∞–≤—å—Ç–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ —Ä–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–π –ò–ò (–Ω–∞–ø—Ä–∏–º–µ—Ä, ChatGPT, Gemini, Mistral –∏ —Ç.–¥.). –í–∫–ª—é—á–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –ø–æ–ø—Ä–æ—Å–∏—Ç –ò–ò –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–∏ –∏–≥—Ä—ã (–æ—à–∏–±–∫–∏, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏) –∏ –¥–∞—Ç—å –≤–∞–º –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Å–æ–≤–µ—Ç—ã –ø–æ –∫–æ—É—á–∏–Ω–≥—É, –ø—Ä—è–º–æ –Ω–∞ —è–∑—ã–∫–µ, –≤—ã–±—Ä–∞–Ω–Ω–æ–º –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏!</li><li><strong>–ó–∞–ø–∏—Å—å ("–ó–∞–ø"):</strong> –î–æ–±–∞–≤–ª—è–π—Ç–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ –∑–∞–º–µ—Ç–∫–∏ –∫ –∫–∞–∂–¥–æ–º—É —Å–¥–µ–ª–∞–Ω–Ω–æ–º—É —Ö–æ–¥—É.</li><li><strong>–í–∏–∑—É–∞–ª—å–Ω–∞—è –ü–æ–º–æ—â—å:</strong><ul><li>–í–∫–ª—é—á–µ–Ω–∏–µ/–í—ã–∫–ª—é—á–µ–Ω–∏–µ: –î–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ (3—Å) –Ω–∞ –∫–Ω–æ–ø–∫—É <strong>+</strong> –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É.</li><li>–ú–∏–≥–∞—é—â–∞—è –æ—Ä–∞–Ω–∂–µ–≤–∞—è –ª—É–Ω–∫–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞: –í–∞—à –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ö–æ–¥ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–ø—Ä—è–º—É—é.</li><li>–õ—É–Ω–∫–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ —Å –æ—Ä–∞–Ω–∂–µ–≤–æ–π —Ä–∞–º–∫–æ–π: –î–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –±—É–¥—É—â–µ–≥–æ –∑–∞—Ö–≤–∞—Ç–∞.</li><li>–í–∞—à–∞ –ª—É–Ω–∫–∞ —Å –ø—É–Ω–∫—Ç–∏—Ä–Ω–æ–π –æ—Ä–∞–Ω–∂–µ–≤–æ–π —Ä–∞–º–∫–æ–π: –£–≥—Ä–æ–∑–∞ –∑–∞—Ö–≤–∞—Ç–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–º.</li></ul></li><li><strong>–ö—Ä–∞—Å–Ω—ã–π –ö—Ä–µ—Å—Ç:</strong><ul><li>–í–∫–ª—é—á–µ–Ω–∏–µ/–í—ã–∫–ª—é—á–µ–Ω–∏–µ: –û–¥–∏–Ω–æ—á–Ω—ã–π –∫–ª–∏–∫ –ø–æ –∫–Ω–æ–ø–∫–µ <strong>+</strong> –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É.</li><li>–ü–æ–º–æ–≥–∞–µ—Ç –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ª—É–Ω–æ–∫.</li></ul></li></ul><strong>–ê–∫—Ç–∏–≤–∏—Ä—É–µ–º—ã–µ –°–µ–∫—Ä–µ—Ç–Ω—ã–µ –ü–æ–¥—Å–∫–∞–∑–∫–∏:</strong><br><ul><li><strong>–õ–æ–≥–æ—Ç–∏–ø x3 –∫–ª–∏–∫–∞:</strong> –°–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â—É—é –∏–≥—Ä—É.</li><li><strong>–ë–∞–Ω–∫ x3 –∫–ª–∏–∫–∞:</strong> –í–∫–ª—é—á–∞–µ—Ç/–í—ã–∫–ª—é—á–∞–µ—Ç —Ä–µ–∂–∏–º "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö" (–≤—Å–µ —Å—Ç–∞–≤–∫–∏ –≤—ã–∏–≥—Ä—ã–≤–∞—é—Ç).</li><li><strong>–¢–µ–∫—Å—Ç "–°—Ç–∞–≤–∫–∞" x3 –∫–ª–∏–∫–∞:</strong> –ë–ª–æ–∫–∏—Ä—É–µ—Ç/–†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç —Å—Ç–∞–≤–∫–∏.</li><li><strong>–õ—É–Ω–∫–∞ 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 2—Å):</strong> –û—Ç–º–µ–Ω—è–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–¥–µ–ª–∞–Ω–Ω—ã–π —Ö–æ–¥.</li><li><strong>–õ—É–Ω–∫–∏ 'f' + 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 3—Å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ):</strong> –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫.</li></ul>`,
                 secretMessage: "–ü—Ä–∏–≤–µ—Ç, –≠—Ä–∏–∫",
                 secretTipsTitle: "–°–µ–∫—Ä–µ—Ç–Ω—ã–µ –ü–æ–¥—Å–∫–∞–∑–∫–∏ (–ü—Ä–µ–º–∏—É–º)",
                 secretTips: [ "–õ–æ–≥–æ—Ç–∏–ø x3 –∫–ª–∏–∫–∞: –°–±—Ä–æ—Å –∏–≥—Ä—ã", "–ë–∞–Ω–∫ x3 –∫–ª–∏–∫–∞: –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–ö–õ/–í–´–ö–õ", "'–°—Ç–∞–≤–∫–∞' x3 –∫–ª–∏–∫–∞: –ë–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å/–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞–≤–∫—É (%)", "–õ—É–Ω–∫–∞ 'f' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 2—Å): –ü—Ä–∏–≤–µ—Ç, –≠—Ä–∏–∫", "–õ—É–Ω–∫–∞ 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 2—Å): –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ö–æ–¥", "–õ—É–Ω–∫–∏ 'f' + 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 3—Å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ): –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ—Ç —Å–ø–∏—Å–æ–∫" ],
                 commentModalTitle: "–î–æ–±–∞–≤–∏—Ç—å –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π",
                 commentInputPlaceholder: "–í–∞—à–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∞—è –∑–∞–º–µ—Ç–∫–∞ –∑–¥–µ—Å—å...",
                 // --- –ù–û–í–´–ï –û–ü–¶–ò–ò –ö–û–ú–ú–ï–ù–¢–ê–†–ò–Ø ---
                 commentOptionNoSeedsBC: "–ù–µ—Ç —Å–µ–º—è–Ω –≤ –ª—É–Ω–∫–∞—Ö B –∏ C",
                 commentOptionOffensiveCapture: "–ë—ã—Ç—å –ù–∞—Å—Ç—É–ø–∞—Ç–µ–ª—å–Ω—ã–º (–∑–∞—Ö–≤–∞—Ç) > –û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–º (—É—Ö–æ–¥)",
                 commentOptionBuildKrouOffensive: "–°—Ç—Ä–æ–∏—Ç—å –ù–∞—Å—Ç—É–ø–∞—Ç–µ–ª—å–Ω—ã–π –ö—Ä—É (D/E/F) > –û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–π",
                 commentOptionBuildKrouDefensive: "–°—Ç—Ä–æ–∏—Ç—å –û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ö—Ä—É (C/D/E) > –ù–∞—Å—Ç—É–ø–∞—Ç–µ–ª—å–Ω—ã–π",
                 commentOptionBlockCounterKrou: "–ë–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ö–æ–Ω—Ç—Ä-–ö—Ä—É –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞",
                 commentOptionBuild2Krous: "–°—Ç—Ä–æ–∏—Ç—å 2 –ö—Ä—É –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ",
                 commentOptionCaptureLimit3: "–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∑–∞—Ö–≤–∞—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω 3 –ª—É–Ω–∫–∞–º–∏",
                 commentOptionCaptureMax5: "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∑–∞—Ö–≤–∞—Ç (5 –ª—É–Ω–æ–∫)",
                 commentOptionAccelerate: "–£—Å–∫–æ—Ä–∏—Ç—å –∏–≥—Ä—É",
                 commentOptionSlowDown: "–ó–∞–º–µ–¥–ª–∏—Ç—å –∏–≥—Ä—É",
                 commentOptionTechErrorSelect: "–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞ –ª—É–Ω–∫–∏",
                 // --- –ö–û–ù–ï–¶ –ù–û–í–´–• –û–ü–¶–ò–ô ---
                 historyTitle: "–ò—Å—Ç–æ—Ä–∏—è –ò–≥—Ä",
                 historyRecordTitle: (name, date) => `–ò–≥—Ä–∞: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `–£—Å–ø–µ—Ö: ${rate}% | –§–∏–Ω–∞–ª—å–Ω—ã–π –ë–∞–Ω–∫: ${pot}‚Ç¨ | –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${duration}—Å`,
                 historyCommentsTitle: "–ó–∞–ø–∏—Å–∞–Ω–Ω—ã–µ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏",
                 historyErrorsTitle: "–û—à–∏–±–∫–∏ –°—Ç–∞–≤–æ–∫",
                 historyNoComments: "–ù–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –¥–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã.",
                 historyNoErrors: "–ù–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫ —Å—Ç–∞–≤–æ–∫ –¥–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã.",
                 historyInProgress: "(–í –ø—Ä–æ—Ü–µ—Å—Å–µ)",
                 historyMoveLabel: "–•–æ–¥",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `–°—Ç–∞–≤–∫–∞ <span class="error-detail">${bet}</span> –ø—Ä–æ—Ç–∏–≤ <span class="error-detail">${correct}</span> (–ë–∞–Ω–∫ ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "–ü—Ä–µ–º–∏—É–º –§—É–Ω–∫—Ü–∏—è",
                 premiumModalText: "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è, –∞ —Ç–∞–∫–∂–µ –¥—Ä—É–≥–∏–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞, –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –ü—Ä–µ–º–∏—É–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.",
                 premiumModalBenefitsTitle: "–ü—Ä–µ–º–∏—É–º –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:",
                 premiumBenefitLevels: "–î–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º –∏–≥—Ä–∞–º.",
                 premiumBenefitHistory: "–ö–Ω–æ–ø–∫–∞ '–ò—Å—Ç' –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏ –∞–Ω–∞–ª–∏–∑–∞ –≤–∞—à–∏—Ö –ø—Ä–æ—à–ª—ã—Ö –∏–≥—Ä.",
                 premiumBenefitRecord: "–ö–Ω–æ–ø–∫–∞ '–ó–∞–ø' –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.",
                 premiumBenefitAids: "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø–æ–º–æ—â–∏ (–∑–∞—Ö–≤–∞—Ç—ã/–¥–∞–≤–ª–µ–Ω–∏–µ).",
                 premiumBenefitCross: "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –∫—Ä–∞—Å–Ω–æ–≥–æ –∫—Ä–µ—Å—Ç–∞ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è.",
                 premiumBenefitSecrets: "–î–æ—Å—Ç—É–ø –∫ —Å–µ–∫—Ä–µ—Ç–Ω—ã–º –ø–æ–¥—Å–∫–∞–∑–∫–∞–º.",
                 premiumModalHowto: "–ß—Ç–æ–±—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—é –∏ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –Ω–∞—à—É –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—é, —Å—Ç–∞–Ω—å—Ç–µ —á–ª–µ–Ω–æ–º <strong>Jeux Nomades France</strong>:",
                 premiumModalActionLink: "–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏",
                 gameDropdownFormat: (index, moves) => `–ò–≥—Ä–∞ ${index} (${moves} —Ö–æ–¥–æ–≤)`,
                 encouragingMessages: [ "–ë—Ä–∞–≤–æ!", "–û—Ç–ª–∏—á–Ω–æ!", "–ü—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω–æ!", "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!", "–í–ø–µ—á–∞—Ç–ª—è—é—â–µ!", "–í–µ–ª–∏–∫–æ–ª–µ–ø–Ω–æ!", "–£–º–µ–ª–æ!", "–ó–∞–º–µ—á–∞—Ç–µ–ª—å–Ω–æ!", "–ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!", "–ü–æ—Ç—Ä—è—Å–∞—é—â–µ!", "–ò–¥–µ–∞–ª—å–Ω–æ!", "–ó–∞—Ö–≤–∞—Ç—ã–≤–∞—é—â–µ!", "–í–æ—Å—Ö–æ–¥—è—â–∞—è –∑–≤–µ–∑–¥–∞!", "–°–µ–Ω—Å–∞—Ü–∏–æ–Ω–Ω–æ!", "–¢—Ä–∏—É–º—Ñ!", "–ú–∞—Å—Ç–µ—Ä!", "–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ!", "–ì–µ–Ω–∏–π!", "–ß–µ–º–ø–∏–æ–Ω!", "–ë–µ—Å—Å–º–µ—Ä—Ç–Ω—ã–π!" ]
             },
             zh: {
                 pageTitle: "ÂÜ†ÂÜõÊÄùÁª¥",
                 languageLabel: "ËØ≠Ë®Ä:",
                 levelLabel: "Ê£ãÂ±Ä:",
                 title: "ÂÜ†ÂÜõÊÄùÁª¥!",
                 moveInfo: (p1, p2) => `Áé©ÂÆ∂ üòä ‚Üì: ${p1} | Áé©ÂÆ∂ üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `ÂΩ©Ê±†:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `ÊàêÂäüÁéá:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | ÊúÄËøëÂá†Ê≠•: ${moves}`,
                 betLabel: "Êàë‰∏ãÊ≥®",
                 betCaseLabel: "Âú®",
                 betButton: "‰∏ãÊ≥®!",
                 nextButton: "‰∏ã‰∏ÄÊ≠•",
                 recordButtonShort: "ËÆ∞ÂΩï",
                 historyButtonShort: "ÂéÜÂè≤",
                 closeButton: "ÂÖ≥Èó≠",
                 saveButton: "‰øùÂ≠ò",
                 cancelButton: "ÂèñÊ∂à",
                 copyButton: "Â§çÂà∂ (JSON)",
                 resetButton: "ÈáçÁΩÆ",
                 tooltipPot: "ÊÇ®ÂΩìÂâçÁöÑËôöÊãüËµÑÈáë",
                 tooltipSuccessRate: "Ê≠§Â±ÄÊ∏∏Êàè‰∏≠Ê≠£Á°Æ‰∏ãÊ≥®ÁöÑÁôæÂàÜÊØî",
                 tooltipRecord: "‰∏∫Ê≠§Ê≠•ËÆ∞ÂΩïËØÑËÆ∫ (È´òÁ∫ßÁâà)",
                 tooltipHistory: "Êü•ÁúãÂ∑≤Áé©ËøáÁöÑÊ£ãÂ±ÄÂéÜÂè≤ (È´òÁ∫ßÁâà)",
                 tooltipHelp: "ÊòæÁ§∫Â∏ÆÂä©/ËßÑÂàô",
                 tooltipTheme: "Ê∑±Ëâ≤/ÊµÖËâ≤Ê®°Âºè",
                 tooltipCross: "È´òÁ∫ßÈÄâÈ°π (ÂçÅÂ≠óÁ∫ø / ËæÖÂä©)",
                 resultInvalidBet: "Êó†Êïà‰∏ãÊ≥®!",
                 resultWin: "Ëµ¢‰∫Ü!",
                 resultLose: "Ëæì‰∫Ü!",
                 resultGameOver: "Ê£ãÂ±ÄÁªìÊùü!",
                 resetMessage: "Ê£ãÂ±ÄÂ∑≤ÈáçÁΩÆ!",
                 premiumUnlockedMessage: "È´òÁ∫ßÁâàÂ∑≤ÊøÄÊ¥ª! ÂäüËÉΩÂ∑≤Ëß£ÈîÅ„ÄÇ",
                 successOnMessage: "‰øùËØÅÊàêÂäü ÂºÄÂêØ",
                 successOffMessage: "‰øùËØÅÊàêÂäü ÂÖ≥Èó≠",
                 betLockedMessage: (pct) => `‰∏ãÊ≥®Â∑≤ÈîÅÂÆö (${pct}%)`,
                 betUnlockedMessage: "‰∏ãÊ≥®Â∑≤Ëß£ÈîÅ",
                 backMessage: "Êí§ÈîÄÊàêÂäü",
                 opponentTurnMessage: "ÁÇπÂáª‰∏ã‰∏ÄÊ≠• (ÂØπÊâãÂõûÂêà)",
                 playerTurnIndicator: "ËΩÆÂà∞ÊÇ®: ÈÄâÊã©Âπ∂‰∏ãÊ≥®!",
                 opponentTurnIndicator: "ÂØπÊâãÂõûÂêà (ÁÇπÂáª‰∏ã‰∏ÄÊ≠•)",
                 emptyHoleMessage: "Á©∫Á©¥!",
                 notYourTurnMessage: "ËøòÊ≤°ËΩÆÂà∞ÊÇ®! ÁÇπÂáª '‰∏ã‰∏ÄÊ≠•'.",
                 invalidHoleMessage: "Êó†ÊïàÊàñÁ©∫Á©¥!",
                 internalErrorMessage: "ÂÜÖÈÉ®Ê®°ÊãüÈîôËØØ„ÄÇ",
                 aidesEnabled: "ËßÜËßâËæÖÂä©Â∑≤ÂêØÁî®",
                 aidesDisabled: "ËßÜËßâËæÖÂä©Â∑≤Á¶ÅÁî®",
                 crossEnabled: "Á∫¢ÂçÅÂ≠óÁ∫øÂ∑≤ÂêØÁî®",
                 crossDisabled: "Á∫¢ÂçÅÂ≠óÁ∫øÂ∑≤Á¶ÅÁî®",
                 errorDisplayMessage: "ÊòæÁ§∫ÈîôËØØ„ÄÇËØ∑ÈáçÊñ∞Âä†ËΩΩ„ÄÇ",
                 confirmResetHistory: "ÊÇ®Á°ÆÂÆöË¶ÅÈáçÁΩÆÂÖ®ÈÉ®ÂéÜÂè≤ËÆ∞ÂΩïÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÈÄÜ„ÄÇ",
                 historyResetSuccess: "ÂéÜÂè≤ËÆ∞ÂΩïÂ∑≤ÈáçÁΩÆ!",
                 copySuccess: "ÂéÜÂè≤ËÆ∞ÂΩïÂÜÖÂÆπÂ∑≤Â§çÂà∂!",
                 copyError: "Â§çÂà∂Êó∂Âá∫Èîô„ÄÇ",
                 copyPrepareError: "ÂáÜÂ§áÂ§çÂà∂Êó∂Âá∫Èîô„ÄÇ",
                 noHistory: "Ê≤°ÊúâËÆ∞ÂΩïÁöÑÊ£ãÂ±ÄÂéÜÂè≤„ÄÇ",
                 helpTitle: "Â∏ÆÂä©‰∏éÁõÆÊ†á",
                 helpTextStandard: `<strong>Ê¨¢ËøéÊù•Âà∞ Awal√© Â§ßËÑëËÆ≠ÁªÉ!</strong><br><br>ÊÇ®ÁöÑÁõÆÊ†áÊòØ<strong>ÂÉèÂÜ†ÂÜõ‰∏ÄÊ†∑ÊÄùËÄÉ</strong>ÔºåÂú®ÊØèÊ¨°ËΩÆÂà∞ÊÇ®Êó∂ (Áé©ÂÆ∂ üòä ‚Üì) ÁåúÊµã‰ªñ‰ª¨Âú®ÁúüÂÆûÊ£ãÂ±Ä‰∏≠Ëµ∞Âá∫ÁöÑÈÇ£‰∏ÄÊ≠•„ÄÇ<br><br><strong>Áé©Ê≥ïËØ¥Êòé:</strong><br>1. ÈÄâÊã©‰∏ÄÁßçËØ≠Ë®ÄÂíåÂâç3‰∏™ÂèØÁî®Ê£ãÂ±Ä‰πã‰∏Ä„ÄÇ<br>2. ËΩÆÂà∞ÊÇ®Êó∂ (üòä ‚Üì)ÔºåËßÇÂØüÊ£ãÁõò„ÄÇ<br>3. ÁÇπÂáªÊÇ®ÂÖ∂‰∏≠‰∏Ä‰∏™ÂåÖÂê´Ê£ãÂ≠ê (ÁßçÂ≠ê) ÁöÑÊ£ãÁ©¥ (A-F) Êù•ÈÄâÊã©ÂÆÉ„ÄÇ<br>4. ÈÄâÊã©ÊÇ®ËôöÊãüÂΩ©Ê±†ÁöÑ‰∏Ä‰∏™ÁôæÂàÜÊØîÔºåÂØπÊ≠§ÈÄâÊã©‰∏ãÊ≥®„ÄÇ<br>5. ÁÇπÂáª '‰∏ãÊ≥®!'„ÄÇÂ¶ÇÊûúÊÇ®ÁöÑÈÄâÊã©Ê≠£Á°ÆÔºåÊÇ®Ëµ¢ÂæóËµåÊ≥®„ÄÇÂê¶ÂàôÔºåÊÇ®ËæìÊéâËµåÊ≥®„ÄÇ<br>6. ËΩÆÂà∞ÂØπÊâãÊó∂ (üòî ‚Üë)ÔºåÁÇπÂáª '‰∏ã‰∏ÄÊ≠•'„ÄÇ<br><br><strong>ÂçáÁ∫ßÂà∞È´òÁ∫ßÁâà!</strong><br>‰∏∫‰∫ÜËé∑ÂæóÂÆåÊï¥‰ΩìÈ™åÂπ∂ÊîØÊåÅÊàë‰ª¨ÁöÑÂçè‰ºöÔºåËØ∑Âä†ÂÖ• <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>„ÄÇÈ´òÁ∫ßÁâàËß£ÈîÅ‰ª•‰∏ãÂäüËÉΩÔºö<ul><li>ËÆøÈóÆ<strong>ÊâÄÊúâËÆ≠ÁªÉÊ£ãÂ±Ä</strong>„ÄÇ</li><li><strong>"ÂéÜÂè≤"</strong> (ÂéÜÂè≤ËÆ∞ÂΩï) Âíå <strong>"ËÆ∞ÂΩï"</strong> (ËÆ∞ÂΩïÁ¨îËÆ∞) ÊåâÈíÆ„ÄÇ</li><li>ÊøÄÊ¥ª<strong>ËßÜËßâËæÖÂä©</strong> (ÊäìÂ≠ê/ÂéãÂäõÊåáÁ§∫)„ÄÇ</li><li>ÊøÄÊ¥ª<strong>Á∫¢Ëâ≤ÂØπÈΩêÂçÅÂ≠óÁ∫ø</strong>„ÄÇ</li><li>ËÆøÈóÆ<strong>ÁßòÂØÜÊèêÁ§∫</strong>„ÄÇ</li></ul>`,
                 helpTextPremium: `<strong>Ê¨¢ËøéÊù•Âà∞È´òÁ∫ßÁâà!</strong><br><br>ÊÇ®ÂèØ‰ª•‰ΩøÁî®ÊâÄÊúâÂäüËÉΩÊù•ËÆ≠ÁªÉËá™Â∑±ÂÉèÂÜ†ÂÜõ‰∏ÄÊ†∑ÊÄùËÄÉ„ÄÇ<br><br><strong>È´òÁ∫ßÁâàÂäüËÉΩ:</strong><br><ul><li><strong>ÊâÄÊúâÊ£ãÂ±Ä:</strong> ÈÄöËøáÈÄâÊã©Âô®ËÆøÈóÆÊâÄÊúâÊ£ãÂ±Ä„ÄÇ</li><li><strong>ÂéÜÂè≤ ("ÂéÜÂè≤"):</strong> Êü•ÁúãÊÇ®ËøáÂéªÁöÑÊ£ãÂ±Ä„ÄÅÁªüËÆ°Êï∞ÊçÆÂíåËØÑËÆ∫„ÄÇ</li><li><strong>ÈÄöËøá JSON ÂØºÂá∫ËøõË°å AI ÊåáÂØº:</strong> ‰ΩøÁî®ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠ÁöÑ "Â§çÂà∂ (JSON)" ÊåâÈíÆ„ÄÇÂ∞ÜÂ§çÂà∂ÁöÑÊñáÊú¨Á≤òË¥¥Âà∞ÂØπËØùÂºè‰∫∫Â∑•Êô∫ËÉΩ (Â¶Ç ChatGPT, Gemini, Mistral Á≠â) ‰∏≠„ÄÇÂåÖÂê´ÁöÑÊèêÁ§∫Â∞ÜË¶ÅÊ±Ç AI ÂàÜÊûêÊÇ®ÁöÑÊ£ãÂ±Ä (ÈîôËØØ„ÄÅËØÑËÆ∫) Âπ∂‰∏∫ÊÇ®Êèê‰æõ‰∏™ÊÄßÂåñÁöÑÊåáÂØºÂª∫ËÆÆÔºåÁõ¥Êé•‰ΩøÁî®Â∫îÁî®Á®ãÂ∫è‰∏≠ÈÄâÊã©ÁöÑËØ≠Ë®ÄÔºÅ</li><li><strong>ËÆ∞ÂΩï ("ËÆ∞ÂΩï"):</strong> ‰∏∫ÊØè‰∏ÄÊ≠•Ê£ãÊ∑ªÂä†ÊàòÁï•Á¨îËÆ∞„ÄÇ</li><li><strong>ËßÜËßâËæÖÂä©:</strong><ul><li>ÊøÄÊ¥ª/ÂÅúÁî®: ÈïøÊåâ (3Áßí) Âè≥‰∏äËßíÁöÑ <strong>+</strong> ÊåâÈíÆ„ÄÇ</li><li>Èó™ÁÉÅÁöÑÊ©ôËâ≤ÂØπÊâãÊ£ãÁ©¥: ÊÇ®ÈÄâÊã©ÁöÑÊ≠•Êï∞Áõ¥Êé•ÊäìÂ≠ê„ÄÇ</li><li>Â∏¶Ê©ôËâ≤ËæπÊ°ÜÁöÑÂØπÊâãÊ£ãÁ©¥: Êú™Êù•ÂèØËÉΩÊäìÂ≠êÁöÑÂéãÂäõ„ÄÇ</li><li>Â∏¶Ê©ôËâ≤ËôöÁ∫øËæπÊ°ÜÁöÑÊÇ®ÁöÑÊ£ãÁ©¥: ÂØπÊâãÊäìÂ≠êÁöÑÂ®ÅËÉÅ„ÄÇ</li></ul></li><li><strong>Á∫¢ÂçÅÂ≠óÁ∫ø:</strong><ul><li>ÊøÄÊ¥ª/ÂÅúÁî®: ÂçïÂáªÂè≥‰∏äËßíÁöÑ <strong>+</strong> ÊåâÈíÆ„ÄÇ</li><li>Â∏ÆÂä©ÂèØËßÜÂåñÊ£ãÁ©¥ÂØπÈΩê„ÄÇ</li></ul></li></ul><strong>ÂèØÊøÄÊ¥ªÁöÑÁßòÂØÜÊèêÁ§∫:</strong><br><ul><li><strong>Logo x3 ÁÇπÂáª:</strong> ÈáçÁΩÆÂΩìÂâçÊ£ãÂ±Ä„ÄÇ</li><li><strong>ÂΩ©Ê±† x3 ÁÇπÂáª:</strong> ÂàáÊç¢ "‰øùËØÅÊàêÂäü" Ê®°Âºè (ÊâÄÊúâ‰∏ãÊ≥®ÈÉΩËµ¢)„ÄÇ</li><li><strong>"Êàë‰∏ãÊ≥®" ÊñáÊú¨ x3 ÁÇπÂáª:</strong> ÈîÅÂÆö/Ëß£ÈîÅÈÄâÂÆöÁöÑ‰∏ãÊ≥®ÁôæÂàÜÊØî„ÄÇ</li><li><strong>ÂØπÊâã 'a' Ê£ãÁ©¥ (ÈïøÊåâ 2Áßí):</strong> Êí§ÈîÄ‰∏ä‰∏ÄÊ≠•Ê£ã„ÄÇ</li><li><strong>ÂØπÊâã 'f' + 'a' Ê£ãÁ©¥ (ÂêåÊó∂ÈïøÊåâ 3Áßí):</strong> ÊòæÁ§∫ÁßòÂØÜÊèêÁ§∫ÂàóË°®„ÄÇ</li></ul>`,
                 secretMessage: "‰Ω†Â•Ω",
                 secretTipsTitle: "ÁßòÂØÜÊèêÁ§∫ (È´òÁ∫ßÁâà)",
                 secretTips: [ "Logo x3 ÁÇπÂáª: ÈáçÁΩÆÊ£ãÂ±Ä", "ÂΩ©Ê±† x3 ÁÇπÂáª: ‰øùËØÅÊàêÂäü ÂºÄ/ÂÖ≥", "'Êàë‰∏ãÊ≥®' x3 ÁÇπÂáª: ÈîÅÂÆö/Ëß£ÈîÅ ‰∏ãÊ≥® (%)", "ÂØπÊâã 'f' Ê£ãÁ©¥ (ÈïøÊåâ 2Áßí): ‰Ω†Â•Ω", "ÂØπÊâã 'a' Ê£ãÁ©¥ (ÈïøÊåâ 2Áßí): Êí§ÈîÄ‰∏ä‰∏ÄÊ≠•", "ÂØπÊâã 'f' + 'a' Ê£ãÁ©¥ (ÂêåÊó∂ÈïøÊåâ 3Áßí): ÊòæÁ§∫Ê≠§ÂàóË°®" ],
                 commentModalTitle: "Ê∑ªÂä†ËØÑËÆ∫",
                 commentInputPlaceholder: "Âú®Ê≠§Â§ÑËæìÂÖ•ÊÇ®ÁöÑÊàòÁï•Á¨îËÆ∞...",
                 // --- Êñ∞ËØÑËÆ∫ÈÄâÈ°π ---
                 commentOptionNoSeedsBC: "B Âíå C Ê¥û‰∏≠Ê≤°ÊúâÁßçÂ≠ê",
                 commentOptionOffensiveCapture: "ËøõÊîªÔºàÊäìÂ≠êÔºâ > Èò≤ÂÆàÔºàÈÄÉËÑ±Ôºâ",
                 commentOptionBuildKrouOffensive: "ÊûÑÂª∫ËøõÊîªÊÄßÂÖãÈ≤Å (D/E/F) > Èò≤ÂÆàÊÄß",
                 commentOptionBuildKrouDefensive: "ÊûÑÂª∫Èò≤Âæ°ÊÄßÂÖãÈ≤Å (C/D/E) > ËøõÊîªÊÄß",
                 commentOptionBlockCounterKrou: "ÈòªÊ≠¢ÂØπÊâãÁöÑÂèçÂÖãÈ≤Å",
                 commentOptionBuild2Krous: "ÂêåÊó∂ÊûÑÂª∫ 2 ‰∏™ÂÖãÈ≤Å",
                 commentOptionCaptureLimit3: "Â§öÈáçÊäìÂ≠êÈôêÂà∂Âú® 3 ‰∏™Ê¥û",
                 commentOptionCaptureMax5: "ÊúÄÂ§ßÂ§öÈáçÊäìÂ≠êÔºà5 ‰∏™Ê¥ûÔºâ",
                 commentOptionAccelerate: "Âä†Âø´Ê∏∏ÊàèÈÄüÂ∫¶",
                 commentOptionSlowDown: "ÂáèÊÖ¢Ê∏∏ÊàèÈÄüÂ∫¶",
                 commentOptionTechErrorSelect: "ÊäÄÊúØÊÄßÈÄâÊ¥ûÈîôËØØ",
                 // --- ÁªìÊùüÊñ∞ÈÄâÈ°π ---
                 historyTitle: "Ê£ãÂ±ÄÂéÜÂè≤",
                 historyRecordTitle: (name, date) => `Ê£ãÂ±Ä: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `ÊàêÂäüÁéá: ${rate}% | ÊúÄÁªàÂΩ©Ê±†: ${pot}‚Ç¨ | Êó∂Èïø: ${duration}Áßí`,
                 historyCommentsTitle: "Â∑≤ËÆ∞ÂΩïËØÑËÆ∫",
                 historyErrorsTitle: "‰∏ãÊ≥®ÈîôËØØ",
                 historyNoComments: "Ê≠§Ê£ãÂ±ÄÊ≤°ÊúâËÆ∞ÂΩïÁöÑËØÑËÆ∫„ÄÇ",
                 historyNoErrors: "Ê≠§Ê£ãÂ±ÄÊ≤°ÊúâËÆ∞ÂΩïÁöÑ‰∏ãÊ≥®ÈîôËØØ„ÄÇ",
                 historyInProgress: "(ËøõË°å‰∏≠)",
                 historyMoveLabel: "Ê≠•Êï∞",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `‰∏ãÊ≥® <span class="error-detail">${bet}</span> ÂØπÊØî <span class="error-detail">${correct}</span> (ÂΩ©Ê±† ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "È´òÁ∫ßÁâàÂäüËÉΩ",
                 premiumModalText: "Ê≠§ÂäüËÉΩ‰ª•ÂèäÂÖ∂‰ªñÂ•ΩÂ§Ñ‰ªÖÈôêÈ´òÁ∫ß‰ºöÂëò‰ΩøÁî®„ÄÇ",
                 premiumModalBenefitsTitle: "È´òÁ∫ßÁâàÂ•ΩÂ§Ñ:",
                 premiumBenefitLevels: "ËÆøÈóÆÊâÄÊúâËÆ≠ÁªÉÊ£ãÂ±Ä„ÄÇ",
                 premiumBenefitHistory: "‚ÄúÂéÜÂè≤‚ÄùÊåâÈíÆÂèØÊü•ÁúãÂíåÂàÜÊûêÊÇ®ËøáÂéªÁöÑÊ£ãÂ±Ä„ÄÇ",
                 premiumBenefitRecord: "‚ÄúËÆ∞ÂΩï‚ÄùÊåâÈíÆÂèØÊ∑ªÂä†ÊàòÁï•ËØÑËÆ∫„ÄÇ",
                 premiumBenefitAids: "ÊøÄÊ¥ªËßÜËßâËæÖÂä©ÔºàÊäìÂ≠ê/ÂéãÂäõÔºâ„ÄÇ",
                 premiumBenefitCross: "ÊøÄÊ¥ªÁ∫¢Ëâ≤ÂØπÈΩêÂçÅÂ≠óÁ∫ø„ÄÇ",
                 premiumBenefitSecrets: "ËÆøÈóÆÁßòÂØÜÊèêÁ§∫„ÄÇ",
                 premiumModalHowto: "Ë¶ÅËß£ÈîÅÈ´òÁ∫ßÁâàÂπ∂ÊîØÊåÅÊàë‰ª¨ÁöÑÂçè‰ºöÔºåËØ∑Êàê‰∏∫ <strong>Jeux Nomades France</strong> ÁöÑ‰ºöÂëòÔºö",
                 premiumModalActionLink: "Âä†ÂÖ•Âçè‰ºö",
                 gameDropdownFormat: (index, moves) => `Ê£ãÂ±Ä ${index} (${moves} Ê≠•)`,
                 encouragingMessages: [ "Â§™Ê£í‰∫Ü!", "Â•ΩÊ†∑ÁöÑ!", "ÈùûÂ∏∏Âá∫Ëâ≤!", "ÁªßÁª≠Âä™Âäõ!", "‰ª§‰∫∫Âç∞Ë±°Ê∑±Âàª!", "Â§™Á≤æÂΩ©‰∫Ü!", "ÊäÄÊúØÂ®¥ÁÜü!", "Â§™Â•Ω‰∫Ü!", "‰∏çÂèØÊÄùËÆÆ!", "ÁúüÊ£í!", "ÂÆåÁæé!", "ÊÉäËâ≥!", "ÂêéËµ∑‰πãÁßÄ!", "ËΩ∞Âä®!", "ËÉúÂà©!", "Â§ßÂ∏à!", "‰º†Â•á!", "Â§©Êâç!", "ÂÜ†ÂÜõ!", "‰∏çÊúΩ!" ]
             }
        };

        // --- Fonctions Utilitaires ---
        function closeModal(modalId) {
             const modal = document.getElementById(modalId);
             if (modal) modal.style.display = 'none';
        }
        function showPremiumInfoModal() {
             const t = translations[currentLanguage] || translations.en;
             document.getElementById('premium-modal-title').textContent = t.premiumModalTitle;
             document.getElementById('premium-modal-text').textContent = t.premiumModalText;
             document.getElementById('premium-modal-benefits-title').textContent = t.premiumModalBenefitsTitle;
             document.getElementById('premium-benefit-levels').textContent = t.premiumBenefitLevels;
             document.getElementById('premium-benefit-history').textContent = t.premiumBenefitHistory;
             document.getElementById('premium-benefit-record').textContent = t.premiumBenefitRecord;
             document.getElementById('premium-benefit-aids').textContent = t.premiumBenefitAids;
             document.getElementById('premium-benefit-cross').textContent = t.premiumBenefitCross;
             document.getElementById('premium-benefit-secrets').textContent = t.premiumBenefitSecrets;
             document.getElementById('premium-modal-howto').innerHTML = t.premiumModalHowto;
             document.getElementById('premium-modal-action-link').textContent = t.premiumModalActionLink;
             document.getElementById('premium-modal-close').textContent = t.closeButton;
             const modal = document.getElementById('premium-info-modal');
             if (modal) modal.style.display = 'block';
        }
        function toggleCrossVisibility() {
             const t = translations[currentLanguage] || translations.en;
             if (!isPremium) { showPremiumInfoModal(); return; }
             isCrossVisible = !isCrossVisible;
             applyCrossVisibility();
             // showTemporaryMessage(isCrossVisible ? t.crossEnabled : t.crossDisabled); // Optional message
        }
        function applyCrossVisibility() {
            const crossElement = document.getElementById('red-cross');
            if (crossElement) { crossElement.style.display = (isPremium && isCrossVisible) ? 'flex' : 'none'; }
        }
        function toggleAides() {
             const t = translations[currentLanguage] || translations.en;
             if (!isPremium) { showPremiumInfoModal(); return; }
             areAidesEnabled = !areAidesEnabled;
             showTemporaryMessage(areAidesEnabled ? t.aidesEnabled : t.aidesDisabled);
             renderBoard();
        }
        function showTemporaryMessage(message) {
             const resultEl = document.getElementById('result');
             if (resultEl) {
                 const originalText = resultEl.textContent;
                 const originalColor = resultEl.style.color;
                 resultEl.textContent = message;
                 resultEl.style.color = '#17a2b8'; // Info color
                 setTimeout(() => {
                     if (resultEl.textContent === message) {
                         resultEl.textContent = originalText;
                         resultEl.style.color = originalColor;
                     }
                 }, 2000);
             }
        }
        function loadGameRecords() {
            const savedRecords = localStorage.getItem('awaleGameRecords');
            if (savedRecords) {
                try {
                     gameRecords = JSON.parse(savedRecords);
                     if (!Array.isArray(gameRecords)) gameRecords = [];
                } catch (e) { console.error("Error parsing saved records:", e); gameRecords = []; }
            } else { gameRecords = []; }
        }
        function saveGameRecords() {
            try { localStorage.setItem('awaleGameRecords', JSON.stringify(gameRecords)); }
            catch (e) { console.error("Error saving game records:", e); }
        }

        // --- Fonction de Mise √† Jour Langue (Modifi√©e pour les nouvelles checkboxes) ---
        function updateLanguage() {
            currentLanguage = document.getElementById("language-select").value || "fr";
            const t = translations[currentLanguage] || translations.en;
            console.log("Updating language to:", currentLanguage);
            document.documentElement.lang = currentLanguage;
            document.title = t.pageTitle;
            try {
                // Static Labels & Buttons
                document.getElementById("language-label").textContent = t.languageLabel;
                document.getElementById("level-label").textContent = t.levelLabel;
                document.getElementById("title").textContent = t.title;
                document.getElementById("bet-label").textContent = t.betLabel;
                document.getElementById("bet-case-label").textContent = t.betCaseLabel;
                document.getElementById("bet-and-verify-btn").textContent = t.betButton;
                document.getElementById("next-btn").textContent = t.nextButton;
                const recordBtn = document.getElementById('record-btn');
                if (recordBtn) { recordBtn.textContent = t.recordButtonShort; recordBtn.title = t.tooltipRecord; }
                const historyBtn = document.getElementById('history-btn');
                if (historyBtn) { historyBtn.textContent = t.historyButtonShort; historyBtn.title = t.tooltipHistory; }
                document.getElementById("help-btn").title = t.tooltipHelp;
                document.getElementById("theme-toggle").title = t.tooltipTheme;
                document.getElementById("cross-toggle-btn").title = t.tooltipCross;
                const betPotInfoEl = document.getElementById('bet-pot-info');
                if (betPotInfoEl) betPotInfoEl.title = t.tooltipPot;
                const successRateEl = document.getElementById('success-rate');
                if (successRateEl) successRateEl.title = t.tooltipSuccessRate;

                // Modal Content Updates
                // Help Modal
                document.getElementById("help-title").textContent = t.helpTitle;
                const helpTextElement = document.getElementById("help-text");
                if (helpTextElement) {
                    const helpTextContent = isPremium ? (t.helpTextPremium || t.helpTextStandard) : t.helpTextStandard;
                    helpTextElement.innerHTML = helpTextContent;
                }
                 const helpCloseBtn = document.getElementById('help-modal-close');
                 if(helpCloseBtn) helpCloseBtn.textContent = t.closeButton;
                // Secret Tips Modal
                 document.getElementById("secret-tips-title").textContent = t.secretTipsTitle;
                 const tipsList = document.getElementById('secret-tips');
                 if(tipsList) tipsList.innerHTML = (t.secretTips || []).map(tip => `<li>${tip}</li>`).join('');
                 const secretCloseBtn = document.getElementById('secret-modal-close');
                 if(secretCloseBtn) secretCloseBtn.textContent = t.closeButton;
                // History Modal Buttons
                 document.getElementById("history-title").textContent = t.historyTitle;
                 const historyCopyBtn = document.getElementById('history-copy-btn');
                 if(historyCopyBtn) historyCopyBtn.textContent = t.copyButton;
                 const historyResetBtn = document.getElementById('history-reset-btn');
                 if(historyResetBtn) historyResetBtn.textContent = t.resetButton;
                 const historyCloseBtn = document.getElementById('history-close-btn');
                 if(historyCloseBtn) historyCloseBtn.textContent = t.closeButton;

                 // --- MODIFICATION: Comment Modal ---
                 document.getElementById("comment-title").textContent = t.commentModalTitle;
                 const commentInput = document.getElementById("comment-input");
                 if(commentInput) commentInput.placeholder = t.commentInputPlaceholder;
                 const commentSaveBtn = document.getElementById('comment-save-btn');
                 if(commentSaveBtn) commentSaveBtn.textContent = t.saveButton;
                 const commentCancelBtn = document.getElementById('comment-cancel-btn');
                 if(commentCancelBtn) commentCancelBtn.textContent = t.cancelButton;

                 // --- MODIFICATION: Update 11 checkbox labels ---
                 const setCheckboxLabel = (value, translationKey) => {
                     const span = document.querySelector(`input[name="comment-option"][value="${value}"] + .checkbox-label-text`);
                     if (span && t[translationKey]) {
                         span.textContent = t[translationKey];
                     } else if(span) {
                         span.textContent = value; // Fallback if translation key is missing
                     }
                 };
                 setCheckboxLabel("NoSeedsBC", "commentOptionNoSeedsBC");
                 setCheckboxLabel("OffensiveCapture", "commentOptionOffensiveCapture");
                 setCheckboxLabel("BuildKrouOffensive", "commentOptionBuildKrouOffensive");
                 setCheckboxLabel("BuildKrouDefensive", "commentOptionBuildKrouDefensive");
                 setCheckboxLabel("BlockCounterKrou", "commentOptionBlockCounterKrou");
                 setCheckboxLabel("Build2Krous", "commentOptionBuild2Krous");
                 setCheckboxLabel("CaptureLimit3", "commentOptionCaptureLimit3");
                 setCheckboxLabel("CaptureMax5", "commentOptionCaptureMax5");
                 setCheckboxLabel("Accelerate", "commentOptionAccelerate");
                 setCheckboxLabel("SlowDown", "commentOptionSlowDown");
                 setCheckboxLabel("TechErrorSelect", "commentOptionTechErrorSelect");
                 // --- FIN MODIFICATION CHECKBOX LABELS ---

                // Premium Modal (only if open, otherwise use function)
                if (document.getElementById('premium-info-modal').style.display === 'block') {
                    showPremiumInfoModal();
                } else {
                    const premiumCloseBtn = document.getElementById('premium-modal-close');
                    if (premiumCloseBtn) premiumCloseBtn.textContent = t.closeButton;
                }
            } catch (error) { console.error("Error updating static text elements:", error); }

            // Dynamic Content Updates
            populateGameSelect(); // Re-populates game dropdown with translated names
            renderBoard(); // Re-renders board with updated dynamic text

            console.log("Language update finished for:", currentLanguage);
        }

        // --- Fonctions de Configuration Jeu ---
        function populateGameSelect() {
            const select = document.getElementById("level-select");
            if (!select) { console.error("Level select element not found"); return; }
            const t = translations[currentLanguage] || translations.en;
            const currentSelectedIndex = select.value ? parseInt(select.value) : currentGameIndex;

            select.innerHTML = "";
            const maxGamesToShow = isPremium ? games.length : 3;
            const gamesToShowCount = Math.min(maxGamesToShow, games.length);
            const visibleGames = games.slice(0, Math.max(1, gamesToShowCount));

            visibleGames.forEach((game, index) => {
                const option = document.createElement("option");
                option.value = index;
                option.textContent = t.gameDropdownFormat(index + 1, game.length);
                select.appendChild(option);
            });

            if (select.options.length > 0) {
                 const validIndex = Math.min(currentSelectedIndex, select.options.length - 1);
                 const optionExists = Array.from(select.options).some(opt => parseInt(opt.value) === validIndex);
                 select.value = optionExists ? validIndex : 0;
             }
        }
        function changeLevel() {
            const select = document.getElementById("level-select");
            if (!select) return;
            const selectedValue = select.value;
            let potentialNewIndex = parseInt(selectedValue);
            const maxAllowedIndex = isPremium ? games.length - 1 : Math.min(2, games.length - 1);

            if (isNaN(potentialNewIndex) || potentialNewIndex < 0 || potentialNewIndex > maxAllowedIndex) {
                console.warn(`Invalid level selection ${selectedValue}. Max allowed: ${maxAllowedIndex}. Defaulting to 0.`);
                potentialNewIndex = 0;
                select.value = 0;
            }

            if (currentGameIndex !== potentialNewIndex || currentGame.length === 0) {
                currentGameIndex = potentialNewIndex;
                 if (games[currentGameIndex]) {
                     currentGame = games[currentGameIndex].split('');
                     restartGame();
                 } else {
                     console.error("Selected game data unexpectedly not found:", currentGameIndex, "Defaulting to 0.");
                     currentGameIndex = 0;
                     select.value = 0;
                     currentGame = games[0] ? games[0].split('') : [];
                     restartGame();
                 }
            }
        }
        function setDefaultBet() {
            const select = document.getElementById('bet-amount');
            if (select) {
                if (isBetLocked && lockedBetPercentage !== null) {
                    if (Array.from(select.options).some(opt => opt.value === lockedBetPercentage)) {
                        select.value = lockedBetPercentage;
                    } else {
                        console.warn(`Locked bet percentage ${lockedBetPercentage} not found. Unlocking.`);
                        isBetLocked = false;
                        lockedBetPercentage = null;
                        select.value = "75";
                    }
                    select.disabled = isBetLocked;
                } else {
                    isBetLocked = false;
                    lockedBetPercentage = null;
                    select.value = "75";
                    select.disabled = false;
                }
            }
        }

        // --- Fonction de Rendu Plateau ---
        function renderBoard() {
            const t = translations[currentLanguage] || translations.en;
            try {
                const player1Row = document.getElementById('player1-row');
                const player2Row = document.getElementById('player2-row');
                if (!player1Row || !player2Row) { console.error("CRITICAL: #player1-row or #player2-row not found."); document.getElementById('result').textContent = t.errorDisplayMessage; return; }

                player1Row.innerHTML = '';
                player2Row.innerHTML = '';

                 if (!board || typeof board !== 'object' || !Array.isArray(board.player1) || !Array.isArray(board.player2) ||
                     !scores || typeof scores !== 'object' || typeof scores.player1 !== 'number' || typeof scores.player2 !== 'number') {
                     console.error("CRITICAL: Board or scores data is invalid or missing.", board, scores);
                     document.getElementById('result').textContent = t.errorDisplayMessage;
                     return;
                 }

                const betInput = document.getElementById('bet-input');
                const selectedBetCode = betInput ? betInput.value : null;
                const isCurrentlyGameOver = currentMoveIndex + 1 >= currentGame.length;
                isGameOver.confettiShown = isGameOver.confettiShown && isCurrentlyGameOver;
                const nextMoveCode = isCurrentlyGameOver ? null : currentGame[currentMoveIndex + 1];
                const isPlayer1Turn = !isCurrentlyGameOver && /[A-F]/.test(nextMoveCode);

                clearTimeout(animationTimeout);

                // Calculate Visual Aids
                let capturedOpponentHolesIndices = [];
                let pressuredOpponentHolesIndices = [];
                let threatenedPlayer1HolesIndices = [];
                if (isPremium && areAidesEnabled && isPlayer1Turn && board.player1 && board.player2) {
                    if (selectedBetCode) {
                        const selectedIndex = holeMap[selectedBetCode];
                        if (selectedIndex !== undefined && board.player1[selectedIndex] > 0) {
                            const simResultP1 = simulateMove(selectedBetCode, { currentBoard: board, currentScores: scores }); // Pass current state
                            if (simResultP1 && !simResultP1.error && Array.isArray(simResultP1.capturedHoles)) {
                                capturedOpponentHolesIndices = simResultP1.capturedHoles.filter(h => h.player === 2).map(h => h.index);
                                if (capturedOpponentHolesIndices.length === 0) {
                                    // Pass the *result* of the simulation to analyze pressure
                                    pressuredOpponentHolesIndices = analyzeFuturePressure(simResultP1.board, simResultP1.scores);
                                }
                            }
                        }
                    }
                    opponentHoleCodes.forEach((opponentMoveCode) => {
                        const opponentHoleIndex = holeMap[opponentMoveCode];
                        if (opponentHoleIndex !== undefined && board.player2[opponentHoleIndex] > 0) {
                             const simResultP2 = simulateMove(opponentMoveCode, { currentBoard: board, currentScores: scores }); // Pass current state
                             if (simResultP2 && !simResultP2.error && Array.isArray(simResultP2.capturedHoles)) {
                                 const capturedP1Holes = simResultP2.capturedHoles.filter(h => h.player === 1).map(h => h.index);
                                 capturedP1Holes.forEach(threatIndex => {
                                     if (!threatenedPlayer1HolesIndices.includes(threatIndex)) {
                                         threatenedPlayer1HolesIndices.push(threatIndex);
                                     }
                                 });
                             }
                        }
                    });
                }

                 // Update Turn Indicator
                 const turnIndicator = document.getElementById('turn-indicator');
                 if (turnIndicator) {
                     if (isCurrentlyGameOver) {
                         turnIndicator.textContent = "";
                         turnIndicator.className = "";
                     } else {
                         turnIndicator.textContent = isPlayer1Turn ? t.playerTurnIndicator : t.opponentTurnIndicator;
                         turnIndicator.className = isPlayer1Turn ? 'player-turn' : 'opponent-turn';
                     }
                 }

                // Render Player 1 Row
                board.player1.forEach((seeds, index) => {
                    const hole = document.createElement('div');
                    const holeCode = playerHoleCodes[index];
                    hole.className = 'hole player1-hole';
                    hole.textContent = seeds;
                    hole.dataset.code = holeCode;

                    const isClickable = isPlayer1Turn && seeds > 0;
                    if (isClickable) {
                        hole.classList.add('clickable');
                        hole.addEventListener('click', () => { if (betInput) betInput.value = holeCode; renderBoard(); });
                    } else if (isPlayer1Turn && seeds === 0) {
                         hole.classList.add('disabled'); hole.addEventListener('click', () => showTemporaryMessage(t.emptyHoleMessage));
                    } else if (!isPlayer1Turn) {
                        hole.classList.add('disabled'); hole.addEventListener('click', () => showTemporaryMessage(t.opponentTurnMessage));
                    }

                    if (holeCode === selectedBetCode && isPlayer1Turn) hole.classList.add('selected-bet');
                    if (isPremium && areAidesEnabled && isPlayer1Turn && threatenedPlayer1HolesIndices.includes(index)) hole.classList.add('highlight-pressure-enabled');
                    if (holeCode === lastIncorrectGuess) hole.classList.add('highlight-incorrect');
                    if (holeCode === lastCorrectMove) hole.classList.add('highlight-correct');
                    if (highlightStartHole?.player === 1 && highlightStartHole?.index === index) hole.classList.add('highlight-start');
                    if (highlightEndHole?.player === 1 && highlightEndHole?.index === index) hole.classList.add('highlight-end');
                    player1Row.appendChild(hole);
                });

                // Render Player 2 Row
                const reversedPlayer2 = [...board.player2].reverse();
                reversedPlayer2.forEach((seeds, visualIndex) => {
                    const actualIndex = 5 - visualIndex;
                    const holeCode = opponentHoleCodes[actualIndex];
                    const hole = document.createElement('div');
                    hole.className = 'hole player2-hole';
                    hole.textContent = seeds;
                    hole.dataset.index = actualIndex; hole.dataset.code = holeCode;
                    addLongPressListenerForSecrets(hole, actualIndex);
                    if (isPremium && areAidesEnabled && isPlayer1Turn) {
                        if (capturedOpponentHolesIndices.includes(actualIndex)) hole.classList.add('highlight-capture-enabled');
                        else if (pressuredOpponentHolesIndices.includes(actualIndex)) hole.classList.add('highlight-pressure-enabled');
                    }
                    if (highlightStartHole?.player === 2 && highlightStartHole?.index === actualIndex) hole.classList.add('highlight-start');
                    if (highlightEndHole?.player === 2 && highlightEndHole?.index === actualIndex) hole.classList.add('highlight-end');
                    player2Row.appendChild(hole);
                });

                 // Show/hide premium buttons
                 const recordBtn = document.getElementById('record-btn');
                 const historyBtn = document.getElementById('history-btn');
                 if(recordBtn) recordBtn.style.display = isPremium ? 'inline-block' : 'none';
                 if(historyBtn) historyBtn.style.display = isPremium ? 'inline-block' : 'none';

                 // Update Info Displays
                const moveInfoEl = document.getElementById('move-info');
                if (moveInfoEl) moveInfoEl.textContent = t.moveInfo(scores.player1, scores.player2);
                const betPotInfoEl = document.getElementById('bet-pot-info');
                if (betPotInfoEl) betPotInfoEl.innerHTML = t.betPotInfo(pot);
                const successRateEl = document.getElementById('success-rate');
                if (successRateEl) {
                    const rate = totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100);
                    successRateEl.innerHTML = t.successRate(rate);
                }
                const playedMovesEl = document.getElementById('played-moves');
                 if (playedMovesEl) {
                     const movesToShow = Array.isArray(playedMoves) ? playedMoves.slice(-10).join(' ') : '';
                     playedMovesEl.textContent = t.playedMoves(currentMoveIndex + 1, currentGame.length, movesToShow);
                 }

                 // Manage Button Visibility and Game Over State
                const betButton = document.getElementById('bet-and-verify-btn');
                const nextButton = document.getElementById('next-btn');
                const resultEl = document.getElementById('result');

                if (betButton && nextButton && resultEl) {
                    if (isCurrentlyGameOver) {
                        betButton.style.display = 'none'; nextButton.style.display = 'none';
                         if (!resultEl.textContent.includes(t.resultWin) && !resultEl.textContent.includes(t.resultLose) && resultEl.style.color !== 'rgb(23, 162, 184)') {
                                if (resultEl.textContent !== t.resultGameOver) { resultEl.textContent = t.resultGameOver; resultEl.style.color = '#ff0000'; }
                         }
                        if (totalPlayer1Bets > 0 && successfulBets === totalPlayer1Bets && pot > 100 && !isGameOver.confettiShown) {
                             perfectGamesCount++; rainConfetti(); isGameOver.confettiShown = true;
                             const messages = t.encouragingMessages || translations.en.encouragingMessages;
                             const messageIndex = Math.min(perfectGamesCount - 1, messages.length - 1);
                             setTimeout(() => {
                                 const resEl = document.getElementById('result');
                                 if (resEl && resEl.textContent.startsWith(t.resultGameOver)) { resEl.textContent = t.resultGameOver + " " + messages[messageIndex]; resEl.style.color = '#008000'; }
                             }, 2500);
                        }
                         if (currentGameRecord.startTime && !currentGameRecord.endTime) { finalizeGameRecord(); }
                    } else {
                        betButton.style.display = isPlayer1Turn ? 'inline-block' : 'none';
                        nextButton.style.display = isPlayer1Turn ? 'none' : 'inline-block';
                        if (resultEl.textContent === t.resultGameOver) { resultEl.textContent = ""; }
                    }
                }
                if (betInput) { betInput.onchange = () => renderBoard(); }
                applyCrossVisibility();

            } catch (error) {
                 console.error("Error during renderBoard:", error);
                 const t = translations[currentLanguage] || translations.en;
                 const resultEl = document.getElementById('result');
                 if (resultEl) { resultEl.textContent = t.errorDisplayMessage; resultEl.style.color = "red"; }
                 clearTimeout(animationTimeout);
             }
        }

        // --- Fonctions Logiques (Avec simulateMove corrig√©) ---

        // ========================================================================
        // ===      simulateMove (Version CLARIFI√âE: ne modifie PAS l'√©tat global) ===
        // ========================================================================
        function simulateMove(moveCode, options = {}) {
            const { currentBoard = board, currentScores = scores } = options;
            let tempBoard, tempScores;
            const t = translations[currentLanguage] || translations.en;

            try {
                tempBoard = JSON.parse(JSON.stringify(currentBoard));
                tempScores = JSON.parse(JSON.stringify(currentScores));

                 if (!tempBoard?.player1 || !tempBoard?.player2 || !tempScores ||
                     !Array.isArray(tempBoard.player1) || !Array.isArray(tempBoard.player2) ||
                     typeof tempScores.player1 !== 'number' || typeof tempScores.player2 !== 'number') {
                      console.error("Invalid board/scores structure provided to simulateMove", currentBoard, currentScores);
                      const safeBoard = initialBoard(); const safeScores = initialScores();
                      return { board: safeBoard, scores: safeScores, startHole: null, endHole: null, captured: 0, capturedHoles: [], error: true };
                 }

                const isPlayer1 = /[A-F]/.test(moveCode);
                const playerBoard = isPlayer1 ? tempBoard.player1 : tempBoard.player2;
                const holeIndex = holeMap[moveCode];

                if (holeIndex === undefined || holeIndex < 0 || holeIndex > 5 || !playerBoard || playerBoard[holeIndex] === undefined || playerBoard[holeIndex] <= 0) {
                    console.warn(`SimulateMove invalid start: ${moveCode} from hole ${holeIndex} with ${playerBoard ? playerBoard[holeIndex] : 'N/A'} seeds.`);
                    return { board: JSON.parse(JSON.stringify(currentBoard)), scores: JSON.parse(JSON.stringify(currentScores)), startHole: { player: isPlayer1 ? 1 : 2, index: holeIndex }, endHole: { player: isPlayer1 ? 1 : 2, index: holeIndex }, captured: 0, capturedHoles: [], error: true };
                }

                const startHole = { player: isPlayer1 ? 1 : 2, index: holeIndex };
                let seeds = playerBoard[holeIndex];
                playerBoard[holeIndex] = 0;

                let currentPlayer = isPlayer1 ? 1 : 2;
                let currentHole = holeIndex;
                let seedsToDistribute = seeds;
                let lastHole = null;

                 while (seedsToDistribute > 0) {
                    if (currentPlayer === 1) {
                        currentHole++;
                        if (currentHole > 5) { currentPlayer = 2; currentHole = 0; }
                    } else {
                        currentHole++;
                        if (currentHole > 5) { currentPlayer = 1; currentHole = 0; }
                    }
                    const isStartingHole = (isPlayer1 && currentPlayer === 1 && currentHole === holeIndex) || (!isPlayer1 && currentPlayer === 2 && currentHole === holeIndex);
                    if (!(seeds >= 12 && isStartingHole)) {
                        if (currentPlayer === 1) tempBoard.player1[currentHole]++;
                        else tempBoard.player2[currentHole]++;
                        seedsToDistribute--;
                    }
                    if (seedsToDistribute === 0) lastHole = { player: currentPlayer, index: currentHole };
                }
                const endHole = lastHole || startHole;

                let capturedSeedsTotal = 0;
                let capturedHolesPath = [];
                const landedPlayer = lastHole ? lastHole.player : (isPlayer1 ? 1 : 2);
                const landedHoleIndex = lastHole ? lastHole.index : holeIndex;

                 if (lastHole && ((isPlayer1 && landedPlayer === 2) || (!isPlayer1 && landedPlayer === 1)))
                {
                    let newBoardForCheck = JSON.parse(JSON.stringify(tempBoard));
                    let tempCapturedInLoop = 0;
                    let currentCapturePathDetails = [];

                    if (isPlayer1 && landedPlayer === 2) {
                        let capturePos = landedHoleIndex;
                        while (capturePos >= 0 && (tempBoard.player2[capturePos] === 2 || tempBoard.player2[capturePos] === 3)) {
                            const seedsInHole = tempBoard.player2[capturePos];
                            tempCapturedInLoop += seedsInHole;
                            currentCapturePathDetails.push({ index: capturePos, player: 2, value: seedsInHole });
                            newBoardForCheck.player2[capturePos] = 0;
                            capturePos--;
                        }
                        if (tempCapturedInLoop > 0 && !newBoardForCheck.player2.every(s => s === 0)) {
                             capturedSeedsTotal = tempCapturedInLoop;
                             capturedHolesPath = currentCapturePathDetails;
                             capturedHolesPath.forEach(holeInfo => { tempBoard.player2[holeInfo.index] = 0; });
                             tempScores.player1 += capturedSeedsTotal;
                        }
                    } else if (!isPlayer1 && landedPlayer === 1) {
                         let capturePos = landedHoleIndex;
                         while (capturePos >= 0 && (tempBoard.player1[capturePos] === 2 || tempBoard.player1[capturePos] === 3)) {
                             const seedsInHole = tempBoard.player1[capturePos];
                             tempCapturedInLoop += seedsInHole;
                             currentCapturePathDetails.push({ index: capturePos, player: 1, value: seedsInHole });
                             newBoardForCheck.player1[capturePos] = 0;
                             capturePos--;
                        }
                        if (tempCapturedInLoop > 0 && !newBoardForCheck.player1.every(s => s === 0)) {
                            capturedSeedsTotal = tempCapturedInLoop;
                            capturedHolesPath = currentCapturePathDetails;
                            capturedHolesPath.forEach(holeInfo => { tempBoard.player1[holeInfo.index] = 0; });
                            tempScores.player2 += capturedSeedsTotal;
                        }
                    }
                }

                return {
                    board: tempBoard, scores: tempScores, startHole: startHole,
                    endHole: endHole, captured: capturedSeedsTotal, capturedHoles: capturedHolesPath, error: false
                };

            } catch (error) {
                console.error("Error during simulateMove:", error, moveCode, currentBoard);
                showTemporaryMessage(t.internalErrorMessage);
                const safeBoard = initialBoard();
                const safeScores = initialScores();
                 return { board: safeBoard, scores: safeScores, startHole: null, endHole: null, captured: 0, capturedHoles: [], error: true };
            }
        }
        // ========================================================================
        // ===                 FIN de simulateMove CLARIFI√âE                    ===
        // ========================================================================


        function analyzeFuturePressure(simulatedBoard, simulatedScores) {
             const pressurePoints = [];
             const opponentPlayer = 2;
             if (!simulatedBoard?.player2) return [];
             const vulnerableHolesIndices = simulatedBoard.player2.reduce((acc, seeds, index) => {
                 if (seeds === 1 || seeds === 2) acc.push(index);
                 return acc;
             }, []);
             if (vulnerableHolesIndices.length === 0) return [];
             if (!simulatedBoard?.player1) return [];
             for (let playerHoleIndex = 0; playerHoleIndex < playerHoleCodes.length; playerHoleIndex++) {
                 const playerSeeds = simulatedBoard.player1[playerHoleIndex];
                 if (playerSeeds > 0) {
                     const potentialNextMoveCode = playerHoleCodes[playerHoleIndex];
                     // Pass the simulated state for the next potential move check
                     const nextSimResult = simulateMove(potentialNextMoveCode, {
                         currentBoard: simulatedBoard,
                         currentScores: simulatedScores
                     });
                     if (nextSimResult && !nextSimResult.error && Array.isArray(nextSimResult.capturedHoles)) {
                         const capturedByThisNextMove = nextSimResult.capturedHoles
                             .filter(h => h.player === opponentPlayer)
                             .map(h => h.index);
                         vulnerableHolesIndices.forEach(vulnIndex => {
                             if (capturedByThisNextMove.includes(vulnIndex) && !pressurePoints.includes(vulnIndex)) {
                                 pressurePoints.push(vulnIndex);
                             }
                         });
                     }
                 }
                 if (pressurePoints.length === vulnerableHolesIndices.length) break;
             }
             return pressurePoints;
        }

        // --- betAndVerify (Utilise simulateMove corrig√©) ---
        function betAndVerify() {
             const t = translations[currentLanguage] || translations.en;
             const betInput = document.getElementById('bet-input');
             if (!betInput) return;
             currentBet = betInput.value;
             const betSelect = document.getElementById('bet-amount');
             if (!betSelect) return;
             let betPercentage = parseInt(betSelect.value);

             if (isNaN(betPercentage) || betPercentage <= 0 || betPercentage > 100) { showTemporaryMessage(t.resultInvalidBet + " (%)"); return; }
             if (isNaN(pot)) pot = 100;
             betAmount = Math.max(0, Math.floor(pot * (betPercentage / 100)));
             if ((betAmount <= 0 && pot > 0) || betAmount > pot) { showTemporaryMessage(t.resultInvalidBet + " (Amount/Funds)"); return; }
             if (currentMoveIndex + 1 >= currentGame.length) { showTemporaryMessage(t.resultGameOver); return; }
             const nextMove = currentGame[currentMoveIndex + 1];
             const isPlayer1Next = /[A-F]/.test(nextMove);
             if (!isPlayer1Next) { showTemporaryMessage(t.notYourTurnMessage); return; }
             const currentBetIndex = holeMap[currentBet];
             if (currentBetIndex === undefined || !board?.player1 || board.player1[currentBetIndex] === undefined || board.player1[currentBetIndex] <= 0) { showTemporaryMessage(t.invalidHoleMessage); return; }

             document.getElementById('result').textContent = "";
             lastIncorrectGuess = null;
             lastCorrectMove = null;

             currentMoveIndex++;
             totalPlayer1Bets++;
             if (!Array.isArray(playedMoves)) playedMoves = [];
             playedMoves.push(nextMove);
             if (totalPlayer1Bets === 1 && currentMoveIndex === 0) { startNewGameRecord(); }

             if (!Array.isArray(moveHistory)) moveHistory = [];
             moveHistory.push({
                 board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: nextMove
             });

             // Simulate, passing current state explicitly
             const moveResult = simulateMove(nextMove, { currentBoard: board, currentScores: scores });

              // Check for simulation error
              if (!moveResult || moveResult.error) {
                  console.error("Simulation failed for the correct move:", nextMove);
                  moveHistory.pop();
                  currentMoveIndex--;
                  totalPlayer1Bets--;
                  if (playedMoves.length > 0) playedMoves.pop();
                  showTemporaryMessage(t.internalErrorMessage);
                  renderBoard(); // Render the state BEFORE the failed simulation
                  return;
              }

              // Update GLOBAL state only if simulation succeeded
              board = moveResult.board;
              scores = moveResult.scores;

             triggerAnimation(moveResult.startHole, moveResult.endHole);

             const resultEl = document.getElementById('result');
             if (isSuccessGuaranteed || currentBet === nextMove) {
                 pot = Math.round(pot + betAmount);
                 successfulBets++;
                 if (resultEl) { resultEl.textContent = t.resultWin; resultEl.style.color = '#008000'; }
             } else {
                 pot = Math.max(0, Math.round(pot - betAmount));
                 if (resultEl) { resultEl.textContent = `${t.resultLose} (${nextMove})`; resultEl.style.color = '#ff0000'; }
                 lastIncorrectGuess = currentBet;
                 lastCorrectMove = nextMove;
                 const errorData = {
                      moveIndex: currentMoveIndex, bet: currentBet, correctMove: nextMove,
                      potChange: -betAmount, betAmount: betAmount, timestamp: Date.now()
                 };
                 if (!Array.isArray(errorLog)) errorLog = [];
                 errorLog.push(errorData);
                 if (currentGameRecord && Array.isArray(currentGameRecord.errors)) {
                     currentGameRecord.errors.push(errorData);
                 }
             }
             setDefaultBet();
             renderBoard(); // Render the NEW global state
        }

        // --- moveNext (Utilise simulateMove corrig√©) ---
        function moveNext() {
             const t = translations[currentLanguage] || translations.en;
             if (currentMoveIndex + 1 >= currentGame.length) { showTemporaryMessage(t.resultGameOver); return; }
             const nextMove = currentGame[currentMoveIndex + 1];
             const isPlayer1Next = /[A-F]/.test(nextMove);
             if (isPlayer1Next) { showTemporaryMessage(t.playerTurnIndicator); return; }

             document.getElementById('result').textContent = "";
             lastIncorrectGuess = null;
             lastCorrectMove = null;

             currentMoveIndex++;
             if (!Array.isArray(playedMoves)) playedMoves = [];
             playedMoves.push(nextMove);
             if (currentMoveIndex === 0 && totalPlayer1Bets === 0) { startNewGameRecord(); }

              if (!Array.isArray(moveHistory)) moveHistory = [];
             moveHistory.push({
                 board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: nextMove
             });

              // Simulate, passing current state explicitly
              const moveResult = simulateMove(nextMove, { currentBoard: board, currentScores: scores });

             // Check for simulation error
             if (!moveResult || moveResult.error) {
                  console.error("Simulation failed for opponent move:", nextMove);
                  moveHistory.pop();
                  currentMoveIndex--;
                   if (playedMoves.length > 0) playedMoves.pop();
                  showTemporaryMessage(t.internalErrorMessage);
                  renderBoard(); // Render the state BEFORE the failed simulation
                  return;
             }

               // Update GLOBAL state only if simulation succeeded
               board = moveResult.board;
               scores = moveResult.scores;

             triggerAnimation(moveResult.startHole, moveResult.endHole);
             setDefaultBet();
             renderBoard(); // Render the NEW global state
        }

        // --- triggerAnimation ---
        function triggerAnimation(startHole, endHole) {
             clearTimeout(animationTimeout);
             highlightStartHole = startHole;
             highlightEndHole = endHole;
             renderBoard(); // Render immediately with highlights
             animationTimeout = setTimeout(() => {
                 highlightStartHole = null;
                 highlightEndHole = null;
                 renderBoard(); // Render again without highlights
             }, 800);
        }

        // --- Fonctions Historique, Commentaires, Enregistrements (Modifi√©e saveComment) ---
        function startNewGameRecord() {
            if (currentGameRecord.startTime && !currentGameRecord.endTime) { finalizeGameRecord(); }
            gameStartTime = Date.now();
            const t = translations[currentLanguage] || translations.en;
            currentGameRecord = {
                gameId: `game-${currentGameIndex + 1}-${gameStartTime}`,
                gameName: t.gameDropdownFormat(currentGameIndex + 1, currentGame.length),
                totalMoves: currentGame.length, startTime: gameStartTime, endTime: null,
                duration: 0, successRate: 0, finalPot: pot, comments: [], errors: []
            };
            errorLog = [];
            console.log("Started new game record:", currentGameRecord.gameId);
        }
        function finalizeGameRecord() {
            if (!currentGameRecord || !currentGameRecord.startTime || currentGameRecord.endTime) { return; }
            console.log("Finalizing game record:", currentGameRecord.gameId);
            currentGameRecord.endTime = Date.now();
            currentGameRecord.duration = Math.round((currentGameRecord.endTime - currentGameRecord.startTime) / 1000);
            currentGameRecord.successRate = totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100);
            currentGameRecord.finalPot = pot;
            currentGameRecord.errors = [...errorLog];

            const existingIndex = gameRecords.findIndex(r => r.gameId === currentGameRecord.gameId);
            if (existingIndex > -1) { gameRecords[existingIndex] = { ...currentGameRecord }; console.log("Updated existing game record:", currentGameRecord.gameId); }
            else { gameRecords.push({ ...currentGameRecord }); console.log("Added new game record:", currentGameRecord.gameId); }
            saveGameRecords();
            currentGameRecord = {}; gameStartTime = null; errorLog = [];
        }
        function restartGame() {
            finalizeGameRecord();
            board = initialBoard(); scores = initialScores(); currentMoveIndex = -1;
            moveHistory = [{ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: null }];
            currentBet = null; playedMoves = []; pot = 100; successfulBets = 0; totalPlayer1Bets = 0;
            errorLog = []; gameStartTime = null; currentGameRecord = {};
            lastIncorrectGuess = null; lastCorrectMove = null; highlightStartHole = null; highlightEndHole = null;
            clearTimeout(animationTimeout); isGameOver.confettiShown = false;
            const resultEl = document.getElementById('result'); if (resultEl) resultEl.textContent = "";
            const secretMsgEl = document.getElementById('secret-message'); if (secretMsgEl) secretMsgEl.textContent = "";
            setDefaultBet();
             if (games[currentGameIndex]) { currentGame = games[currentGameIndex].split(''); }
             else {
                 console.error(`Game index ${currentGameIndex} invalid after restart. Defaulting to 0.`);
                 currentGameIndex = 0; currentGame = games[0] ? games[0].split('') : [];
                 const levelSelect = document.getElementById('level-select'); if(levelSelect) levelSelect.value = 0;
             }
            renderBoard();
        }
        function openCommentModal() {
            if (!isPremium) { showPremiumInfoModal(); return; }
            const modal = document.getElementById('comment-modal'); if (modal) modal.style.display = 'block';
            const commentInput = document.getElementById('comment-input'); if (commentInput) commentInput.value = '';
            document.querySelectorAll('input[name="comment-option"]').forEach(checkbox => checkbox.checked = false);
        }

        // --- MODIFICATION: saveComment to use new options ---
        function saveComment() {
             if (!currentGameRecord || !currentGameRecord.startTime) {
                 console.warn("Cannot save comment: No active game record.");
                 closeModal('comment-modal');
                 return;
             }
             const t = translations[currentLanguage] || translations.en;
             const commentInput = document.getElementById('comment-input');
             const checkboxes = document.querySelectorAll('input[name="comment-option"]:checked');
             let commentText = commentInput ? commentInput.value.trim() : '';

             // Map checkbox values to their corresponding translation keys
             const valueToTranslationKeyMap = {
                 "NoSeedsBC": "commentOptionNoSeedsBC",
                 "OffensiveCapture": "commentOptionOffensiveCapture",
                 "BuildKrouOffensive": "commentOptionBuildKrouOffensive",
                 "BuildKrouDefensive": "commentOptionBuildKrouDefensive",
                 "BlockCounterKrou": "commentOptionBlockCounterKrou",
                 "Build2Krous": "commentOptionBuild2Krous",
                 "CaptureLimit3": "commentOptionCaptureLimit3",
                 "CaptureMax5": "commentOptionCaptureMax5",
                 "Accelerate": "commentOptionAccelerate",
                 "SlowDown": "commentOptionSlowDown",
                 "TechErrorSelect": "commentOptionTechErrorSelect"
             };

             const checkedOptions = Array.from(checkboxes).map(checkbox => {
                 const translationKey = valueToTranslationKeyMap[checkbox.value];
                 // Return the translated text if found, otherwise fallback to the value
                 return t[translationKey] || checkbox.value;
             });

             if (commentText || checkedOptions.length > 0) {
                 const moveIndexForLabel = currentMoveIndex >= 0 ? currentMoveIndex + 1 : 0;
                 const moveLabel = moveIndexForLabel > 0 ? `${moveIndexForLabel}/${currentGame.length}` : "Start";
                 const moveCodePlayed = currentMoveIndex >= 0 ? currentGame[currentMoveIndex] : null;
                 const fullComment = {
                     move: moveLabel,
                     moveCode: moveCodePlayed,
                     timestamp: Date.now(),
                     text: commentText,
                     options: checkedOptions
                 };

                 if (!Array.isArray(currentGameRecord.comments)) {
                     currentGameRecord.comments = [];
                 }
                 currentGameRecord.comments.push(fullComment);
                 console.log("Comment saved:", fullComment);
             }
             closeModal('comment-modal');
        }
        // --- FIN MODIFICATION saveComment ---

        function openHistoryModal() {
             if (!isPremium) { showPremiumInfoModal(); return; }
             const t = translations[currentLanguage] || translations.en;
             const historyContent = document.getElementById('history-content');
             const historyModal = document.getElementById('history-modal');
             if (!historyContent || !historyModal) { console.error("History modal elements not found"); return;}
             historyContent.innerHTML = '';
             const tempRecords = [...gameRecords];
             if (currentGameRecord && currentGameRecord.startTime && !currentGameRecord.endTime) {
                 const currentSnapshot = { ...currentGameRecord, endTime: Date.now(), duration: Math.round((Date.now() - currentGameRecord.startTime) / 1000), finalPot: pot, successRate: totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100), errors: [...errorLog], comments: [...(currentGameRecord.comments || [])], isInProgress: true };
                 tempRecords.push(currentSnapshot);
             }
             tempRecords.sort((a, b) => (b.startTime || 0) - (a.startTime || 0));
             if (tempRecords.length === 0) { historyContent.textContent = t.noHistory; }
             else {
                 tempRecords.forEach(record => {
                      if (!record || !record.startTime) return;
                     const entryDetails = document.createElement('details'); entryDetails.className = 'history-entry';
                     const entrySummary = document.createElement('summary'); entrySummary.className = 'history-summary';
                     const gameDate = new Date(record.startTime).toLocaleString(currentLanguage, { dateStyle: 'short', timeStyle: 'short' });
                     const titleText = t.historyRecordTitle(record.gameName || `Game ID ${record.gameId}`, gameDate);
                     const statsText = t.historyStats(record.successRate ?? 0, record.finalPot ?? 0, record.duration ?? 0);
                     const inProgressText = record.isInProgress ? ` <em style="color: #007bff;font-size:0.9em;">${t.historyInProgress}</em>` : '';
                     entrySummary.innerHTML = `<span style="flex-grow: 1;">${titleText} <span style="font-weight:normal; font-size:0.9em;">(${statsText})</span></span>${inProgressText}`;
                     entryDetails.appendChild(entrySummary);
                     const detailsDiv = document.createElement('div'); detailsDiv.className = 'history-details';
                     const commentsTitle = document.createElement('h4'); commentsTitle.textContent = t.historyCommentsTitle; detailsDiv.appendChild(commentsTitle);
                     if (record.comments && record.comments.length > 0) {
                         record.comments.forEach(comment => {
                             const commentP = document.createElement('p'); commentP.className = 'comment-entry';
                             const commentDate = new Date(comment.timestamp).toLocaleTimeString(currentLanguage, { timeStyle: 'short' });
                             let optionsText = comment.options && comment.options.length > 0 ? ` [${comment.options.join(', ')}]` : '';
                             const moveLabel = t.historyMoveLabel;
                             commentP.innerHTML = `<strong>${moveLabel} ${comment.move || '?'} (${comment.moveCode || 'N/A'}):</strong> ${comment.text || ''}<span class="comment-options">${optionsText}</span> <small>(${commentDate})</small>`;
                             detailsDiv.appendChild(commentP);
                         });
                     } else { const noCommentP = document.createElement('p'); noCommentP.textContent = t.historyNoComments; noCommentP.style.fontStyle = 'italic'; detailsDiv.appendChild(noCommentP); }
                     const errorsTitle = document.createElement('h4'); errorsTitle.textContent = t.historyErrorsTitle; errorsTitle.style.marginTop = '15px'; detailsDiv.appendChild(errorsTitle);
                     if (record.errors && record.errors.length > 0) {
                         record.errors.forEach(error => {
                             const errorP = document.createElement('p'); errorP.className = 'error-entry';
                             const errorDate = new Date(error.timestamp).toLocaleTimeString(currentLanguage, { timeStyle: 'short' });
                              const moveLabel = t.historyMoveLabel;
                              const errorMoveNumber = (typeof error.moveIndex === 'number' && error.moveIndex >= 0) ? error.moveIndex + 1 : '?';
                              errorP.innerHTML = `<strong>${moveLabel} ${errorMoveNumber}:</strong> ${t.historyBetErrorLabel(error.bet, error.correctMove, error.potChange, errorDate)}`;
                             detailsDiv.appendChild(errorP);
                         });
                     } else { const noErrorP = document.createElement('p'); noErrorP.textContent = t.historyNoErrors; noErrorP.style.fontStyle = 'italic'; detailsDiv.appendChild(noErrorP); }
                     entryDetails.appendChild(detailsDiv);
                     historyContent.appendChild(entryDetails);
                 });
             }
             historyModal.style.display = 'block';
        }
        function copyHistoryContent() {
             const t = translations[currentLanguage] || translations.en;
             try {
                 const dynamicPromptMap = {
                     fr: `Vous √™tes un expert Awal√© et coach strat√©gique sp√©cialis√© dans l'analyse des parties de champions. Voici l'historique des parties jou√©es par un utilisateur essayant de deviner le coup du champion. Analysez ses performances, ses erreurs courantes (le tableau 'errors' montre son pari incorrect par rapport au coup correct), ses points forts et ses commentaires. Fournissez des commentaires constructifs et des conseils de coaching pour l'aider √† am√©liorer sa capacit√© √† penser comme le champion.\nIMPORTANT : Veuillez formuler votre r√©ponse exclusivement dans la langue suivante : Fran√ßais.`,
                     en: `You are an Awale expert and strategic coach specialized in analyzing champion games. Here is the history of games played by a user trying to guess the champion's move. Analyze their performance, common mistakes (the 'errors' array shows their incorrect bet vs the correct move), strengths, and comments. Provide constructive feedback and coaching tips to help them improve their ability to think like the champion.\nIMPORTANT: Please formulate your response exclusively in the following language: English.`,
                     es: `Eres un experto en Awal√© y entrenador estrat√©gico especializado en analizar partidas de campeones. Aqu√≠ tienes el historial de partidas jugadas por un usuario que intenta adivinar la jugada del campe√≥n. Analiza su rendimiento, errores comunes (la matriz 'errors' muestra su apuesta incorrecta frente a la jugada correcta), puntos fuertes y comentarios. Proporciona comentarios constructivos y consejos de coaching para ayudarle a mejorar su capacidad de pensar como el campe√≥n.\nIMPORTANTE: Por favor, formula tu respuesta exclusivamente en el siguiente idioma: Espa√±ol.`,
                     ru: `–í—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –ê–≤–∞–ª–µ –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–π —Ç—Ä–µ–Ω–µ—Ä, —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—â–∏–π—Å—è –Ω–∞ –∞–Ω–∞–ª–∏–∑–µ –∏–≥—Ä —á–µ–º–ø–∏–æ–Ω–æ–≤. –í–æ—Ç –∏—Å—Ç–æ—Ä–∏—è –∏–≥—Ä, —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –ø—ã—Ç–∞—é—â–∏–º—Å—è —É–≥–∞–¥–∞—Ç—å —Ö–æ–¥ —á–µ–º–ø–∏–æ–Ω–∞. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏ (–º–∞—Å—Å–∏–≤ 'errors' –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –µ–≥–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç–∞–≤–∫—É –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ö–æ–¥–æ–º), —Å–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏. –ü—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–∏–≤–Ω—É—é –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å –∏ —Ç—Ä–µ–Ω–µ—Ä—Å–∫–∏–µ —Å–æ–≤–µ—Ç—ã, —á—Ç–æ–±—ã –ø–æ–º–æ—á—å –µ–º—É —É–ª—É—á—à–∏—Ç—å —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –¥—É–º–∞—Ç—å –∫–∞–∫ —á–µ–º–ø–∏–æ–Ω.\n–í–ê–ñ–ù–û: –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ —Å–≤–æ–π –æ—Ç–≤–µ—Ç –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–º —è–∑—ã–∫–µ: –†—É—Å—Å–∫–∏–π.`,
                     zh: `ÊÇ®ÊòØ‰∏Ä‰Ωç Awale ‰∏ìÂÆ∂ÂíåÊàòÁï•ÊïôÁªÉÔºå‰∏ìÈó®ÂàÜÊûêÂÜ†ÂÜõÊ£ãÂ±Ä„ÄÇËøôÊòØ‰∏Ä‰ΩçËØïÂõæÁåúÊµãÂÜ†ÂÜõËµ∞Ê≥ïÁöÑÁî®Êà∑ÁöÑ‰∏ãÊ£ãÂéÜÂè≤ËÆ∞ÂΩï„ÄÇËØ∑ÂàÜÊûê‰ªñ‰ª¨ÁöÑË°®Áé∞„ÄÅÂ∏∏ËßÅÈîôËØØÔºà'errors' Êï∞ÁªÑÊòæÁ§∫‰∫Ü‰ªñ‰ª¨ÈîôËØØÁöÑ‰∏ãÊ≥®‰∏éÊ≠£Á°ÆËµ∞Ê≥ïÔºâ„ÄÅ‰ºòÁÇπÂíåËØÑËÆ∫„ÄÇÊèê‰æõÂª∫ËÆæÊÄßÁöÑÂèçÈ¶àÂíåÊåáÂØºÊäÄÂ∑ßÔºåÂ∏ÆÂä©‰ªñ‰ª¨ÊèêÈ´òÂÉèÂÜ†ÂÜõ‰∏ÄÊ†∑ÊÄùËÄÉÁöÑËÉΩÂäõ„ÄÇ\nÈáçË¶ÅÊèêÁ§∫ÔºöËØ∑‰ªÖ‰ΩøÁî®‰ª•‰∏ãËØ≠Ë®ÄÂà∂ÂÆöÊÇ®ÁöÑÂõûÂ§çÔºö‰∏≠Êñá„ÄÇ`
                 };
                 const dynamicPrompt = dynamicPromptMap[currentLanguage] || dynamicPromptMap.en;
                 const dataToCopy = { prompt: dynamicPrompt, language_preference: currentLanguage, games: [...gameRecords] };
                 const historyJson = JSON.stringify(dataToCopy, null, 2);
                 navigator.clipboard.writeText(historyJson).then(() => { alert(t.copySuccess); }).catch(err => { console.error('Clipboard write error:', err); alert(t.copyError); });
             } catch (e) { console.error("Error preparing history for copying:", e); alert(t.copyPrepareError); }
        }
        function resetHistory() {
             const t = translations[currentLanguage] || translations.en;
             if (confirm(t.confirmResetHistory)) {
                 gameRecords = []; localStorage.removeItem('awaleGameRecords');
                 const historyContent = document.getElementById('history-content'); if (historyContent) historyContent.textContent = t.noHistory;
                 closeModal('history-modal'); alert(t.historyResetSuccess);
             }
        }
        function rainConfetti() {
            const container = document.body;
            for (let i = 0; i < 150; i++) {
                 let c=document.createElement('div'); c.className='confetti';
                 const s=Math.random()*8+4; c.style.width=s+'px'; c.style.height=s+'px';
                 c.style.left=Math.random()*100+'vw'; c.style.top='-10px';
                 c.style.backgroundColor=`hsl(${Math.random()*360},100%,70%)`;
                 c.style.animationDuration=(Math.random()*3+2)+'s';
                 c.style.animationDelay=Math.random()*1+'s';
                 c.style.transform=`rotate(${Math.random()*360}deg)`;
                 container.appendChild(c);
                 c.addEventListener('animationend',()=>{if(c.parentNode)c.parentNode.removeChild(c);});
            }
        }

        // --- Fonctions Secrets et Listeners ---
        function addTripleClickListener(element, callback) {
             let c = 0, l = 0;
             element?.addEventListener('click', (e) => {
                 const t = Date.now(); if (t - l < 500) c++; else c = 1; l = t;
                 if (c === 3) { callback(element); c = 0; }
             });
         }
        function handleTripleClick(element) {
            const t = translations[currentLanguage] || translations.en;
            if (!element) return;
            if (element.classList.contains('logo')) { restartGame(); showTemporaryMessage(t.resetMessage); }
            else if (element.id === 'bet-pot-info') { isSuccessGuaranteed = !isSuccessGuaranteed; showTemporaryMessage(isSuccessGuaranteed ? t.successOnMessage : t.successOffMessage); }
            else if (element.id === 'bet-label') {
                 const select = document.getElementById('bet-amount');
                 if(select){
                     isBetLocked = !isBetLocked;
                     if (isBetLocked) { lockedBetPercentage = select.value; showTemporaryMessage(t.betLockedMessage(lockedBetPercentage)); select.disabled = true; }
                     else { lockedBetPercentage = null; showTemporaryMessage(t.betUnlockedMessage); select.disabled = false; select.value = "75"; }
                 }
             }
         }
        function addLongPressListener(element, duration, callback) {
             let p = null;
             const s = (e) => { if (e.button === 2) return; clearTimeout(p); p = setTimeout(() => { if(callback) callback(); p = null; }, duration); };
             const c = () => { clearTimeout(p); p = null; };
             const o = { passive: true };
             element?.addEventListener('touchstart', s, o); element?.addEventListener('touchend', c);
             element?.addEventListener('touchcancel', c); element?.addEventListener('mousedown', s);
             element?.addEventListener('mouseup', c); element?.addEventListener('mouseleave', c);
         }
        function activatePremium() {
             if (!isPremium) {
                 isPremium = true; localStorage.setItem('isPremiumVersion', 'true');
                 const t = translations[currentLanguage] || translations.en;
                 showTemporaryMessage(t.premiumUnlockedMessage); updateLanguage();
             }
         }
        function handleLongPressSecret(index) {
            const t = translations[currentLanguage] || translations.en;
            const secretMsgEl = document.getElementById('secret-message');
            if (index === 5) { if(secretMsgEl) secretMsgEl.textContent = t.secretMessage; }
            else if (index === 0) {
                 if (!isPremium) { showPremiumInfoModal(); return; }
                 if (currentMoveIndex >= 0 && moveHistory.length > 1) {
                      const moveBeingUndone = playedMoves.length > 0 ? playedMoves[playedMoves.length - 1] : null;
                      const wasPlayerBet = moveBeingUndone ? /[A-F]/.test(moveBeingUndone) : false;
                      moveHistory.pop(); const previousState = moveHistory[moveHistory.length - 1];
                      board = JSON.parse(JSON.stringify(previousState.board)); scores = JSON.parse(JSON.stringify(previousState.scores));
                      currentMoveIndex--; if (playedMoves.length > 0) playedMoves.pop();
                      if (wasPlayerBet) {
                          totalPlayer1Bets = Math.max(0, totalPlayer1Bets - 1);
                          const errorIndex = errorLog.findIndex(err => err.moveIndex === currentMoveIndex + 1);
                          if (errorIndex === -1) { successfulBets = Math.max(0, successfulBets - 1); console.warn("Pot reversal on successful undo might be inaccurate."); }
                          else {
                             const undoneError = errorLog[errorIndex];
                             if (undoneError && typeof undoneError.betAmount === 'number') { pot = Math.round(pot + undoneError.betAmount); }
                             else { console.warn("Could not find bet amount to restore pot on error undo."); }
                             errorLog.splice(errorIndex, 1);
                          }
                      }
                      lastIncorrectGuess = null; lastCorrectMove = null;
                      showTemporaryMessage(t.backMessage); renderBoard();
                 }
             }
         }
        function addLongPressListenerForSecrets(element, index) {
             if (index === 5 || index === 0) { addLongPressListener(element, 2000, () => handleLongPressSecret(index)); }
         }
        function showSecretTips() {
            if (!isPremium) { showPremiumInfoModal(); return; }
            const t = translations[currentLanguage] || translations.en;
            const secretModal = document.getElementById('secret-modal');
            const tipsTitle = document.getElementById('secret-tips-title');
            const tipsList = document.getElementById('secret-tips');
            const closeBtn = document.getElementById('secret-modal-close');
            if(secretModal && tipsTitle && tipsList && closeBtn) {
                tipsTitle.textContent = t.secretTipsTitle;
                tipsList.innerHTML = (t.secretTips || []).map(tip => `<li>${tip}</li>`).join('');
                closeBtn.textContent = t.closeButton;
                secretModal.style.display = 'block';
            }
        }
        function setupCombinedSecretListener() {
             const boardElement = document.getElementById('board'); if (!boardElement) return;
             let fPressed = false; let aPressed = false; let pressTimer = null; let targetF = null; let targetA = null;
             const clearTimer = () => { if (pressTimer) clearTimeout(pressTimer); pressTimer = null; };
             const handlePress = (event, isStartingPress) => {
                 if (!isPremium) return;
                 const holeElement = event.target.closest('.hole.player2-hole'); if (!holeElement) return;
                 const holeCode = holeElement.dataset.code;
                 if (holeCode === 'f') { fPressed = isStartingPress; targetF = isStartingPress ? holeElement : null; }
                 else if (holeCode === 'a') { aPressed = isStartingPress; targetA = isStartingPress ? holeElement : null; }
                 else { return; }
                 if (fPressed && aPressed) { clearTimer(); pressTimer = setTimeout(() => { if(fPressed && aPressed) showSecretTips(); }, 3000); }
                 else { clearTimer(); }
             };
             boardElement.addEventListener('touchstart', (e) => handlePress(e, true), {passive: true});
             boardElement.addEventListener('touchend', (e) => handlePress(e, false));
             boardElement.addEventListener('touchcancel', (e) => handlePress(e, false));
             boardElement.addEventListener('mousedown', (e) => {if(e.button!==2) handlePress(e, true);});
             boardElement.addEventListener('mouseup', (e) => {if(e.button!==2) handlePress(e, false);});
             boardElement.addEventListener('mouseleave', (e) => {
                 if (e.target === targetF) handlePress(e, false);
                 if (e.target === targetA) handlePress(e, false);
             }, true);
        }

        // --- Initialisation du Jeu ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing Application...");
            isPremium = localStorage.getItem('isPremiumVersion') === 'true';
            console.log("Premium Status:", isPremium);

            // Setup UI Listeners
            document.getElementById('theme-toggle')?.addEventListener('click', () => { document.body.classList.toggle('dark-mode'); renderBoard(); });
            document.getElementById('help-btn')?.addEventListener('click', () => {
                 const t = translations[currentLanguage] || translations.en;
                 const helpTextElement = document.getElementById("help-text");
                 if (helpTextElement) {
                     const content = isPremium ? (t.helpTextPremium || t.helpTextStandard) : t.helpTextStandard;
                     helpTextElement.innerHTML = content;
                 }
                 const modal = document.getElementById('help-modal');
                 if(modal) modal.style.display = 'block';
            });
             addLongPressListener(document.getElementById('title'), 10000, activatePremium);
            const crossBtn = document.getElementById('cross-toggle-btn');
            if (crossBtn) {
                crossBtn.addEventListener('click', toggleCrossVisibility);
                addLongPressListener(crossBtn, 3000, toggleAides);
            }
             document.querySelectorAll('.logo, #bet-pot-info, #bet-label').forEach(element => {
                if(element) addTripleClickListener(element, handleTripleClick);
            });
            setupCombinedSecretListener();
            const langSelect = document.getElementById("language-select");
            if(langSelect) langSelect.addEventListener('change', updateLanguage);
            const levelSelect = document.getElementById("level-select");
            if(levelSelect) levelSelect.addEventListener('change', changeLevel);

            // Load saved data & Initialize state
            loadGameRecords();
            board = initialBoard(); scores = initialScores(); currentGameIndex = 0;
            currentGame = games[currentGameIndex] ? games[currentGameIndex].split('') : [];
            moveHistory = [{ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: null }];
            console.log("Initial board state set.");

            // Set initial language and render everything
            currentLanguage = langSelect ? (langSelect.value || "fr") : "fr";
            updateLanguage(); // This populates dropdowns, sets initial text, and renders board

            console.log("Initialization complete. Current Language:", currentLanguage);
        });
    </script>
</body>
</html>
