<!DOCTYPE html>
<!-- lang attribute will be set dynamically by JS -->
<html lang="fr">
<head>
	<link rel="manifest" href="/manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be set dynamically by JS -->
    <title>Dans la Tête d'un Champion</title>
    <style>
        /* Styles CSS (Identiques au nouveau code fourni précédemment) */
        html, body { height: 100%; margin: 0; padding: 0; box-sizing: border-box; }
        body { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; min-height: 100vh; padding: 10px 0; transition: background-color 0.3s, color 0.3s; font-family: sans-serif; overflow-x: hidden; }
        *, *:before, *:after { box-sizing: inherit; }
        .dark-mode { background-color: #333; color: #fff; }
        .dark-mode .hole { color: #fff; }
        .dark-mode #bet-pot-info, .dark-mode #success-rate { background-color: #555; border-color: #777; color: #fff; }
        .dark-mode #title, .dark-mode #move-info, .dark-mode #played-moves, .dark-mode #result, .dark-mode #turn-indicator { color: #fff; }
        .dark-mode #help-modal, .dark-mode #secret-modal, .dark-mode #comment-modal, .dark-mode #history-modal, .dark-mode #premium-info-modal { background: #444; color: #fff; }
        .dark-mode .history-entry summary { background-color: #555; }
        .dark-mode .history-entry { border-color: #777; }
        .dark-mode .hole.player1-hole { background-color: #a0522d; color: white; }
        .dark-mode .hole.player2-hole { background-color: #5c4033; color: white; }
        .dark-mode .selected-bet { animation: blink-dark 0.6s infinite; }
        .dark-mode #turn-indicator.player-turn { color: #90ee90; background-color: #385038; }
        .dark-mode #turn-indicator.opponent-turn { color: #ffa0a0; background-color: #5a3030; }
        .dark-mode .comment-entry::before, .dark-mode .error-entry::before { color: #bbb; }
        .dark-mode .comment-options { color: #ddd; }
        .dark-mode .error-detail { color: #ff6b6b;}
        .dark-mode #theme-toggle { background: url('https://img.icons8.com/ios-filled/24/ffffff/light-off.png') no-repeat center; background-size: 60%; }
        .dark-mode .highlight-capture-enabled { animation: blink-orange-dark 0.6s infinite; }
        .dark-mode .highlight-pressure-enabled { border: 3px dashed #ff8c00 !important; box-shadow: 0 0 8px #ff8c00; }
        .dark-mode #cross-toggle-btn { background: #555; border-color: #777; color: #ff6b6b; }
        .dark-mode .highlight-start { background-color: rgba(0, 200, 255, 0.5) !important; }
        #game-area { width: 90vw; max-width: 700px; padding: 1vh 5px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; gap: 1vh; margin-top: 10px; }
        #title { color: #333; text-align: center; font-size: clamp(1.4em, 5vw, 1.8em); margin: 0 0 0.5vh 0; user-select: none; cursor: help; }
        #turn-indicator { font-weight: bold; margin-bottom: 8px; text-align: center; padding: 5px; border-radius: 4px; min-height: 1.2em; width: 90%; max-width: 300px; }
        #turn-indicator.player-turn { color: #006400; background-color: #e8f5e9; }
        #turn-indicator.opponent-turn { color: #b71c1c; background-color: #ffebee; }
        .button-yellow, .button-next, .button-small, .button-save, .button-copy, .button-reset, .button-close { padding: 10px 18px; font-size: clamp(0.9em, 2.5vw, 1em); border-radius: 5px; cursor: pointer; transition: transform 0.2s, background-color 0.2s; border: none; font-weight: bold; margin: 5px 4px; white-space: nowrap; }
        .button-yellow:active, .button-next:active { transform: scale(0.95); }
        .button-yellow { background-color: #ffc107; color: #000; border: 2px solid #e0a800; }
        .button-yellow:hover { background-color: #e0a800; }
        .button-next { background-color: #28a745; color: white; border: 2px solid #218838; }
        .button-next:hover { background-color: #218838; }
        .button-small { background-color: #17a2b8; color: white; border: 2px solid #138496; padding: 8px 12px; font-size: clamp(0.8em, 2.2vw, 0.9em); }
        .button-small:hover { background-color: #138496; }
        .button-small.history { background-color: #6f42c1; border: 2px solid #5a32a3; }
        .button-small.history:hover { background-color: #5a32a3; }
        .button-save { background-color: #28a745; color: white; border: 2px solid #218838; }
        .button-save:hover { background-color: #218838; }
        .button-copy { background-color: #007bff; color: white; border: 2px solid #0056b3; }
        .button-copy:hover { background-color: #0056b3; }
        .button-reset { background-color: #dc3545; color: white; border: 2px solid #c82333; }
        .button-reset:hover { background-color: #c82333; }
        .button-close { background-color: #6c757d; color: white; border: 2px solid #5a6268; }
        .button-close:hover { background-color: #5a6268; }
        .logo-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin: 1vh auto; flex-direction: column; }
        .logo-row { display: flex; align-items: center; gap: clamp(10px, 3vw, 20px); }
        .logo { width: clamp(100px, 25vw, 150px); height: auto; }
        #theme-toggle, #help-btn { width: clamp(30px, 8vw, 40px); height: clamp(30px, 8vw, 40px); border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; background-color: #eee; }
        #theme-toggle { background: url('https://img.icons8.com/ios-filled/24/000000/light-on.png') no-repeat center; background-size: 60%;}
        #help-btn { background-color: #007bff; color: white; font-size: clamp(1em, 4vw, 1.4em); font-weight: bold; }
        #cross-toggle-btn { color: red; font-weight: bold; font-size: clamp(1.8em, 7vw, 2.4em); line-height: 1; padding: 0 5px 4px 5px; background: #eee; border: 1px solid #ccc; border-radius: 50%; width: clamp(30px, 8vw, 40px); height: clamp(30px, 8vw, 40px); cursor: pointer; display: flex; align-items: center; justify-content: center; user-select: none; }
        .selector-container { display: flex; justify-content: center; gap: clamp(10px, 4vw, 25px); margin: 1.5vh 0; flex-wrap: wrap; }
        .selector-container > div { display: flex; align-items: center; gap: 5px;}
        .selector-container label, .selector-container select { font-size: clamp(0.85em, 2.8vw, 1em); }
        #board { position: relative; width: 100%; display: flex; flex-direction: column; align-items: center; margin: 1vh 0; padding: 5px 0; box-sizing: border-box; border: 1px solid #eee; background-color: #f9f9f9; border-radius: 8px; }
        .dark-mode #board { border: 1px solid #555; background-color: #404040; }
        .board-row { display: flex; justify-content: center; width: 100%; padding: 0 5px; box-sizing: border-box; }
        .board-label { flex: 0 0 auto; width: 13vw; max-width: 70px; height: auto; margin: 0.5vw; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: clamp(0.8em, 3vw, 1.3em); text-align: center; color: #666; user-select: none; }
        .dark-mode .board-label { color: #ccc; }
        .hole { flex: 0 0 auto; width: 13vw; height: 13vw; max-width: 70px; max-height: 70px; color: black; display: flex; align-items: center; justify-content: center; border-radius: 50%; margin: 0.5vw; font-weight: bold; font-size: clamp(1em, 4vw, 1.8em); transition: background-color 0.3s, box-shadow 0.3s, border 0.2s, color 0.3s; box-sizing: border-box; border: 2px solid transparent; position: relative; overflow: hidden; cursor: default; user-select: none; }
        .hole.player1-hole { background-color: #d2b48c; color: #333; }
        .hole.player2-hole { background-color: #8b4513; color: white; }
        .hole.player1-hole.clickable { cursor: pointer; }
        .hole.disabled { cursor: not-allowed !important; opacity: 0.7; }
        .highlight-incorrect { border: 3px solid red !important; box-shadow: 0 0 10px red; }
        .highlight-correct { border: 3px solid limegreen !important; box-shadow: 0 0 10px limegreen; }
        .highlight-start { background-color: rgba(0, 200, 255, 0.7) !important; }
        .highlight-end { background-color: rgba(210, 180, 222, 0.7) !important; }
        .selected-bet { animation: blink 0.6s infinite; }
        @keyframes blink { 0%, 100% { background-color: #4682b4; border-color: #1e90ff; box-shadow: 0 0 8px #1e90ff; } 50% { background-color: #add8e6; border-color: #4682b4; box-shadow: 0 0 12px #4682b4; } }
        @keyframes blink-dark { 0%, 100% { background-color: #1e90ff; border-color: #4682b4; box-shadow: 0 0 8px #4682b4; } 50% { background-color: #4682b4; border-color: #1e90ff; box-shadow: 0 0 12px #1e90ff;} }
        .highlight-capture-enabled { animation: blink-orange 0.6s infinite; }
        @keyframes blink-orange { 0%, 100% { background-color: #ffcc80; border: 2px solid orange; box-shadow: 0 0 6px orange; } 50% { background-color: #ffa726; border: 2px solid darkorange; box-shadow: 0 0 10px darkorange; } }
        @keyframes blink-orange-dark { 0%, 100% { background-color: #e69500; border: 2px solid #ff8c00; box-shadow: 0 0 6px #ff8c00; } 50% { background-color: #ffae42; border: 2px solid #ffa500; box-shadow: 0 0 10px #ffa500; } }
        .highlight-pressure-enabled { border: 3px dashed orange !important; box-shadow: 0 0 8px orange; }
        .dark-mode .highlight-pressure-enabled { border: 3px dashed #ff8c00 !important; box-shadow: 0 0 8px #ff8c00; }
        #red-cross { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; justify-content: center; align-items: center; overflow: hidden; }
        .cross-line { position: absolute; background-color: transparent; opacity: 0.7; }
        .cross-line.horizontal { width: 96%; height: 2px; top: 50%; left: 2%; transform: translateY(-50%); border-top: 2px dashed red; }
        .cross-line.vertical { width: 2px; height: 90%; left: 50%; top: 5%; transform: translateX(-50%); border-left: 2px dashed red; }
        #move-info { text-align: center; margin-bottom: 5px; font-size: clamp(0.9em, 3vw, 1.1em);}
        .pot-container { display: flex; align-items: center; justify-content: center; gap: clamp(8px, 3vw, 15px); margin: 1vh 0; }
        #bet-pot-info, #success-rate { background-color: #fff3cd; border: 1px solid #e0a800; padding: 6px 12px; border-radius: 5px; display: inline-block; text-align: center; font-size: clamp(0.85em, 2.8vw, 1em);}
        #played-moves { text-align: center; margin-top: 5px; font-size: clamp(0.8em, 2.5vw, 0.9em); color: #555; width: 90%; word-wrap: break-word;}
        .dark-mode #played-moves { color: #ccc; }
        #result { text-align: center; font-weight: bold; min-height: 1.2em; margin: 8px 0; font-size: clamp(0.95em, 3.2vw, 1.1em); }
        .betting-area { margin-top: 1.5vh; display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        .bet-selection { display: flex; align-items: center; justify-content: center; gap: 5px; flex-wrap: wrap; margin-bottom: 10px; }
        .bet-selection label, .bet-selection select, .bet-selection span { font-size: clamp(0.9em, 2.8vw, 1em); }
        .bet-buttons { display: flex; justify-content: center; align-items: center; gap: clamp(5px, 2vw, 10px); flex-wrap: wrap; }
        #help-modal, #secret-modal, #comment-modal, #history-modal, #premium-info-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1000; max-width: 90%; width: 500px; max-height: 85vh; overflow-y: auto; }
        #help-modal button, #secret-modal button, #comment-modal button, #history-modal button:not(.history-buttons button), #premium-info-modal button { margin-top: 15px; }
        #comment-modal { height: auto; min-height: 380px; }
        .comment-section { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        #comment-input { width: calc(100% - 10px); height: 100px; resize: vertical; padding: 5px; margin-bottom: 5px; border: 1px solid #ccc;}
        .checkbox-section { margin-top: 5px; }
        .checkbox-section label { display: flex; align-items: center; margin-bottom: 6px; cursor: pointer;}
        .checkbox-section input[type="checkbox"] { margin-right: 8px;}
        #history-content { margin-bottom: 10px; font-family: monospace; }
        .history-buttons { display: flex; justify-content: space-between; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .history-entry { border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; background-color: #f9f9f9; }
        .history-entry summary { padding: 10px; font-weight: bold; cursor: pointer; background-color: #eee; border-radius: 5px 5px 0 0; outline: none; display: flex; justify-content: space-between; align-items: center;}
        .history-entry summary::before { content: '▶ '; display: inline-block; margin-right: 5px; transition: transform 0.2s; order: -1;}
        .history-entry summary::-webkit-details-marker { display: none; }
        .history-entry[open] summary::before { transform: rotate(90deg); }
        .history-details { padding: 10px; border-top: 1px solid #ddd; }
        .history-details h4 { margin-top: 0; margin-bottom: 5px; font-size: 1em; }
        .comment-entry, .error-entry { margin-bottom: 8px; padding-left: 15px; position: relative; font-size: 0.9em; line-height: 1.4; word-break: break-word; }
        .comment-entry::before, .error-entry::before { content: '•'; position: absolute; left: 0; color: #555; }
        .comment-options { font-style: italic; color: #333; margin-left: 5px; }
        .error-detail { color: #c00; font-weight: bold;}
        .confetti { position: fixed; width: 8px; height: 8px; pointer-events: none; animation: fall 3s ease-out forwards; border-radius: 50%; transform: rotate(0deg); z-index: 9999; }
        @keyframes fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        #premium-info-modal ul { list-style: disc; margin-left: 25px; margin-top: 10px;}
        #premium-info-modal li { margin-bottom: 8px; }
        #help-modal ul { list-style: disc; margin-left: 25px; margin-top: 10px;}
        #help-modal li { margin-bottom: 8px; }

        @media (max-width: 480px) { body { padding: 5px 0; } #game-area { width: 95vw; gap: 0.8vh;} .logo-row { gap: 10px; } .button-yellow, .button-next, .button-small { padding: 8px 10px; font-size: 0.9em; margin: 3px; } .bet-buttons { gap: 5px; } .history-buttons { justify-content: center; } .pot-container { gap: 8px; } #bet-pot-info, #success-rate { padding: 5px 8px; } #help-modal, #secret-modal, #comment-modal, #history-modal, #premium-info-modal { width: 95%; max-height: 80vh; } .hole, .board-label { width: 14vw; max-width: 60px; height: 14vw; max-height: 60px; margin: 0.4vw; font-size: clamp(0.9em, 3.5vw, 1.6em); } }
    </style>
</head>
<body>
    <!-- Structure HTML (Identique) -->
     <div class="logo-container">
        <div id="secret-message"></div>
        <div class="logo-row">
            <img src="logo.jpg" alt="Logo" class="logo" onerror="this.style.display='none'">
            <button id="theme-toggle"></button>
            <button id="help-btn">i</button>
            <button id="cross-toggle-btn">+</button>
        </div>
    </div>
    <div class="selector-container">
        <div>
            <label for="language-select" id="language-label"></label>
            <select id="language-select" onchange="updateLanguage()">
                <option value="fr">Français</option>
                <option value="en">English</option>
                <option value="es">Español</option>
                <option value="ru">Русский</option>
                <option value="zh">中文</option>
            </select>
        </div>
        <div>
            <label for="level-select" id="level-label"></label>
            <select id="level-select" onchange="changeLevel()"></select>
        </div>
    </div>
    <div id="game-area">
        <h1 id="title"></h1>
        <div id="turn-indicator"></div>
        <div id="board">
            <div class="board-row"> <div class="board-label">f</div><div class="board-label">e</div><div class="board-label">d</div><div class="board-label">c</div><div class="board-label">b</div><div class="board-label">a</div> </div>
            <div id="player2-row" class="board-row"></div>
            <div id="player1-row" class="board-row"></div>
            <div class="board-row"> <div class="board-label">A</div><div class="board-label">B</div><div class="board-label">C</div><div class="board-label">D</div><div class="board-label">E</div><div class="board-label">F</div> </div>
            <div id="red-cross"> <div class="cross-line horizontal"></div> <div class="cross-line vertical"></div> </div>
        </div>
        <div id="move-info"></div>
        <div class="pot-container">
            <div id="bet-pot-info"></div>
            <div id="success-rate"></div>
        </div>
        <div id="played-moves"></div>
        <div id="result"></div>
        <div class="betting-area">
            <div class="bet-selection">
                <label id="bet-label" for="bet-amount"></label>
                <select id="bet-amount">
                    <option value="25">25 %</option>
                    <option value="50">50 %</option>
                    <option value="75">75 %</option>
                    <option value="100">100 %</option>
                </select>
                <span>€</span>
                <label id="bet-case-label" for="bet-input"></label>
                <select id="bet-input">
                    <option value="A">A</option><option value="B">B</option><option value="C">C</option>
                    <option value="D">D</option><option value="E">E</option><option value="F">F</option>
                </select>
            </div>
            <div class="bet-buttons">
                <button id="bet-and-verify-btn" class="button-yellow" onclick="betAndVerify()"></button>
                <button id="next-btn" class="button-next" onclick="moveNext()"></button>
                <button id="record-btn" class="button-small" onclick="openCommentModal()" style="display: none;"></button>
                <button id="history-btn" class="button-small history" onclick="openHistoryModal()" style="display: none;"></button>
            </div>
        </div>
    </div>

    <!-- Modals (structure identique) -->
     <div id="help-modal">
        <h2 id="help-title"></h2>
        <div id="help-text"></div>
        <button onclick="closeModal('help-modal')" class="button-close" id="help-modal-close"></button>
    </div>
    <div id="secret-modal">
        <h2 id="secret-tips-title"></h2>
        <ul id="secret-tips"></ul>
        <button onclick="closeModal('secret-modal')" class="button-close" id="secret-modal-close"></button>
    </div>
    <div id="comment-modal">
        <h3 id="comment-title"></h3>
        <div class="comment-section">
            <textarea id="comment-input" placeholder=""></textarea>
             <div class="checkbox-section">
                <label><input type="checkbox" name="comment-option" value="GoodMove"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="BadMove"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="Risky"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="Safe"> <span class="checkbox-label-text"></span></label>
            </div>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="button-save" onclick="saveComment()" id="comment-save-btn"></button>
            <button class="button-close" onclick="closeModal('comment-modal')" id="comment-cancel-btn"></button>
        </div>
    </div>
    <div id="history-modal">
        <h3 id="history-title"></h3>
        <div id="history-content"></div>
        <div class="history-buttons">
            <button class="button-copy" onclick="copyHistoryContent()" id="history-copy-btn"></button>
            <button class="button-reset" onclick="resetHistory()" id="history-reset-btn"></button>
            <button class="button-close" onclick="closeModal('history-modal')" id="history-close-btn"></button>
        </div>
    </div>
    <div id="premium-info-modal">
        <h2 id="premium-modal-title"></h2>
        <p id="premium-modal-text"></p>
        <p><strong id="premium-modal-benefits-title"></strong></p>
        <ul>
            <li id="premium-benefit-levels"></li>
            <li id="premium-benefit-history"></li>
            <li id="premium-benefit-record"></li>
            <li id="premium-benefit-aids"></li>
            <li id="premium-benefit-cross"></li>
            <li id="premium-benefit-secrets"></li>
        </ul>
        <p id="premium-modal-howto"></p>
        <p style="text-align: center; margin-top:15px;">
            <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer" class="button-yellow" style="text-decoration: none;" id="premium-modal-action-link"></a>
        </p>
        <button onclick="closeModal('premium-info-modal')" class="button-close" id="premium-modal-close"></button>
    </div>

    <script>
        // !!! ATTENTION !!!
        // Ce code utilise une version MODIFIÉE de simulateMove
        // qui réintègre l'ANCIENNE logique anti-famine pour tests.
        // Cette logique peut différer des règles standard ou avoir des effets de bord.
        // !!! --------- !!!

        // --- Variables Globales (Identiques) ---
        let isPremium = false;
        let areAidesEnabled = false;
        let isCrossVisible = false;
        const initialBoard = () => ({ player1: [4, 4, 4, 4, 4, 4], player2: [4, 4, 4, 4, 4, 4] });
        const initialScores = () => ({ player1: 0, player2: 0 });
        let board = {};
        let scores = {};
        const games = [ "FfCdAbBaDbCdDcBdAaBbDcCdDeEeDdCfEeFdBeFaD", "FfBaCfAbAfBdCfBcAfCeBfDfCeBdCeEfDbEcAdCaEbF", "FfBaCaAaCfBbAcCaBbCcAfAdAfCaBeDfEeBfAaEbCaEbF", "FfCcBbAaFaDaAcBdDbCfDaCdBcDbCcAeFdBeCfFaCbDaFbE", "FfBdBfDdAbAdDaBdDbAfAeAbDaBbDcEeDdBfAeCfEaDbEcBdF", "FfCcBbAcBbFaCfCeCcBbDfAcDdCfEfBeAfDbEcCdEeAaDbEcBdCeDfEaAbF", "FfBcEeBcDcCcEbAeDbCcBaEfDeEdEcDbCaEdDcEbFfEdFfAaBbCeAcCdDeBf", "FfCcBbAfFdAaEaFaCaEbBeEcCdAfEeCbDdAfAeAfEaCbBbEaDcAdCbEcDdEeAfFfCdBeAfDaE", "FfBaCbBdFbDbFdCfCcFdDfFaCdDcBdDbEfFbAaEdFaCaDfFaAcAeEaAdDbEeCdEfCcEeFbAcDfAeAfEdBcDaCbF", "FfCbDeDcCbAfAeFfAcDbEfFeCcDaAcEdCcEdDaEbBdDbCcAdBeBcEcDfDdCeAcDdBbEbFfEeBfCaFaAeCbBcCdEeAfD", "FfCbDbFbBeAfCcAaDaCeDbBdBcDaEeDfEaCaBbAcCdBeEfDaAbBcEdCeDfEaFfEeDdCcBeDdCeDfFaEaBbCcDdAeBfEaF", "FfCaFdBcFdDaFaBdAfFeFfDcCdDeBbBaDcAfAdAeCbAfDcAdBeCfFbAcDdEeBfFbDaCcDdEeAaFaBbDcEdCeDfFaBbCcAdBeCf", "FfBaCbBeDbCfCeDaBcCfDeEfAcDaBeEfCdAaEcDbAfAeAdBcCeEdDeFfEaDbCdBeAcCdBeCfFbEaDcBeAdCaFaEeBbDcCdDeEaF", "FfBcFbBdAeBbCcAdDbCeDdCeDaFaBaEeBfFbEdBfFeDfEbFaAfAaCeAfEbDcEeFaDbCeEdCcDfDeCdDeEfFaBaDbCcAdBeDfFaEaAbBcCdDeEaFfAaBbCcDdEeFf" ];
        let currentGame = [];
        let currentMoveIndex = -1;
        let moveHistory = [];
        let currentBet = null;
        let playedMoves = [];
        let betAmount = 0;
        let pot = 100;
        let currentLanguage = "fr";
        let successfulBets = 0;
        let totalPlayer1Bets = 0;
        let isBetLocked = false;
        let lockedBetPercentage = null;
        let isSuccessGuaranteed = false;
        let perfectGamesCount = 0;
        let currentGameIndex = 0;
        let gameStartTime = null;
        let errorLog = [];
        let lastIncorrectGuess = null;
        let lastCorrectMove = null;
        let highlightStartHole = null;
        let highlightEndHole = null;
        let animationTimeout = null;
        let gameRecords = [];
        let currentGameRecord = {};
        const holeMap = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5 };
        const opponentHoleCodes = ['a', 'b', 'c', 'd', 'e', 'f'];
        const playerHoleCodes = ['A', 'B', 'C', 'D', 'E', 'F'];
        let isGameOver = { confettiShown: false };


        // --- Objet Translations (Identique) ---
        const translations = {
             fr: {
                 pageTitle: "Dans la Tête d'un Champion",
                 languageLabel: "Langue :",
                 levelLabel: "Partie :",
                 title: "Dans la Tête d'un Champion !",
                 moveInfo: (p1, p2) => `Joueur 😊 ↓: ${p1} | Joueur 😔 ↑: ${p2}`,
                 betPotInfo: (pot) => `Cagnotte:<BR>${pot} €`,
                 successRate: (rate) => `Réussite:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | Derniers jeux: ${moves}`,
                 betLabel: "Je mise",
                 betCaseLabel: "sur",
                 betButton: "Je parie !",
                 nextButton: "Suivant",
                 recordButtonShort: "Enr",
                 historyButtonShort: "Histo",
                 closeButton: "Fermer",
                 saveButton: "Sauver",
                 cancelButton: "Annuler",
                 copyButton: "Copier (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Votre argent virtuel actuel",
                 tooltipSuccessRate: "Pourcentage de paris corrects sur cette partie",
                 tooltipRecord: "Enregistrer un commentaire pour ce coup (Premium)",
                 tooltipHistory: "Voir l'historique des parties jouées (Premium)",
                 tooltipHelp: "Afficher l'aide / Règles",
                 tooltipTheme: "Mode Sombre/Clair",
                 tooltipCross: "Options Premium (Croix / Aides)",
                 resultInvalidBet: "Mise invalide !",
                 resultWin: "Gagné !",
                 resultLose: "Perdu !",
                 resultGameOver: "Partie terminée !",
                 resetMessage: "Jeu réinitialisé !",
                 premiumUnlockedMessage: "Version Premium activée ! Fonctionnalités débloquées.",
                 successOnMessage: "Succès garanti ACTIVÉ",
                 successOffMessage: "Succès garanti DÉSACTIVÉ",
                 betLockedMessage: (pct) => `Mise verrouillée (${pct}%)`,
                 betUnlockedMessage: "Mise déverrouillée",
                 backMessage: "Retour arrière effectué",
                 opponentTurnMessage: "Clic Suivant (tour adverse)",
                 playerTurnIndicator: "À vous : Sélectionnez & misez !",
                 opponentTurnIndicator: "Tour adverse (Clic Suivant)",
                 emptyHoleMessage: "Case vide !",
                 notYourTurnMessage: "Pas votre tour ! Cliquez sur 'Suivant'.",
                 invalidHoleMessage: "Case invalide ou vide !",
                 internalErrorMessage: "Erreur interne de simulation.",
                 aidesEnabled: "Aides visuelles activées",
                 aidesDisabled: "Aides visuelles désactivées",
                 crossEnabled: "Croix rouge activée",
                 crossDisabled: "Croix rouge désactivée",
                 errorDisplayMessage: "Erreur d'affichage. Rechargez.",
                 confirmResetHistory: "Voulez-vous vraiment réinitialiser tout l'historique ? Cette action est irréversible.",
                 historyResetSuccess: "Historique réinitialisé !",
                 copySuccess: "Contenu de l'historique copié !",
                 copyError: "Erreur lors de la copie.",
                 copyPrepareError: "Erreur lors de la préparation de la copie.",
                 noHistory: "Aucun historique de partie enregistré.",
                 helpTitle: "Aide & Objectif",
                 helpTextStandard: `<strong>Bienvenue dans l'entraînement cérébral Awalé !</strong><br><br>Votre objectif est de <strong>penser comme un champion</strong> en devinant le coup qu'il a joué dans une partie réelle à chaque fois que c'est votre tour (Joueur 😊 ↓).<br><br><strong>Comment jouer :</strong><br>1. Choisissez une langue et l'une des 3 premières parties disponibles.<br>2. Quand c'est votre tour (😊 ↓), observez le plateau.<br>3. Cliquez sur une de vos cases (A-F) contenant des graines pour la sélectionner.<br>4. Choisissez le pourcentage de votre cagnotte virtuelle à miser sur ce choix.<br>5. Cliquez sur 'Je parie !'. Si votre choix est correct, vous gagnez votre mise. Sinon, vous la perdez.<br>6. Quand c'est le tour de l'adversaire (😔 ↑), cliquez sur 'Suivant'.<br><br><strong>Passez à la Version Premium !</strong><br>Pour une expérience complète et soutenir notre association, adhérez à <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. La version Premium débloque les fonctionnalités suivantes :<ul><li>L'accès à <strong>toutes les parties</strong> d'entraînement.</li><li>Les boutons <strong>"Histo"</strong> (historique) et <strong>"Enr"</strong> (prise de notes).</li><li>L'activation des <strong>aides visuelles</strong> (indications de capture/pression).</li><li>L'activation de la <strong>croix rouge</strong> d'alignement.</li><li>L'accès aux <strong>astuces secrètes</strong>.</li></ul>`,
                 helpTextPremium: `<strong>Bienvenue dans la version Premium !</strong><br><br>Vous avez accès à toutes les fonctionnalités pour vous entraîner à penser comme un champion.<br><br><strong>Fonctionnalités Premium :</strong><br><ul><li><strong>Toutes les Parties :</strong> Accédez à l'ensemble des parties via le sélecteur.</li><li><strong>Historique ("Histo") :</strong> Consultez vos parties précédentes, statistiques et commentaires.</li><li>
                     <strong>Coaching par IA via Export JSON :</strong> Utilisez le bouton "Copier (JSON)" dans l'historique. Collez le texte copié dans une Intelligence Artificielle conversationnelle (comme ChatGPT, Gemini, Mistral, etc.). Le prompt inclus demandera à l'IA d'analyser vos parties (erreurs, commentaires) et de vous donner des conseils de coaching personnalisés, directement dans la langue sélectionnée dans l'application !
                 </li><li><strong>Enregistrement ("Enr") :</strong> Ajoutez des notes stratégiques à chaque coup joué.</li><li><strong>Aides Visuelles :</strong><ul><li>Activation/Désactivation : Appui long (3s) sur le bouton <strong>+</strong> en haut à droite.</li><li>Case adverse orange clignotante : Votre coup sélectionné capture directement.</li><li>Case adverse avec bordure orange : Pression pour capture future possible.</li><li>Votre case avec bordure orange pointillée : Menace de capture par l'adversaire.</li></ul></li><li><strong>Croix Rouge :</strong><ul><li>Activation/Désactivation : Clic simple sur le bouton <strong>+</strong> en haut à droite.</li><li>Aide à visualiser les alignements de cases.</li></ul></li></ul><strong>Astuces Secrètes Activables :</strong><br><ul><li><strong>Logo x3 clics :</strong> Réinitialise la partie en cours.</li><li><strong>Cagnotte x3 clics :</strong> Active/Désactive le mode "Succès Garanti" (tous les paris réussissent).</li><li><strong>Texte "Je mise" x3 clics :</strong> Verrouille/Déverrouille le pourcentage de mise sélectionné.</li><li><strong>Case 'a' adverse (appui 2s) :</strong> Annule le dernier coup joué (retour arrière).</li><li><strong>Cases 'f' + 'a' adverses (appui 3s simultané) :</strong> Affiche la liste des astuces secrètes.</li></ul>`,
                 secretMessage: "Bonjour Eric",
                 secretTipsTitle: "Astuces Secrètes (Premium)",
                 secretTips: [ "Logo x3 clics : Reset partie", "Cagnotte x3 clics : Succès garanti ON/OFF", "'Je mise' x3 clics : Verrouille/Déverrouille mise (%)", "Case 'f' adverse (appui 2s) : Bonjour Eric", "Case 'a' adverse (appui 2s) : Retour arrière (annule dernier coup)", "Cases 'f' + 'a' adverses (appui 3s simultané) : Montre cette liste" ],
                 commentModalTitle: "Ajouter un Commentaire",
                 commentInputPlaceholder: "Votre note stratégique ici...",
                 commentCheckboxGood: "Bon coup potentiel",
                 commentCheckboxBad: "Mauvais coup potentiel",
                 commentCheckboxRisky: "Risqué",
                 commentCheckboxSafe: "Sécurisé",
                 historyTitle: "Historique des Parties",
                 historyRecordTitle: (name, date) => `Partie: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `Réussite: ${rate}% | Pot final: ${pot}€ | Durée: ${duration}s`,
                 historyCommentsTitle: "Commentaires Enregistrés",
                 historyErrorsTitle: "Erreurs de Pari",
                 historyNoComments: "Aucun commentaire enregistré pour cette partie.",
                 historyNoErrors: "Aucune erreur de pari enregistrée pour cette partie.",
                 historyInProgress: "(En cours)",
                 historyMoveLabel: "Coup",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Parié <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pot ${potChange > 0 ? '+' : ''}${potChange}€) <small>(${date})</small>`,
                 premiumModalTitle: "Fonctionnalité Premium",
                 premiumModalText: "Cette fonctionnalité, ainsi que d'autres avantages, sont réservés aux membres Premium.",
                 premiumModalBenefitsTitle: "Avantages Premium :",
                 premiumBenefitLevels: "Accès à toutes les parties d'entraînement.",
                 premiumBenefitHistory: "Bouton 'Histo' pour voir et analyser vos parties précédentes.",
                 premiumBenefitRecord: "Bouton 'Enr' pour ajouter des commentaires stratégiques.",
                 premiumBenefitAids: "Activation des aides visuelles (captures/pression).",
                 premiumBenefitCross: "Activation de la croix rouge d'alignement.",
                 premiumBenefitSecrets: "Accès aux astuces secrètes.",
                 premiumModalHowto: "Pour débloquer la version Premium et soutenir notre association, devenez membre de <strong>Jeux Nomades France</strong> :",
                 premiumModalActionLink: "Adhérer à l'association",
                 gameDropdownFormat: (index, moves) => `Partie ${index} (${moves} coups)`,
                 encouragingMessages: [ "Bravo!", "Super!", "Excellent!", "Continue!", "Impressionnant!", "Magnifique!", "Doué!", "Formidable!", "Incroyable!", "Génial!", "Parfait!", "Époustouflant!", "Étoile montante!", "Sensationnel!", "Triomphe!", "Maître!", "Légendaire!", "Génie!", "Champion!", "Immortel!" ]
             },
              en: { /* ... */ },
              es: { /* ... */ },
              ru: { /* ... */ },
              zh: { /* ... */ }
        };

        // --- Fonctions Utilitaires (Identiques) ---
        function closeModal(modalId) {
             const modal = document.getElementById(modalId);
             if (modal) modal.style.display = 'none';
        }
        function showPremiumInfoModal() {
             const t = translations[currentLanguage] || translations.en;
             document.getElementById('premium-modal-title').textContent = t.premiumModalTitle;
             document.getElementById('premium-modal-text').textContent = t.premiumModalText;
             document.getElementById('premium-modal-benefits-title').textContent = t.premiumModalBenefitsTitle;
             document.getElementById('premium-benefit-levels').textContent = t.premiumBenefitLevels;
             document.getElementById('premium-benefit-history').textContent = t.premiumBenefitHistory;
             document.getElementById('premium-benefit-record').textContent = t.premiumBenefitRecord;
             document.getElementById('premium-benefit-aids').textContent = t.premiumBenefitAids;
             document.getElementById('premium-benefit-cross').textContent = t.premiumBenefitCross;
             document.getElementById('premium-benefit-secrets').textContent = t.premiumBenefitSecrets;
             document.getElementById('premium-modal-howto').innerHTML = t.premiumModalHowto;
             document.getElementById('premium-modal-action-link').textContent = t.premiumModalActionLink;
             document.getElementById('premium-modal-close').textContent = t.closeButton;
             const modal = document.getElementById('premium-info-modal');
             if (modal) modal.style.display = 'block';
        }
        function toggleCrossVisibility() {
             const t = translations[currentLanguage] || translations.en;
             if (!isPremium) { showPremiumInfoModal(); return; }
             isCrossVisible = !isCrossVisible;
             applyCrossVisibility();
        }
        function applyCrossVisibility() {
            const crossElement = document.getElementById('red-cross');
            if (crossElement) { crossElement.style.display = (isPremium && isCrossVisible) ? 'flex' : 'none'; }
        }
        function toggleAides() {
             const t = translations[currentLanguage] || translations.en;
             if (!isPremium) { showPremiumInfoModal(); return; }
             areAidesEnabled = !areAidesEnabled;
             showTemporaryMessage(areAidesEnabled ? t.aidesEnabled : t.aidesDisabled);
             renderBoard();
        }
        function showTemporaryMessage(message) {
             const resultEl = document.getElementById('result');
             if (resultEl) {
                 const originalText = resultEl.textContent;
                 const originalColor = resultEl.style.color;
                 resultEl.textContent = message;
                 resultEl.style.color = '#17a2b8'; // Info color
                 setTimeout(() => {
                     // Restore only if the message hasn't changed in the meantime
                     if (resultEl.textContent === message) {
                         resultEl.textContent = originalText;
                         resultEl.style.color = originalColor;
                     }
                 }, 2000);
             }
        }
        function loadGameRecords() {
            const savedRecords = localStorage.getItem('awaleGameRecords');
            if (savedRecords) {
                try {
                     gameRecords = JSON.parse(savedRecords);
                     if (!Array.isArray(gameRecords)) gameRecords = [];
                } catch (e) { console.error("Error parsing saved records:", e); gameRecords = []; }
            } else { gameRecords = []; }
        }
        function saveGameRecords() {
            try { localStorage.setItem('awaleGameRecords', JSON.stringify(gameRecords)); }
            catch (e) { console.error("Error saving game records:", e); }
        }

        // --- Fonction de Mise à Jour Langue (Identique) ---
        function updateLanguage() {
            currentLanguage = document.getElementById("language-select").value || "fr";
            const t = translations[currentLanguage] || translations.en;

            document.documentElement.lang = currentLanguage;
            document.title = t.pageTitle;

            try {
                document.getElementById("language-label").textContent = t.languageLabel;
                document.getElementById("level-label").textContent = t.levelLabel;
                document.getElementById("title").textContent = t.title;
                document.getElementById("bet-label").textContent = t.betLabel;
                document.getElementById("bet-case-label").textContent = t.betCaseLabel;
                document.getElementById("bet-and-verify-btn").textContent = t.betButton;
                document.getElementById("next-btn").textContent = t.nextButton;

                const recordBtn = document.getElementById('record-btn');
                if (recordBtn) { recordBtn.textContent = t.recordButtonShort; recordBtn.title = t.tooltipRecord; }
                const historyBtn = document.getElementById('history-btn');
                if (historyBtn) { historyBtn.textContent = t.historyButtonShort; historyBtn.title = t.tooltipHistory; }
                document.getElementById("help-btn").title = t.tooltipHelp;
                document.getElementById("theme-toggle").title = t.tooltipTheme;
                document.getElementById("cross-toggle-btn").title = t.tooltipCross;

                const betPotInfoEl = document.getElementById('bet-pot-info');
                if (betPotInfoEl) betPotInfoEl.title = t.tooltipPot;
                const successRateEl = document.getElementById('success-rate');
                if (successRateEl) successRateEl.title = t.tooltipSuccessRate;

                document.getElementById("help-title").textContent = t.helpTitle;
                const helpTextElement = document.getElementById("help-text");
                if (helpTextElement) {
                    const helpTextContent = isPremium ? (t.helpTextPremium || t.helpTextStandard) : t.helpTextStandard;
                    helpTextElement.innerHTML = helpTextContent;
                }
                 const helpCloseBtn = document.getElementById('help-modal-close');
                 if(helpCloseBtn) helpCloseBtn.textContent = t.closeButton;

                 document.getElementById("secret-tips-title").textContent = t.secretTipsTitle;
                 const secretCloseBtn = document.getElementById('secret-modal-close');
                 if(secretCloseBtn) secretCloseBtn.textContent = t.closeButton;

                 document.getElementById("history-title").textContent = t.historyTitle;
                 const historyCopyBtn = document.getElementById('history-copy-btn');
                 if(historyCopyBtn) historyCopyBtn.textContent = t.copyButton;
                 const historyResetBtn = document.getElementById('history-reset-btn');
                 if(historyResetBtn) historyResetBtn.textContent = t.resetButton;
                 const historyCloseBtn = document.getElementById('history-close-btn');
                 if(historyCloseBtn) historyCloseBtn.textContent = t.closeButton;

                 document.getElementById("comment-title").textContent = t.commentModalTitle;
                 const commentInput = document.getElementById("comment-input");
                 if(commentInput) commentInput.placeholder = t.commentInputPlaceholder;
                 const commentSaveBtn = document.getElementById('comment-save-btn');
                 if(commentSaveBtn) commentSaveBtn.textContent = t.saveButton;
                 const commentCancelBtn = document.getElementById('comment-cancel-btn');
                 if(commentCancelBtn) commentCancelBtn.textContent = t.cancelButton;
                 document.querySelector('input[name="comment-option"][value="GoodMove"] + .checkbox-label-text').textContent = t.commentCheckboxGood;
                 document.querySelector('input[name="comment-option"][value="BadMove"] + .checkbox-label-text').textContent = t.commentCheckboxBad;
                 document.querySelector('input[name="comment-option"][value="Risky"] + .checkbox-label-text').textContent = t.commentCheckboxRisky;
                 document.querySelector('input[name="comment-option"][value="Safe"] + .checkbox-label-text').textContent = t.commentCheckboxSafe;

                if (document.getElementById('premium-info-modal').style.display === 'block') {
                    showPremiumInfoModal(); // Update premium modal content if open
                }

            } catch (error) { console.error("Error updating static text elements:", error); }

            populateGameSelect(); // Update game dropdown based on premium status
            renderBoard(); // Re-render board with current data and labels

            console.log("Language update finished for:", currentLanguage);
        }

        // --- Fonctions de Configuration Jeu (Identiques) ---
        function populateGameSelect() {
            const select = document.getElementById("level-select");
            if (!select) { console.error("Level select element not found"); return; }
            const t = translations[currentLanguage] || translations.en;
            const currentSelectedIndex = select.value ? parseInt(select.value) : currentGameIndex;

            select.innerHTML = "";
            const maxGamesToShow = isPremium ? games.length : 3; // Show all if premium
            const gamesToShowCount = Math.min(maxGamesToShow, games.length);
            // Ensure at least one game is shown if available
            const visibleGames = games.slice(0, Math.max(1, gamesToShowCount));

            visibleGames.forEach((game, index) => {
                const option = document.createElement("option");
                option.value = index;
                option.textContent = t.gameDropdownFormat(index + 1, game.length);
                select.appendChild(option);
            });

            // Restore selection or default to 0
             if (select.options.length > 0) {
                 const validIndex = Math.min(currentSelectedIndex, select.options.length - 1);
                 select.value = select.options[validIndex] ? validIndex : 0;
             }
        }
        function changeLevel() {
            const select = document.getElementById("level-select");
            if (!select) return;
            const selectedValue = select.value;
            let potentialNewIndex = parseInt(selectedValue);
            const maxAllowedIndex = isPremium ? games.length - 1 : Math.min(2, games.length - 1);

            if (isNaN(potentialNewIndex) || potentialNewIndex < 0 || potentialNewIndex > maxAllowedIndex) {
                console.warn(`Invalid level selection ${selectedValue}. Max allowed: ${maxAllowedIndex}. Defaulting to 0.`);
                potentialNewIndex = 0;
                select.value = 0; // Update dropdown visually
            }
            // Only restart if the index actually changes or no game is loaded
            if (currentGameIndex !== potentialNewIndex || currentGame.length === 0) {
                currentGameIndex = potentialNewIndex;
                if (games[currentGameIndex]) {
                    currentGame = games[currentGameIndex].split('');
                    restartGame(); // Restart resets board, scores, history etc.
                } else {
                    // Fallback if somehow an invalid index slips through (shouldn't happen with checks above)
                    console.error("Selected game data not found:", currentGameIndex);
                    currentGameIndex = 0;
                    select.value = 0;
                    currentGame = games[0] ? games[0].split('') : [];
                    restartGame();
                }
            }
        }
        function setDefaultBet() {
            const select = document.getElementById('bet-amount');
            if (select) {
                if (isBetLocked && lockedBetPercentage !== null) {
                    select.value = lockedBetPercentage;
                    select.disabled = true; // Keep it disabled visually
                } else {
                    // Ensure bet is unlocked if state says so
                    isBetLocked = false;
                    lockedBetPercentage = null;
                    select.value = "75"; // Default bet
                    select.disabled = false;
                }
            }
             // Calculate initial bet amount based on selection (might be needed elsewhere)
             // betAmount = Math.max(0, Math.floor(pot * (parseInt(select.value) / 100)));
        }

        // --- Fonction de Rendu Plateau (Identique) ---
        function renderBoard() {
            try {
                const t = translations[currentLanguage] || translations.en;
                const player1Row = document.getElementById('player1-row');
                const player2Row = document.getElementById('player2-row');
                if (!player1Row || !player2Row) { console.error("CRITICAL: #player1-row or #player2-row not found."); document.getElementById('result').textContent = t.errorDisplayMessage; return; }

                player1Row.innerHTML = '';
                player2Row.innerHTML = '';

                 // Add more robust checks for board and scores validity
                 if (!board || typeof board !== 'object' || !Array.isArray(board.player1) || !Array.isArray(board.player2) ||
                     !scores || typeof scores !== 'object' || typeof scores.player1 !== 'number' || typeof scores.player2 !== 'number') {
                     console.error("CRITICAL: Board or scores data is invalid or missing.", board, scores);
                     // Attempt to reset to a safe state if data is corrupt
                     // restartGame(); // Be careful with recursive calls or loops here
                     document.getElementById('result').textContent = t.errorDisplayMessage; // Show error
                     return; // Stop rendering
                 }

                const betInput = document.getElementById('bet-input');
                const selectedBetCode = betInput ? betInput.value : null;
                const isCurrentlyGameOver = currentMoveIndex + 1 >= currentGame.length;
                // Manage confetti state properly
                 isGameOver.confettiShown = isGameOver.confettiShown && isCurrentlyGameOver; // Reset if game restarts
                const nextMoveCode = isCurrentlyGameOver ? null : currentGame[currentMoveIndex + 1];
                const isPlayer1Turn = !isCurrentlyGameOver && /[A-F]/.test(nextMoveCode);

                // Clear any previous animation timeout
                clearTimeout(animationTimeout);

                // --- Calculate Visual Aids (Captures/Pressure) ---
                let capturedOpponentHolesIndices = [];
                let pressuredOpponentHolesIndices = [];
                let threatenedPlayer1HolesIndices = [];
                if (isPremium && areAidesEnabled && isPlayer1Turn && board.player1 && board.player2) {
                    if (selectedBetCode) {
                        const selectedIndex = holeMap[selectedBetCode];
                        // Ensure the selected hole is valid and has seeds
                        if (selectedIndex !== undefined && board.player1[selectedIndex] > 0) {
                            // Simulate the selected move to see potential captures/pressure
                            const simResultP1 = simulateMove(selectedBetCode, { simulateOnly: true, currentBoard: board, currentScores: scores });
                            if (simResultP1 && Array.isArray(simResultP1.capturedHoles)) {
                                capturedOpponentHolesIndices = simResultP1.capturedHoles.filter(h => h.player === 2).map(h => h.index);
                                // Only calculate pressure if the direct move doesn't capture
                                if (capturedOpponentHolesIndices.length === 0) {
                                    pressuredOpponentHolesIndices = analyzeFuturePressure(simResultP1.board, simResultP1.scores);
                                }
                            }
                        }
                    }

                    // Simulate potential opponent moves to see threats
                    opponentHoleCodes.forEach((opponentMoveCode) => {
                        const opponentHoleIndex = holeMap[opponentMoveCode];
                         // Ensure the opponent hole is valid and has seeds
                        if (opponentHoleIndex !== undefined && board.player2[opponentHoleIndex] > 0) {
                             const simResultP2 = simulateMove(opponentMoveCode, { simulateOnly: true, currentBoard: board, currentScores: scores });
                             if (simResultP2 && Array.isArray(simResultP2.capturedHoles)) {
                                 const capturedP1Holes = simResultP2.capturedHoles.filter(h => h.player === 1).map(h => h.index);
                                 // Add unique indices to the threatened list
                                 capturedP1Holes.forEach(threatIndex => {
                                     if (!threatenedPlayer1HolesIndices.includes(threatIndex)) {
                                         threatenedPlayer1HolesIndices.push(threatIndex);
                                     }
                                 });
                             }
                        }
                    });
                }
                // --- End Visual Aids Calculation ---

                 // Update Turn Indicator
                 const turnIndicator = document.getElementById('turn-indicator');
                 if (turnIndicator) {
                     if (isCurrentlyGameOver) {
                         turnIndicator.textContent = ""; // Clear indicator at game end
                         turnIndicator.className = "";
                     } else {
                         turnIndicator.textContent = isPlayer1Turn ? t.playerTurnIndicator : t.opponentTurnIndicator;
                         turnIndicator.className = isPlayer1Turn ? 'player-turn' : 'opponent-turn';
                     }
                 }

                // Render Player 1 Row
                board.player1.forEach((seeds, index) => {
                    const hole = document.createElement('div');
                    const holeCode = playerHoleCodes[index];
                    hole.className = 'hole player1-hole';
                    hole.textContent = seeds;
                    hole.dataset.code = holeCode; // Store code for potential selection

                    const isClickable = isPlayer1Turn && seeds > 0;
                    if (isClickable) {
                        hole.classList.add('clickable');
                        hole.addEventListener('click', () => {
                            if (betInput) betInput.value = holeCode; // Update dropdown on click
                            renderBoard(); // Re-render to show selection highlight
                        });
                    } else if (isPlayer1Turn && seeds === 0) {
                         hole.classList.add('disabled');
                         hole.addEventListener('click', () => showTemporaryMessage(t.emptyHoleMessage));
                    } else if (!isPlayer1Turn) {
                        hole.classList.add('disabled');
                         hole.addEventListener('click', () => showTemporaryMessage(t.opponentTurnMessage));
                    }

                    // Apply highlights/styles
                    if (holeCode === selectedBetCode && isPlayer1Turn) hole.classList.add('selected-bet');
                    if (isPremium && areAidesEnabled && isPlayer1Turn && threatenedPlayer1HolesIndices.includes(index)) hole.classList.add('highlight-pressure-enabled');
                    if (holeCode === lastIncorrectGuess) hole.classList.add('highlight-incorrect');
                    if (holeCode === lastCorrectMove) hole.classList.add('highlight-correct');
                    if (highlightStartHole?.player === 1 && highlightStartHole?.index === index) hole.classList.add('highlight-start');
                    if (highlightEndHole?.player === 1 && highlightEndHole?.index === index) hole.classList.add('highlight-end');

                    player1Row.appendChild(hole);
                });

                // Render Player 2 Row (reversed visually)
                const reversedPlayer2 = [...board.player2].reverse();
                reversedPlayer2.forEach((seeds, visualIndex) => {
                    const actualIndex = 5 - visualIndex; // Map visual index back to actual board index (0-5)
                    const holeCode = opponentHoleCodes[actualIndex];
                    const hole = document.createElement('div');
                    hole.className = 'hole player2-hole';
                    hole.textContent = seeds;
                    hole.dataset.index = actualIndex; // Store actual index
                    hole.dataset.code = holeCode; // Store code for secret listeners

                    // Add listeners for secrets on specific holes
                    addLongPressListenerForSecrets(hole, actualIndex);

                     // Apply highlights/styles for opponent row
                    if (isPremium && areAidesEnabled && isPlayer1Turn) {
                        if (capturedOpponentHolesIndices.includes(actualIndex)) hole.classList.add('highlight-capture-enabled');
                        else if (pressuredOpponentHolesIndices.includes(actualIndex)) hole.classList.add('highlight-pressure-enabled');
                    }
                    if (highlightStartHole?.player === 2 && highlightStartHole?.index === actualIndex) hole.classList.add('highlight-start');
                    if (highlightEndHole?.player === 2 && highlightEndHole?.index === actualIndex) hole.classList.add('highlight-end');

                    player2Row.appendChild(hole);
                });

                 // Show/hide premium buttons
                 const recordBtn = document.getElementById('record-btn');
                 const historyBtn = document.getElementById('history-btn');
                 if(recordBtn) recordBtn.style.display = isPremium ? 'inline-block' : 'none';
                 if(historyBtn) historyBtn.style.display = isPremium ? 'inline-block' : 'none';

                 // Update Info Displays
                const moveInfoEl = document.getElementById('move-info');
                if (moveInfoEl) moveInfoEl.textContent = t.moveInfo(scores.player1, scores.player2);

                const betPotInfoEl = document.getElementById('bet-pot-info');
                if (betPotInfoEl) betPotInfoEl.innerHTML = t.betPotInfo(pot); // Use innerHTML for <BR>

                const successRateEl = document.getElementById('success-rate');
                if (successRateEl) {
                    const rate = totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100);
                    successRateEl.innerHTML = t.successRate(rate); // Use innerHTML for <BR>
                }

                const playedMovesEl = document.getElementById('played-moves');
                 if (playedMovesEl) {
                     // Ensure playedMoves is an array before using slice/join
                     const movesToShow = Array.isArray(playedMoves) ? playedMoves.slice(-10).join(' ') : '';
                     playedMovesEl.textContent = t.playedMoves(currentMoveIndex + 1, currentGame.length, movesToShow);
                 }

                 // Manage Button Visibility and Game Over State
                const betButton = document.getElementById('bet-and-verify-btn');
                const nextButton = document.getElementById('next-btn');
                const resultEl = document.getElementById('result');

                if (betButton && nextButton && resultEl) {
                    if (isCurrentlyGameOver) {
                        betButton.style.display = 'none';
                        nextButton.style.display = 'none';

                        // Only set GameOver message if not already showing win/loss or info message
                         if (!resultEl.textContent.includes(t.resultWin) &&
                             !resultEl.textContent.includes(t.resultLose) &&
                              resultEl.style.color !== 'rgb(23, 162, 184)') { // Check for info message color
                                if (resultEl.textContent !== t.resultGameOver) {
                                     resultEl.textContent = t.resultGameOver;
                                     resultEl.style.color = '#ff0000'; // Red for game over
                                }
                         }

                        // Trigger confetti on perfect game end
                        if (totalPlayer1Bets > 0 && successfulBets === totalPlayer1Bets && pot > 100 && !isGameOver.confettiShown) {
                             perfectGamesCount++; // Increment counter
                             rainConfetti();
                             isGameOver.confettiShown = true; // Prevent multiple confetti runs
                             // Show encouraging message after delay
                             const messages = t.encouragingMessages || translations.en.encouragingMessages;
                             const messageIndex = Math.min(perfectGamesCount - 1, messages.length - 1); // Cycle messages
                             setTimeout(() => {
                                 const resEl = document.getElementById('result');
                                 if (resEl && resEl.textContent.startsWith(t.resultGameOver)) {
                                      resEl.textContent = t.resultGameOver + " " + messages[messageIndex];
                                      resEl.style.color = '#008000'; // Green for success message
                                 }
                             }, 2500); // Show after confetti settles
                        }

                         // Finalize game record if game just ended
                         if (currentGameRecord.startTime && !currentGameRecord.endTime) {
                             finalizeGameRecord();
                         }

                    } else {
                        betButton.style.display = isPlayer1Turn ? 'inline-block' : 'none';
                        nextButton.style.display = isPlayer1Turn ? 'none' : 'inline-block';
                        // Clear "Game Over" message if the game is ongoing
                        if (resultEl.textContent === t.resultGameOver) {
                            resultEl.textContent = "";
                        }
                    }
                }

                // Update bet dropdown listener if needed (e.g., to re-render on selection)
                if (betInput) { betInput.onchange = () => renderBoard(); }

                // Apply cross visibility based on state
                applyCrossVisibility();

            } catch (error) {
                 console.error("Error during renderBoard:", error);
                 const t = translations[currentLanguage] || translations.en;
                 const resultEl = document.getElementById('result');
                 if (resultEl) {
                     resultEl.textContent = t.errorDisplayMessage;
                     resultEl.style.color = "red";
                 }
                 // Attempt to prevent infinite loops if render fails
                 clearTimeout(animationTimeout);
             }
        }


        // --- Fonctions Logiques ---

        // ========================================================================
        // ===      simulateMove AVEC ANCIENNE LOGIQUE ANTI-FAMINE (Corrigée)     ===
        // ========================================================================
        function simulateMove(moveCode, options = {}) {
            const { simulateOnly = false, currentBoard = board, currentScores = scores } = options;
            let tempBoard, tempScores; // Variables locales pour la simulation
            const t = translations[currentLanguage] || translations.en;

            try {
                // Toujours travailler sur des copies profondes pour la simulation interne
                tempBoard = JSON.parse(JSON.stringify(currentBoard));
                tempScores = JSON.parse(JSON.stringify(currentScores));

                // Vérifications initiales de la structure des données
                 if (!tempBoard?.player1 || !tempBoard?.player2 || !tempScores ||
                     !Array.isArray(tempBoard.player1) || !Array.isArray(tempBoard.player2) ||
                     typeof tempScores.player1 !== 'number' || typeof tempScores.player2 !== 'number') {
                      console.error("Invalid board/scores structure provided to simulateMove", currentBoard, currentScores);
                      const safeBoard = initialBoard(); const safeScores = initialScores();
                      return { board: safeBoard, scores: safeScores, startHole: null, endHole: null, captured: 0, capturedHoles: [] };
                 }

                const isPlayer1 = /[A-F]/.test(moveCode);
                const playerBoard = isPlayer1 ? tempBoard.player1 : tempBoard.player2;
                const holeIndex = holeMap[moveCode];

                // Vérification de la case de départ valide
                if (holeIndex === undefined || holeIndex < 0 || holeIndex > 5 || !playerBoard || playerBoard[holeIndex] === undefined || playerBoard[holeIndex] <= 0) {
                    console.warn(`SimulateMove invalid start: ${moveCode} from hole ${holeIndex} with ${playerBoard ? playerBoard[holeIndex] : 'N/A'} seeds.`);
                    return { board: JSON.parse(JSON.stringify(currentBoard)), scores: JSON.parse(JSON.stringify(currentScores)), startHole: { player: isPlayer1 ? 1 : 2, index: holeIndex }, endHole: { player: isPlayer1 ? 1 : 2, index: holeIndex }, captured: 0, capturedHoles: [] };
                }

                // --- Distribution des graines (sur tempBoard/tempScores locales) ---
                const startHole = { player: isPlayer1 ? 1 : 2, index: holeIndex };
                let seeds = playerBoard[holeIndex];
                playerBoard[holeIndex] = 0; // Vide la case de départ sur tempBoard locale

                let currentPlayer = isPlayer1 ? 1 : 2;
                let currentHole = holeIndex;
                let seedsToDistribute = seeds;
                let lastHole = null;

                // Boucle de distribution
                while (seedsToDistribute > 0) {
                    if (currentPlayer === 1) {
                        currentHole++;
                        if (currentHole > 5) { currentPlayer = 2; currentHole = 0; }
                    } else { // currentPlayer === 2
                        currentHole++;
                        if (currentHole > 5) { currentPlayer = 1; currentHole = 0; }
                    }
                    const isStartingHole = (isPlayer1 && currentPlayer === 1 && currentHole === holeIndex) || (!isPlayer1 && currentPlayer === 2 && currentHole === holeIndex);
                    // Ne pas semer dans la case de départ si c'est un Krou
                    if (!(seeds >= 12 && isStartingHole)) {
                        if (currentPlayer === 1) tempBoard.player1[currentHole]++;
                        else tempBoard.player2[currentHole]++;
                        seedsToDistribute--;
                    }
                    // Mémoriser la dernière case où une graine a été posée
                    if (seedsToDistribute === 0) lastHole = { player: currentPlayer, index: currentHole };
                }
                const endHole = lastHole || startHole; // Fallback si 0 graine (ne devrait pas arriver avec la vérif initiale)

                // --- Logique de capture et Anti-Famine (ANCIENNE VERSION sur copies) ---
                let capturedSeedsTotal = 0;
                let capturedHolesPath = []; // Pour stocker les détails des trous capturés
                const landedPlayer = lastHole ? lastHole.player : (isPlayer1 ? 1 : 2); // Joueur de la dernière case
                const landedHoleIndex = lastHole ? lastHole.index : holeIndex; // Index de la dernière case

                // Seulement si la dernière graine tombe chez l'adversaire
                if (lastHole && ((isPlayer1 && landedPlayer === 2) || (!isPlayer1 && landedPlayer === 1)))
                {
                    // Crée une copie *seulement* pour la vérification anti-famine
                    let newBoardForCheck = JSON.parse(JSON.stringify(tempBoard));
                    let tempCapturedInLoop = 0; // Total pour la vérification
                    let currentCapturePathDetails = []; // Stocke les détails pour le retour

                    // Cas: Joueur 1 termine chez Joueur 2
                    if (isPlayer1 && landedPlayer === 2) {
                        let capturePos = landedHoleIndex;

                        // Boucle arrière (vérifie sur tempBoard, *modifie newBoardForCheck*)
                        while (capturePos >= 0 && (tempBoard.player2[capturePos] === 2 || tempBoard.player2[capturePos] === 3)) {
                            const seedsInHole = tempBoard.player2[capturePos];
                            tempCapturedInLoop += seedsInHole;
                            currentCapturePathDetails.push({ index: capturePos, player: 2, value: seedsInHole });
                            newBoardForCheck.player2[capturePos] = 0; // Modifie la copie de vérification
                            capturePos--;
                        }

                        // Vérification anti-famine SUR la copie newBoardForCheck
                        if (tempCapturedInLoop > 0 && !newBoardForCheck.player2.every(s => s === 0)) {
                             // Capture valide: Prépare les valeurs et modifie tempBoard/tempScores
                             capturedSeedsTotal = tempCapturedInLoop;
                             capturedHolesPath = currentCapturePathDetails;
                             capturedHolesPath.forEach(holeInfo => { tempBoard.player2[holeInfo.index] = 0; });
                             tempScores.player1 += capturedSeedsTotal;
                        } // else: Famine, on ne fait rien, les valeurs restent 0/[]

                    // Cas: Joueur 2 termine chez Joueur 1
                    } else if (!isPlayer1 && landedPlayer === 1) {
                         let capturePos = landedHoleIndex;

                         // Boucle arrière (vérifie sur tempBoard, *modifie newBoardForCheck*)
                         while (capturePos >= 0 && (tempBoard.player1[capturePos] === 2 || tempBoard.player1[capturePos] === 3)) {
                             const seedsInHole = tempBoard.player1[capturePos];
                             tempCapturedInLoop += seedsInHole;
                             currentCapturePathDetails.push({ index: capturePos, player: 1, value: seedsInHole });
                             newBoardForCheck.player1[capturePos] = 0;
                             capturePos--;
                        }

                        // Vérification anti-famine SUR la copie newBoardForCheck
                        if (tempCapturedInLoop > 0 && !newBoardForCheck.player1.every(s => s === 0)) {
                            // Capture valide: Prépare les valeurs et modifie tempBoard/tempScores
                            capturedSeedsTotal = tempCapturedInLoop;
                            capturedHolesPath = currentCapturePathDetails;
                            capturedHolesPath.forEach(holeInfo => { tempBoard.player1[holeInfo.index] = 0; });
                            tempScores.player2 += capturedSeedsTotal;
                        } // else: Famine, on ne fait rien
                    }
                } // Fin de la condition "atterri chez l'adversaire"

                // Retourne l'état final simulé (tempBoard, tempScores) et les infos de capture
                return {
                    board: tempBoard,
                    scores: tempScores,
                    startHole: startHole,
                    endHole: endHole,
                    captured: capturedSeedsTotal,
                    capturedHoles: capturedHolesPath
                };

            } catch (error) {
                console.error("Error during simulateMove:", error, moveCode, currentBoard);
                showTemporaryMessage(t.internalErrorMessage);
                const safeBoard = initialBoard();
                const safeScores = initialScores();
                 return { board: safeBoard, scores: safeScores, startHole: null, endHole: null, captured: 0, capturedHoles: [] };
            }
        }
        // ========================================================================
        // ===                 FIN de simulateMove MODIFIÉE (Corrigée)            ===
        // ========================================================================


        function analyzeFuturePressure(simulatedBoard, simulatedScores) {
             // --- Identique au nouveau code ---
             const pressurePoints = [];
             const opponentPlayer = 2; // Assuming analysis is for Player 1's turn

             if (!simulatedBoard?.player2) return []; // Need opponent board

             // Find opponent holes vulnerable to future capture (1 or 2 seeds)
             const vulnerableHolesIndices = simulatedBoard.player2.reduce((acc, seeds, index) => {
                 if (seeds === 1 || seeds === 2) acc.push(index);
                 return acc;
             }, []);

             if (vulnerableHolesIndices.length === 0) return []; // No vulnerable holes

             if (!simulatedBoard?.player1) return []; // Need player board

             // Simulate each possible *next* move for Player 1
             for (let playerHoleIndex = 0; playerHoleIndex < playerHoleCodes.length; playerHoleIndex++) {
                 const playerSeeds = simulatedBoard.player1[playerHoleIndex];
                 if (playerSeeds > 0) {
                     const potentialNextMoveCode = playerHoleCodes[playerHoleIndex];
                     // Simulate this next move
                     const nextSimResult = simulateMove(potentialNextMoveCode, {
                         simulateOnly: true,
                         currentBoard: simulatedBoard,
                         currentScores: simulatedScores
                     });

                     // Check if this simulated *next* move captures any of the vulnerable holes
                     if (nextSimResult && Array.isArray(nextSimResult.capturedHoles)) {
                         const capturedByThisNextMove = nextSimResult.capturedHoles
                             .filter(h => h.player === opponentPlayer) // Only opponent captures count
                             .map(h => h.index);

                         vulnerableHolesIndices.forEach(vulnIndex => {
                             // If a vulnerable hole IS captured by this potential next move, mark it as pressured
                             if (capturedByThisNextMove.includes(vulnIndex) && !pressurePoints.includes(vulnIndex)) {
                                 pressurePoints.push(vulnIndex);
                             }
                         });
                     }
                 }
                 // Optimization: if all vulnerable holes are already marked as pressured, stop checking
                 if (pressurePoints.length === vulnerableHolesIndices.length) break;
             }
             return pressurePoints;
        }

        function betAndVerify() {
             // --- Identique au nouveau code ---
             const t = translations[currentLanguage] || translations.en;
             const betInput = document.getElementById('bet-input');
             if (!betInput) return;
             currentBet = betInput.value; // The hole player selected (e.g., 'A')

             const betSelect = document.getElementById('bet-amount');
             if (!betSelect) return;
             let betPercentage = parseInt(betSelect.value);

             if (isNaN(betPercentage) || betPercentage <= 0 || betPercentage > 100) {
                 showTemporaryMessage(t.resultInvalidBet + " (%)");
                 return;
             }

             if (isNaN(pot)) pot = 100; // Safety check for pot
             betAmount = Math.max(0, Math.floor(pot * (betPercentage / 100)));

             // Validate bet amount against pot
             if ((betAmount <= 0 && pot > 0) || betAmount > pot) {
                 showTemporaryMessage(t.resultInvalidBet + " (Amount/Funds)");
                 return;
             }

             // Check if game is already over
             if (currentMoveIndex + 1 >= currentGame.length) {
                 showTemporaryMessage(t.resultGameOver);
                 return;
             }

             const nextMove = currentGame[currentMoveIndex + 1]; // The actual correct move
             const isPlayer1Next = /[A-F]/.test(nextMove);

             // Check if it's actually player 1's turn
             if (!isPlayer1Next) {
                 showTemporaryMessage(t.notYourTurnMessage);
                 return;
             }

             // Check if the selected hole is valid to play
             const currentBetIndex = holeMap[currentBet];
             if (currentBetIndex === undefined || !board?.player1 || board.player1[currentBetIndex] === undefined || board.player1[currentBetIndex] <= 0) {
                  showTemporaryMessage(t.invalidHoleMessage);
                  return;
             }

             // Clear previous result highlights/messages before processing new bet
             document.getElementById('result').textContent = "";
             lastIncorrectGuess = null;
             lastCorrectMove = null;

             // --- Process the move ---
             currentMoveIndex++;
             totalPlayer1Bets++;
             if (!Array.isArray(playedMoves)) playedMoves = []; // Ensure array
             playedMoves.push(nextMove);

             // Start timer/record on first *player* move attempt of the game
             if (totalPlayer1Bets === 1 && currentMoveIndex === 0) { // Check if it's the very first bet
                 startNewGameRecord();
             }

             // Save state *before* simulating the correct move
             if (!Array.isArray(moveHistory)) moveHistory = []; // Ensure array
             moveHistory.push({
                 board: JSON.parse(JSON.stringify(board)),
                 scores: JSON.parse(JSON.stringify(scores)),
                 moveCode: nextMove // Record the move being made
             });

             // Simulate the *correct* next move (this updates global board/scores because simulateOnly is false by default)
             const moveResult = simulateMove(nextMove, { simulateOnly: false }); // IMPORTANT: Use the CORRECT move

             // Handle simulation errors
              if (!moveResult) {
                  console.error("Simulation failed for the correct move:", nextMove);
                  // Attempt to roll back state
                  moveHistory.pop(); // Remove the failed move attempt
                  const prevState = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
                  if (prevState && prevState.board && prevState.scores) {
                       board = JSON.parse(JSON.stringify(prevState.board));
                       scores = JSON.parse(JSON.stringify(prevState.scores));
                  } else { // Fallback if history is empty or corrupt
                       board = initialBoard();
                       scores = initialScores();
                  }
                  currentMoveIndex--; // Decrement index
                  totalPlayer1Bets--; // Decrement bet count
                  if (playedMoves.length > 0) playedMoves.pop(); // Remove from played moves display
                  showTemporaryMessage(t.internalErrorMessage);
                  renderBoard(); // Re-render previous state
                  return;
              }

              // Update global board/scores with the result of the *correct* move simulation
              // Note: The modified simulateMove might already update globals if simulateOnly is false.
              // Let's ensure it's explicitly set from the return value for clarity.
               board = moveResult.board;
               scores = moveResult.scores;

             // Trigger animation based on the *correct* move
             triggerAnimation(moveResult.startHole, moveResult.endHole);

             // Compare player's bet with the correct move
             const resultEl = document.getElementById('result');
             if (isSuccessGuaranteed || currentBet === nextMove) {
                 // Correct bet or success guaranteed
                 pot = Math.round(pot + betAmount); // Use Math.round for cleaner numbers
                 successfulBets++;
                 if (resultEl) {
                     resultEl.textContent = t.resultWin;
                     resultEl.style.color = '#008000'; // Green for win
                 }
             } else {
                 // Incorrect bet
                 pot = Math.max(0, Math.round(pot - betAmount)); // Ensure pot doesn't go below 0
                 if (resultEl) {
                     resultEl.textContent = `${t.resultLose} (${nextMove})`; // Show correct move
                     resultEl.style.color = '#ff0000'; // Red for loss
                 }
                 // Highlight the incorrect/correct holes
                 lastIncorrectGuess = currentBet;
                 lastCorrectMove = nextMove;

                 // Log the error
                 const errorData = {
                      moveIndex: currentMoveIndex,
                      bet: currentBet,
                      correctMove: nextMove,
                      potChange: -betAmount, // Log the negative change
                      betAmount: betAmount, // Store the original bet amount for potential undo
                      timestamp: Date.now()
                 };
                 if (!Array.isArray(errorLog)) errorLog = []; // Ensure array
                 errorLog.push(errorData);
                 // Also add to the current game record if active
                 if (currentGameRecord && Array.isArray(currentGameRecord.errors)) {
                     currentGameRecord.errors.push(errorData);
                 }
             }

             setDefaultBet(); // Reset bet percentage/amount display
             renderBoard(); // Update display with new state and result message
        }

        function moveNext() {
             // --- Identique au nouveau code ---
             const t = translations[currentLanguage] || translations.en;
             // Check if game is over
             if (currentMoveIndex + 1 >= currentGame.length) {
                 showTemporaryMessage(t.resultGameOver);
                 return;
             }

             const nextMove = currentGame[currentMoveIndex + 1];
             const isPlayer1Next = /[A-F]/.test(nextMove);

             // Check if it's opponent's turn (i.e., not Player 1's turn)
             if (isPlayer1Next) {
                 showTemporaryMessage(t.playerTurnIndicator); // Should be player's turn to bet
                 return;
             }

             // Clear previous result messages/highlights
             document.getElementById('result').textContent = "";
             lastIncorrectGuess = null;
             lastCorrectMove = null;

             // --- Process the opponent's move ---
             currentMoveIndex++;
             if (!Array.isArray(playedMoves)) playedMoves = [];
             playedMoves.push(nextMove);

             // Start timer/record if this is the very first move of the game (opponent starts)
             if (currentMoveIndex === 0 && totalPlayer1Bets === 0) { // Check if game just started
                  startNewGameRecord();
             }

             // Save state *before* simulating the opponent's move
              if (!Array.isArray(moveHistory)) moveHistory = [];
             moveHistory.push({
                 board: JSON.parse(JSON.stringify(board)),
                 scores: JSON.parse(JSON.stringify(scores)),
                 moveCode: nextMove // Record opponent move
             });

             // Simulate the opponent's move (updates global board/scores)
              const moveResult = simulateMove(nextMove, { simulateOnly: false });

             // Handle simulation errors
             if (!moveResult) {
                  console.error("Simulation failed for opponent move:", nextMove);
                   // Attempt to roll back state
                  moveHistory.pop();
                  const prevState = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
                  if (prevState && prevState.board && prevState.scores) {
                       board = JSON.parse(JSON.stringify(prevState.board));
                       scores = JSON.parse(JSON.stringify(prevState.scores));
                  } else {
                       board = initialBoard();
                       scores = initialScores();
                  }
                  currentMoveIndex--; // Decrement index
                   if (playedMoves.length > 0) playedMoves.pop();
                  showTemporaryMessage(t.internalErrorMessage);
                  renderBoard();
                  return;
             }

              // Update global board/scores explicitly from result
               board = moveResult.board;
               scores = moveResult.scores;

             // Trigger animation for opponent's move
             triggerAnimation(moveResult.startHole, moveResult.endHole);

             setDefaultBet(); // Prepare for player's next turn
             renderBoard(); // Update display
        }

        function triggerAnimation(startHole, endHole) {
             // --- Identique au nouveau code ---
             clearTimeout(animationTimeout); // Clear previous animation timer
             highlightStartHole = startHole;
             highlightEndHole = endHole;
             renderBoard(); // Render immediately with highlights
             // Set timeout to remove highlights
             animationTimeout = setTimeout(() => {
                 highlightStartHole = null;
                 highlightEndHole = null;
                 renderBoard(); // Render again without highlights
             }, 800); // Animation duration
        }

        // --- Fonctions Historique, Commentaires, Enregistrements (Identiques) ---
        function startNewGameRecord() {
            // Finalize any previous unfinished record before starting a new one
            if (currentGameRecord.startTime && !currentGameRecord.endTime) {
                finalizeGameRecord();
            }
            gameStartTime = Date.now();
            const t = translations[currentLanguage] || translations.en;
            currentGameRecord = {
                gameId: `game-${currentGameIndex + 1}-${gameStartTime}`, // Unique ID
                gameName: t.gameDropdownFormat(currentGameIndex + 1, currentGame.length),
                totalMoves: currentGame.length,
                startTime: gameStartTime,
                endTime: null,
                duration: 0,
                successRate: 0, // Will be calculated at the end
                finalPot: pot, // Initial pot, will be updated at the end
                comments: [], // Initialize as empty arrays
                errors: []
            };
            errorLog = []; // Reset separate error log as well
            console.log("Started new game record:", currentGameRecord.gameId);
        }
        function finalizeGameRecord() {
             // Ensure there's an active record to finalize
            if (!currentGameRecord || !currentGameRecord.startTime || currentGameRecord.endTime) {
                // console.log("No active game record to finalize or already finalized.");
                return;
            }

            console.log("Finalizing game record:", currentGameRecord.gameId);
            currentGameRecord.endTime = Date.now();
            currentGameRecord.duration = Math.round((currentGameRecord.endTime - currentGameRecord.startTime) / 1000); // Duration in seconds
            currentGameRecord.successRate = totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100);
            currentGameRecord.finalPot = pot; // Record the final pot value
            currentGameRecord.errors = [...errorLog]; // Copy the collected errors

             // Find if a record with the same ID exists (e.g., from previous incomplete save)
            const existingIndex = gameRecords.findIndex(r => r.gameId === currentGameRecord.gameId);
            if (existingIndex > -1) {
                gameRecords[existingIndex] = { ...currentGameRecord }; // Update existing
                 console.log("Updated existing game record:", currentGameRecord.gameId);
            } else {
                gameRecords.push({ ...currentGameRecord }); // Add new record
                 console.log("Added new game record:", currentGameRecord.gameId);
            }

            saveGameRecords(); // Save to localStorage

            // Reset current record state
            currentGameRecord = {};
            gameStartTime = null;
            errorLog = [];
        }
        function restartGame() {
            // --- Identique au nouveau code ---
            // Finalize the current game record before restarting
            finalizeGameRecord();

            // Reset game state variables
            board = initialBoard();
            scores = initialScores();
            currentMoveIndex = -1;
            // Start history with the initial state
            moveHistory = [{ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: null }];
            currentBet = null;
            playedMoves = [];
            pot = 100; // Reset pot
            successfulBets = 0;
            totalPlayer1Bets = 0;
            errorLog = []; // Reset error log for the new game
            gameStartTime = null; // Reset start time
            currentGameRecord = {}; // Reset current record object

            // Reset visual cues
            lastIncorrectGuess = null;
            lastCorrectMove = null;
            highlightStartHole = null;
            highlightEndHole = null;
            clearTimeout(animationTimeout); // Clear any pending animation
            isGameOver.confettiShown = false; // Allow confetti for the next game

            // Clear result message and secret message
            const resultEl = document.getElementById('result');
            if (resultEl) resultEl.textContent = "";
            const secretMsgEl = document.getElementById('secret-message');
            if (secretMsgEl) secretMsgEl.textContent = "";

            // Reset bet selection/locking state
            setDefaultBet();

            // Reload the correct game string based on currentGameIndex
             if (games[currentGameIndex]) {
                 currentGame = games[currentGameIndex].split('');
             } else {
                 // Fallback to game 0 if index is somehow invalid
                 console.error(`Game index ${currentGameIndex} invalid after restart. Defaulting to 0.`);
                 currentGameIndex = 0;
                 currentGame = games[0] ? games[0].split('') : [];
                 const levelSelect = document.getElementById('level-select');
                 if(levelSelect) levelSelect.value = 0; // Update dropdown if index changed
             }

            renderBoard(); // Render the reset state
        }
        function openCommentModal() {
            // --- Identique au nouveau code ---
            if (!isPremium) { showPremiumInfoModal(); return; }
            const modal = document.getElementById('comment-modal');
            if (modal) modal.style.display = 'block';
            // Clear previous input/selections
            const commentInput = document.getElementById('comment-input');
            if (commentInput) commentInput.value = '';
            document.querySelectorAll('input[name="comment-option"]').forEach(checkbox => checkbox.checked = false);
        }
        function saveComment() {
             // --- Identique au nouveau code ---
             // Ensure there's an active game record to save to
             if (!currentGameRecord || !currentGameRecord.startTime) {
                 console.warn("Cannot save comment: No active game record.");
                 closeModal('comment-modal');
                 return;
             }

             const t = translations[currentLanguage] || translations.en;
             const commentInput = document.getElementById('comment-input');
             const checkboxes = document.querySelectorAll('input[name="comment-option"]:checked');

             let commentText = commentInput ? commentInput.value.trim() : '';
             // Get the text labels for checked options based on current language
             const checkedOptions = Array.from(checkboxes).map(checkbox => {
                 switch (checkbox.value) {
                     case 'GoodMove': return t.commentCheckboxGood;
                     case 'BadMove': return t.commentCheckboxBad;
                     case 'Risky': return t.commentCheckboxRisky;
                     case 'Safe': return t.commentCheckboxSafe;
                     default: return checkbox.value; // Fallback for unexpected values
                 }
             });

             // Save only if there's text or at least one option checked
             if (commentText || checkedOptions.length > 0) {
                 // Determine the move number for context
                 const moveIndexForLabel = currentMoveIndex >= 0 ? currentMoveIndex + 1 : 0; // Use 0 for pre-game comment?
                 const moveLabel = moveIndexForLabel > 0 ? `${moveIndexForLabel}/${currentGame.length}` : "Start";
                 // Get the actual move code played (if available)
                 const moveCodePlayed = currentMoveIndex >= 0 ? currentGame[currentMoveIndex] : null;

                 const fullComment = {
                     move: moveLabel,
                     moveCode: moveCodePlayed,
                     timestamp: Date.now(),
                     text: commentText,
                     options: checkedOptions // Store the translated option strings
                 };

                 // Ensure the comments array exists on the record
                 if (!Array.isArray(currentGameRecord.comments)) {
                     currentGameRecord.comments = [];
                 }
                 currentGameRecord.comments.push(fullComment);
                 // Note: Game record is fully saved to localStorage only when finalized/restarted
             }

             closeModal('comment-modal');
        }
        function openHistoryModal() {
            // --- Identique au nouveau code ---
             if (!isPremium) { showPremiumInfoModal(); return; }

             const t = translations[currentLanguage] || translations.en;
             const historyContent = document.getElementById('history-content');
             const historyModal = document.getElementById('history-modal');
             if (!historyContent || !historyModal) { console.error("History modal elements not found"); return;}

             historyContent.innerHTML = ''; // Clear previous content

             // Create a temporary array including the potentially ongoing game
             const tempRecords = [...gameRecords];
             if (currentGameRecord && currentGameRecord.startTime && !currentGameRecord.endTime) {
                 // Create a snapshot of the current game state for display
                 const currentSnapshot = {
                     ...currentGameRecord, // Copy existing data
                     endTime: Date.now(), // Use current time for duration calculation
                     duration: Math.round((Date.now() - currentGameRecord.startTime) / 1000),
                     finalPot: pot, // Current pot
                     successRate: totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100),
                     errors: [...errorLog], // Copy current errors
                     comments: [...(currentGameRecord.comments || [])], // Copy current comments
                     isInProgress: true // Flag as ongoing
                 };
                 tempRecords.push(currentSnapshot);
             }

             // Sort records by start time, newest first
             tempRecords.sort((a, b) => (b.startTime || 0) - (a.startTime || 0));

             if (tempRecords.length === 0) {
                 historyContent.textContent = t.noHistory;
             } else {
                 tempRecords.forEach(record => {
                      // Basic check for valid record structure
                     if (!record || !record.startTime) return;

                     const entryDetails = document.createElement('details');
                     entryDetails.className = 'history-entry';
                     const entrySummary = document.createElement('summary');
                     entrySummary.className = 'history-summary';

                     // Format date/time according to locale
                     const gameDate = new Date(record.startTime).toLocaleString(currentLanguage, { dateStyle: 'short', timeStyle: 'short' });
                     // Format title and stats
                     const titleText = t.historyRecordTitle(record.gameName || `Game ID ${record.gameId}`, gameDate);
                     const statsText = t.historyStats(record.successRate ?? 0, record.finalPot ?? 0, record.duration ?? 0);
                     // Add "In Progress" indicator if applicable
                     const inProgressText = record.isInProgress ? ` <em style="color: #007bff;font-size:0.9em;">${t.historyInProgress}</em>` : '';

                     entrySummary.innerHTML = `<span style="flex-grow: 1;">${titleText} <span style="font-weight:normal; font-size:0.9em;">(${statsText})</span></span>${inProgressText}`;
                     entryDetails.appendChild(entrySummary);

                     const detailsDiv = document.createElement('div');
                     detailsDiv.className = 'history-details';

                     // Display Comments
                     const commentsTitle = document.createElement('h4');
                     commentsTitle.textContent = t.historyCommentsTitle;
                     detailsDiv.appendChild(commentsTitle);
                     if (record.comments && record.comments.length > 0) {
                         record.comments.forEach(comment => {
                             const commentP = document.createElement('p');
                             commentP.className = 'comment-entry';
                             const commentDate = new Date(comment.timestamp).toLocaleTimeString(currentLanguage, { timeStyle: 'short' });
                             let optionsText = comment.options && comment.options.length > 0 ? ` [${comment.options.join(', ')}]` : '';
                             const moveLabel = t.historyMoveLabel;
                             // Display comment text and options
                             commentP.innerHTML = `<strong>${moveLabel} ${comment.move || '?'} (${comment.moveCode || 'N/A'}):</strong> ${comment.text || ''}<span class="comment-options">${optionsText}</span> <small>(${commentDate})</small>`;
                             detailsDiv.appendChild(commentP);
                         });
                     } else {
                         const noCommentP = document.createElement('p');
                         noCommentP.textContent = t.historyNoComments;
                         noCommentP.style.fontStyle = 'italic';
                         detailsDiv.appendChild(noCommentP);
                     }

                     // Display Errors
                     const errorsTitle = document.createElement('h4');
                     errorsTitle.textContent = t.historyErrorsTitle;
                     errorsTitle.style.marginTop = '15px';
                     detailsDiv.appendChild(errorsTitle);
                     if (record.errors && record.errors.length > 0) {
                         record.errors.forEach(error => {
                             const errorP = document.createElement('p');
                             errorP.className = 'error-entry';
                             const errorDate = new Date(error.timestamp).toLocaleTimeString(currentLanguage, { timeStyle: 'short' });
                              const moveLabel = t.historyMoveLabel;
                              // Ensure moveIndex exists and is a number before using it
                              const errorMoveNumber = (typeof error.moveIndex === 'number' && error.moveIndex >= 0) ? error.moveIndex + 1 : '?';
                              // Format error display using translation function
                              errorP.innerHTML = `<strong>${moveLabel} ${errorMoveNumber}:</strong> ${t.historyBetErrorLabel(error.bet, error.correctMove, error.potChange, errorDate)}`;
                             detailsDiv.appendChild(errorP);
                         });
                     } else {
                         const noErrorP = document.createElement('p');
                         noErrorP.textContent = t.historyNoErrors;
                         noErrorP.style.fontStyle = 'italic';
                         detailsDiv.appendChild(noErrorP);
                     }

                     entryDetails.appendChild(detailsDiv);
                     historyContent.appendChild(entryDetails);
                 });
             }

             historyModal.style.display = 'block'; // Show the modal
        }
        function copyHistoryContent() {
             // --- Identique au nouveau code ---
             const t = translations[currentLanguage] || translations.en;
             try {
                 // Construct the prompt dynamically with the current language
                 const dynamicPrompt = `You are an Awale expert and strategic coach specialized in analyzing champion games. Here is the history of games played by a user trying to guess the champion's move. Analyze their performance, common mistakes (errors array shows their incorrect bet vs the correct move), strengths, and comments. Provide constructive feedback and coaching tips to help them improve their ability to think like the champion.
 IMPORTANT: Please formulate your response exclusively in the following language: ${currentLanguage}.`; // Dynamic language insertion

                 const dataToCopy = {
                     prompt: dynamicPrompt, // Use dynamic prompt
                     language_preference: currentLanguage, // Explicitly add preferred language
                     games: [...gameRecords] // Ensure a copy is used
                 };

                 const historyJson = JSON.stringify(dataToCopy, null, 2); // Pretty print JSON
                 navigator.clipboard.writeText(historyJson).then(() => {
                     alert(t.copySuccess); // Use alert for simple feedback
                 }).catch(err => {
                     console.error('Clipboard write error:', err);
                     alert(t.copyError);
                 });
             } catch (e) {
                 console.error("Error preparing history for copying:", e);
                 alert(t.copyPrepareError);
             }
        }
        function resetHistory() {
             // --- Identique au nouveau code ---
             const t = translations[currentLanguage] || translations.en;
             if (confirm(t.confirmResetHistory)) {
                 gameRecords = []; // Clear the in-memory array
                 localStorage.removeItem('awaleGameRecords'); // Remove from storage
                 const historyContent = document.getElementById('history-content');
                 if (historyContent) historyContent.textContent = t.noHistory; // Update display
                 closeModal('history-modal'); // Close the modal
                 alert(t.historyResetSuccess); // Notify user
             }
        }
        function rainConfetti() {
            // --- Identique au nouveau code ---
            const container = document.body; // Append confetti to body
            for (let i = 0; i < 150; i++) { // Create 150 confetti pieces
                 let c=document.createElement('div');
                 c.className='confetti';
                 const s=Math.random()*8+4; // Random size (4px to 12px)
                 c.style.width=s+'px';
                 c.style.height=s+'px';
                 c.style.left=Math.random()*100+'vw'; // Random horizontal start position
                 c.style.top='-10px'; // Start just above the viewport
                 c.style.backgroundColor=`hsl(${Math.random()*360},100%,70%)`; // Random bright color
                 c.style.animationDuration=(Math.random()*3+2)+'s'; // Random duration (2s to 5s)
                 c.style.animationDelay=Math.random()*1+'s'; // Random start delay (0s to 1s)
                 c.style.transform=`rotate(${Math.random()*360}deg)`; // Initial random rotation
                 container.appendChild(c);
                 // Remove confetti element after animation ends to prevent DOM clutter
                 c.addEventListener('animationend',()=>{if(c.parentNode)c.parentNode.removeChild(c);});
            }
        }


        // --- Fonctions Secrets et Listeners (Identiques) ---
        function addTripleClickListener(element, callback) {
             let c = 0, l = 0;
             element?.addEventListener('click', (e) => {
                 const t = Date.now();
                 if (t - l < 500) c++; else c = 1; // Reset count if clicks are too far apart
                 l = t;
                 if (c === 3) { callback(element); c = 0; } // Trigger callback on 3rd click
             });
         }
        function handleTripleClick(element) {
            const t = translations[currentLanguage] || translations.en;
            if (!element) return;
            if (element.classList.contains('logo')) { // Check by class for logo
                restartGame();
                showTemporaryMessage(t.resetMessage);
            } else if (element.id === 'bet-pot-info') { // Check by ID for pot info
                 isSuccessGuaranteed = !isSuccessGuaranteed;
                 showTemporaryMessage(isSuccessGuaranteed ? t.successOnMessage : t.successOffMessage);
            } else if (element.id === 'bet-label') { // Check by ID for bet label
                 const select = document.getElementById('bet-amount');
                 if(select){
                     isBetLocked = !isBetLocked;
                     if (isBetLocked) {
                         lockedBetPercentage = select.value;
                         showTemporaryMessage(t.betLockedMessage(lockedBetPercentage));
                         select.disabled = true;
                     } else {
                         lockedBetPercentage = null;
                         showTemporaryMessage(t.betUnlockedMessage);
                         select.disabled = false;
                         select.value = "75"; // Reset to default when unlocked
                     }
                 }
             }
            // Note: Triple click on title is removed as hiddenLevelsUnlocked is replaced by isPremium
         }
        function addLongPressListener(element, duration, callback) {
             let p = null; // Timer variable
             const s = (e) => { // Start timer function
                 if (e.button === 2) return; // Ignore right-click
                 clearTimeout(p); // Clear any existing timer
                 p = setTimeout(() => { if(callback) callback(); p = null; }, duration); // Start new timer
             };
             const c = () => { clearTimeout(p); p = null; }; // Clear timer function
             const o = { passive: true }; // Optimize for touch events
             // Add listeners for various events
             element?.addEventListener('touchstart', s, o);
             element?.addEventListener('touchend', c);
             element?.addEventListener('touchcancel', c);
             element?.addEventListener('mousedown', s);
             element?.addEventListener('mouseup', c);
             element?.addEventListener('mouseleave', c); // Clear timer if mouse leaves element
         }
        function activatePremium() {
             if (!isPremium) {
                 isPremium = true;
                 localStorage.setItem('isPremiumVersion', 'true'); // Save premium status
                 const t = translations[currentLanguage] || translations.en;
                 showTemporaryMessage(t.premiumUnlockedMessage);
                 updateLanguage(); // Update UI to reflect premium features (e.g., help text, game list)
             }
         }
        function handleLongPressSecret(index) {
            // index 0 is 'a', index 5 is 'f' in opponent row
            const t = translations[currentLanguage] || translations.en;
            const secretMsgEl = document.getElementById('secret-message');

            if (index === 5) { // Hole 'f'
                 if(secretMsgEl) secretMsgEl.textContent = t.secretMessage; // Show Eric message
            } else if (index === 0) { // Hole 'a' - Undo last move
                 if (!isPremium) { showPremiumInfoModal(); return; } // Premium feature

                 // Check if there's a move to undo
                 if (currentMoveIndex >= 0 && moveHistory.length > 1) {
                      const moveBeingUndone = playedMoves.length > 0 ? playedMoves[playedMoves.length - 1] : null;
                      const wasPlayerBet = moveBeingUndone ? /[A-F]/.test(moveBeingUndone) : false;

                      // Remove the last state from history
                      moveHistory.pop();
                      // Get the previous state
                      const previousState = moveHistory[moveHistory.length - 1];

                      // Restore board and scores from the previous state
                      board = JSON.parse(JSON.stringify(previousState.board));
                      scores = JSON.parse(JSON.stringify(previousState.scores));

                      // Decrement move index and remove from played moves display
                      currentMoveIndex--;
                      if (playedMoves.length > 0) playedMoves.pop();

                      // Adjust betting stats if a player's bet is being undone
                      if (wasPlayerBet) {
                          totalPlayer1Bets = Math.max(0, totalPlayer1Bets - 1); // Decrement bet count

                          // Find if the undone move was an error
                          const errorIndex = errorLog.findIndex(err => err.moveIndex === currentMoveIndex + 1); // Index matches the move *before* undo

                          if (errorIndex === -1) { // Successful bet was undone
                              successfulBets = Math.max(0, successfulBets - 1); // Decrement successful count
                              // Attempt to restore pot - This is tricky without knowing the exact bet amount
                              // For simplicity, we might accept some pot drift here, or need a better history system
                              console.warn("Pot reversal on successful undo might be inaccurate without storing bet amount.");
                              // Simple approximation: add back an average bet? Or ignore pot change for simplicity.
                          } else { // Error was undone
                             // Restore pot based on the stored betAmount in the error log entry
                             const undoneError = errorLog[errorIndex];
                             if (undoneError && typeof undoneError.betAmount === 'number') {
                                 pot = Math.round(pot + undoneError.betAmount); // Add back the lost amount
                             } else {
                                 console.warn("Could not find bet amount to restore pot on error undo.");
                             }
                             // Remove the error from the log
                             errorLog.splice(errorIndex, 1);
                          }
                      }

                      // Clear result highlights and show undo message
                      lastIncorrectGuess = null;
                      lastCorrectMove = null;
                      showTemporaryMessage(t.backMessage);
                      renderBoard(); // Re-render the restored state
                 }
             }
         }
        function addLongPressListenerForSecrets(element, index) {
            // Add long press only to holes 'a' (index 0) and 'f' (index 5) of opponent row
             if (index === 5 || index === 0) {
                 addLongPressListener(element, 2000, () => handleLongPressSecret(index)); // 2-second press
             }
         }
        function showSecretTips() {
            // --- Identique au nouveau code ---
             if (!isPremium) { showPremiumInfoModal(); return; } // Premium feature
             const t = translations[currentLanguage] || translations.en;
             const secretModal = document.getElementById('secret-modal');
             const tipsTitle = document.getElementById('secret-tips-title');
             const tipsList = document.getElementById('secret-tips');
             const closeBtn = document.getElementById('secret-modal-close');

             if(secretModal && tipsTitle && tipsList && closeBtn) {
                 tipsTitle.textContent = t.secretTipsTitle; // Set title in current language
                 tipsList.innerHTML = (t.secretTips || []).map(tip => `<li>${tip}</li>`).join(''); // Populate list
                  closeBtn.textContent = t.closeButton; // Set button text
                 secretModal.style.display = 'block'; // Show the modal
             }
        }
        function setupCombinedSecretListener() {
            // --- Identique au nouveau code ---
             const boardElement = document.getElementById('board');
             if (!boardElement) return;

             let fPressed = false; // State for hole 'f'
             let aPressed = false; // State for hole 'a'
             let pressTimer = null; // Timer for the combined press
             let targetF = null; // Keep track of the specific 'f' element being pressed
             let targetA = null; // Keep track of the specific 'a' element being pressed

             const clearTimer = () => { if (pressTimer) clearTimeout(pressTimer); pressTimer = null; };

             const handlePress = (event, isStartingPress) => {
                 if (!isPremium) return; // Premium feature
                 const holeElement = event.target.closest('.hole.player2-hole'); // Find the opponent hole element
                 if (!holeElement) return; // Exit if click wasn't on an opponent hole

                 const holeCode = holeElement.dataset.code;

                 // Update press state for the specific hole
                 if (holeCode === 'f') {
                     fPressed = isStartingPress;
                     targetF = isStartingPress ? holeElement : null; // Track element on press start
                 } else if (holeCode === 'a') {
                     aPressed = isStartingPress;
                     targetA = isStartingPress ? holeElement : null; // Track element on press start
                 } else {
                     return; // Ignore other holes
                 }

                 // Check if both 'f' and 'a' are currently pressed
                 if (fPressed && aPressed) {
                     clearTimer(); // Clear any existing timer
                     pressTimer = setTimeout(() => {
                         // Only trigger if still pressed after 3 seconds
                         if(fPressed && aPressed) showSecretTips();
                     }, 3000); // 3-second duration
                 } else {
                     // If one is released, clear the timer
                     clearTimer();
                 }
             };

             // Add listeners for touch and mouse events
             // Touch events
             boardElement.addEventListener('touchstart', (e) => handlePress(e, true), {passive: true});
             boardElement.addEventListener('touchend', (e) => handlePress(e, false));
             boardElement.addEventListener('touchcancel', (e) => handlePress(e, false)); // Handle cancellation

             // Mouse events (ignore right-click)
             boardElement.addEventListener('mousedown', (e) => {if(e.button!==2) handlePress(e, true);});
             boardElement.addEventListener('mouseup', (e) => {if(e.button!==2) handlePress(e, false);});

             // Handle mouse leaving the specific pressed element
             boardElement.addEventListener('mouseleave', (e) => {
                 if (e.target === targetF) handlePress(e, false); // Release 'f' if mouse leaves it
                 if (e.target === targetA) handlePress(e, false); // Release 'a' if mouse leaves it
             }, true); // Use capture phase to catch event early
        }


        // --- Initialisation du Jeu (Identique) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing Application...");
            isPremium = localStorage.getItem('isPremiumVersion') === 'true';
            console.log("Premium Status:", isPremium);

            // Setup UI Listeners
            document.getElementById('theme-toggle')?.addEventListener('click', () => { document.body.classList.toggle('dark-mode'); renderBoard(); });
            document.getElementById('help-btn')?.addEventListener('click', () => {
                 const t = translations[currentLanguage] || translations.en;
                 const helpTextElement = document.getElementById("help-text");
                 if (helpTextElement) {
                     // Show correct help text based on premium status
                     const content = isPremium ? (t.helpTextPremium || t.helpTextStandard) : t.helpTextStandard;
                     helpTextElement.innerHTML = content;
                 }
                 const modal = document.getElementById('help-modal');
                 if(modal) modal.style.display = 'block';
            });
            // Long press on title was for unlocking levels, now use logo/other method
             addLongPressListener(document.getElementById('title'), 10000, activatePremium); // Keep premium activation via title long press?

            const crossBtn = document.getElementById('cross-toggle-btn');
            if (crossBtn) {
                crossBtn.addEventListener('click', toggleCrossVisibility); // Single click for cross
                addLongPressListener(crossBtn, 3000, toggleAides); // Long press for aids
            }

             // Setup triple-click listeners for secrets
            document.querySelectorAll('.logo, #bet-pot-info, #bet-label').forEach(element => {
                if(element) addTripleClickListener(element, handleTripleClick);
            });

            // Setup combined long press for secret tips list
            setupCombinedSecretListener();

            // Language and Level selector listeners
            const langSelect = document.getElementById("language-select");
            if(langSelect) langSelect.addEventListener('change', updateLanguage);
            const levelSelect = document.getElementById("level-select");
            if(levelSelect) levelSelect.addEventListener('change', changeLevel);

            // Load saved data
            loadGameRecords();

            // Initialize game state
            board = initialBoard();
            scores = initialScores();
            currentGameIndex = 0; // Start with the first game
            currentGame = games[currentGameIndex] ? games[currentGameIndex].split('') : [];
            moveHistory = [{ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: null }]; // Start history
            console.log("Initial board state set.");

            // Set initial language and render
            currentLanguage = langSelect ? (langSelect.value || "fr") : "fr";
            updateLanguage(); // This populates dropdowns and renders the board

            console.log("Initialization complete. Current Language:", currentLanguage);
        });
    </script>
</body>
</html>
