<!DOCTYPE html>
<!-- lang attribute will be set dynamically by JS -->
<html lang="fr">
<head>
	<link rel="manifest" href="/manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be set dynamically by JS -->
    <title>Dans la T√™te d'un Champion</title>
    <style>
        /* Styles CSS */
        html, body { height: 100%; margin: 0; padding: 0; box-sizing: border-box; }
        body { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; min-height: 100vh; padding: 10px 0; transition: background-color 0.3s, color 0.3s; font-family: sans-serif; overflow-x: hidden; }
        *, *:before, *:after { box-sizing: inherit; }
        .dark-mode { background-color: #333; color: #fff; }
        .dark-mode .hole { color: #fff; }
        .dark-mode #bet-pot-info, .dark-mode #success-rate { background-color: #555; border-color: #777; color: #fff; }
        .dark-mode #title, .dark-mode #move-info, .dark-mode #played-moves, .dark-mode #result, .dark-mode #turn-indicator { color: #fff; }
        .dark-mode #help-modal, .dark-mode #secret-modal, .dark-mode #comment-modal, .dark-mode #history-modal, .dark-mode #premium-info-modal { background: #444; color: #fff; }
        .dark-mode .history-entry summary { background-color: #555; }
        .dark-mode .history-entry { border-color: #777; }
        .dark-mode .hole.player1-hole { background-color: #a0522d; color: white; }
        .dark-mode .hole.player2-hole { background-color: #5c4033; color: white; }
        .dark-mode .selected-bet { animation: blink-dark 0.6s infinite; }
        .dark-mode #turn-indicator.player-turn { color: #90ee90; background-color: #385038; }
        .dark-mode #turn-indicator.opponent-turn { color: #ffa0a0; background-color: #5a3030; }
        .dark-mode .comment-entry::before, .dark-mode .error-entry::before { color: #bbb; }
        .dark-mode .comment-options { color: #ddd; }
        .dark-mode .error-detail { color: #ff6b6b;}
        .dark-mode #theme-toggle { background: url('https://img.icons8.com/ios-filled/24/ffffff/light-off.png') no-repeat center; background-size: 60%; }
        .dark-mode .highlight-capture-enabled { animation: blink-orange-dark 0.6s infinite; }
        .dark-mode .highlight-pressure-enabled { border: 3px dashed #ff8c00 !important; box-shadow: 0 0 8px #ff8c00; }
        .dark-mode #cross-toggle-btn { background: #555; border-color: #777; color: #ff6b6b; }
        /* --- MODIFICATION COULEUR --- */
        .dark-mode .highlight-start {
             background-color: rgba(210, 180, 222, 0.5) !important; /* Plus transparent en dark mode ? */
             /* color: black !important; */ /* D√©commenter si texte blanc illisible */
        }
        /* --- FIN MODIFICATION --- */
        #game-area { width: 90vw; max-width: 700px; padding: 1vh 5px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; gap: 1vh; margin-top: 10px; }
        #title { color: #333; text-align: center; font-size: clamp(1.4em, 5vw, 1.8em); margin: 0 0 0.5vh 0; user-select: none; cursor: help; }
        #turn-indicator { font-weight: bold; margin-bottom: 8px; text-align: center; padding: 5px; border-radius: 4px; min-height: 1.2em; width: 90%; max-width: 300px; }
        #turn-indicator.player-turn { color: #006400; background-color: #e8f5e9; }
        #turn-indicator.opponent-turn { color: #b71c1c; background-color: #ffebee; }
        .button-yellow, .button-next, .button-small, .button-save, .button-copy, .button-reset, .button-close { padding: 10px 18px; font-size: clamp(0.9em, 2.5vw, 1em); border-radius: 5px; cursor: pointer; transition: transform 0.2s, background-color 0.2s; border: none; font-weight: bold; margin: 5px 4px; white-space: nowrap; }
        .button-yellow:active, .button-next:active { transform: scale(0.95); }
        .button-yellow { background-color: #ffc107; color: #000; border: 2px solid #e0a800; }
        .button-yellow:hover { background-color: #e0a800; }
        .button-next { background-color: #28a745; color: white; border: 2px solid #218838; }
        .button-next:hover { background-color: #218838; }
        .button-small { background-color: #17a2b8; color: white; border: 2px solid #138496; padding: 8px 12px; font-size: clamp(0.8em, 2.2vw, 0.9em); }
        .button-small:hover { background-color: #138496; }
        .button-small.history { background-color: #6f42c1; border: 2px solid #5a32a3; }
        .button-small.history:hover { background-color: #5a32a3; }
        .button-save { background-color: #28a745; color: white; border: 2px solid #218838; }
        .button-save:hover { background-color: #218838; }
        .button-copy { background-color: #007bff; color: white; border: 2px solid #0056b3; }
        .button-copy:hover { background-color: #0056b3; }
        .button-reset { background-color: #dc3545; color: white; border: 2px solid #c82333; }
        .button-reset:hover { background-color: #c82333; }
        .button-close { background-color: #6c757d; color: white; border: 2px solid #5a6268; }
        .button-close:hover { background-color: #5a6268; }
        .logo-container { display: flex; align-items: center; justify-content: center; gap: 10px; margin: 1vh auto; flex-direction: column; }
        .logo-row { display: flex; align-items: center; gap: clamp(10px, 3vw, 20px); }
        .logo { width: clamp(100px, 25vw, 150px); height: auto; }
        #theme-toggle, #help-btn { width: clamp(30px, 8vw, 40px); height: clamp(30px, 8vw, 40px); border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; background-color: #eee; }
        #theme-toggle { background: url('https://img.icons8.com/ios-filled/24/000000/light-on.png') no-repeat center; background-size: 60%;}
        #help-btn { background-color: #007bff; color: white; font-size: clamp(1em, 4vw, 1.4em); font-weight: bold; }
        #cross-toggle-btn { color: red; font-weight: bold; font-size: clamp(1.8em, 7vw, 2.4em); line-height: 1; padding: 0 5px 4px 5px; background: #eee; border: 1px solid #ccc; border-radius: 50%; width: clamp(30px, 8vw, 40px); height: clamp(30px, 8vw, 40px); cursor: pointer; display: flex; align-items: center; justify-content: center; user-select: none; }
        .selector-container { display: flex; justify-content: center; gap: clamp(10px, 4vw, 25px); margin: 1.5vh 0; flex-wrap: wrap; }
        .selector-container > div { display: flex; align-items: center; gap: 5px;}
        .selector-container label, .selector-container select { font-size: clamp(0.85em, 2.8vw, 1em); }
        #board { position: relative; width: 100%; display: flex; flex-direction: column; align-items: center; margin: 1vh 0; padding: 5px 0; box-sizing: border-box; border: 1px solid #eee; background-color: #f9f9f9; border-radius: 8px; }
        .dark-mode #board { border: 1px solid #555; background-color: #404040; }
        .board-row { display: flex; justify-content: center; width: 100%; padding: 0 5px; box-sizing: border-box; }
        .board-label { flex: 0 0 auto; width: 13vw; max-width: 70px; height: auto; margin: 0.5vw; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: clamp(0.8em, 3vw, 1.3em); text-align: center; color: #666; user-select: none; }
        .dark-mode .board-label { color: #ccc; }
        .hole { flex: 0 0 auto; width: 13vw; height: 13vw; max-width: 70px; max-height: 70px; color: black; display: flex; align-items: center; justify-content: center; border-radius: 50%; margin: 0.5vw; font-weight: bold; font-size: clamp(1em, 4vw, 1.8em); transition: background-color 0.3s, box-shadow 0.3s, border 0.2s, color 0.3s; box-sizing: border-box; border: 2px solid transparent; position: relative; overflow: hidden; cursor: default; user-select: none; }
        .hole.player1-hole { background-color: #d2b48c; color: #333; }
        .hole.player2-hole { background-color: #8b4513; color: white; }
        .hole.player1-hole.clickable { cursor: pointer; }
        .hole.disabled { cursor: not-allowed !important; opacity: 0.7; }
        .highlight-incorrect { border: 3px solid red !important; box-shadow: 0 0 10px red; }
        .highlight-correct { border: 3px solid limegreen !important; box-shadow: 0 0 10px limegreen; }
        /* --- MODIFICATION COULEUR --- */
        .highlight-start {
            /* Violet clair (genre lavande) avec 70% d'opacit√© */
            background-color: rgba(210, 180, 222, 0.7) !important;
             /* color: black !important; */ /* D√©commenter si le texte par d√©faut est illisible */
        }
        /* --- FIN MODIFICATION --- */
        .highlight-end { background-color: rgba(0, 200, 255, 0.7) !important; }
        .selected-bet { animation: blink 0.6s infinite; }
        @keyframes blink { 0%, 100% { background-color: #4682b4; border-color: #1e90ff; box-shadow: 0 0 8px #1e90ff; } 50% { background-color: #add8e6; border-color: #4682b4; box-shadow: 0 0 12px #4682b4; } }
        @keyframes blink-dark { 0%, 100% { background-color: #1e90ff; border-color: #4682b4; box-shadow: 0 0 8px #4682b4; } 50% { background-color: #4682b4; border-color: #1e90ff; box-shadow: 0 0 12px #1e90ff;} }
        .highlight-capture-enabled { animation: blink-orange 0.6s infinite; }
        @keyframes blink-orange { 0%, 100% { background-color: #ffcc80; border: 2px solid orange; box-shadow: 0 0 6px orange; } 50% { background-color: #ffa726; border: 2px solid darkorange; box-shadow: 0 0 10px darkorange; } }
        @keyframes blink-orange-dark { 0%, 100% { background-color: #e69500; border: 2px solid #ff8c00; box-shadow: 0 0 6px #ff8c00; } 50% { background-color: #ffae42; border: 2px solid #ffa500; box-shadow: 0 0 10px #ffa500; } }
        .highlight-pressure-enabled { border: 3px dashed orange !important; box-shadow: 0 0 8px orange; }
        .dark-mode .highlight-pressure-enabled { border: 3px dashed #ff8c00 !important; box-shadow: 0 0 8px #ff8c00; }
        #red-cross { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; justify-content: center; align-items: center; overflow: hidden; }
        .cross-line { position: absolute; background-color: transparent; opacity: 0.7; }
        .cross-line.horizontal { width: 96%; height: 2px; top: 50%; left: 2%; transform: translateY(-50%); border-top: 2px dashed red; }
        .cross-line.vertical { width: 2px; height: 90%; left: 50%; top: 5%; transform: translateX(-50%); border-left: 2px dashed red; }
        #move-info { text-align: center; margin-bottom: 5px; font-size: clamp(0.9em, 3vw, 1.1em);}
        .pot-container { display: flex; align-items: center; justify-content: center; gap: clamp(8px, 3vw, 15px); margin: 1vh 0; }
        #bet-pot-info, #success-rate { background-color: #fff3cd; border: 1px solid #e0a800; padding: 6px 12px; border-radius: 5px; display: inline-block; text-align: center; font-size: clamp(0.85em, 2.8vw, 1em);}
        #played-moves { text-align: center; margin-top: 5px; font-size: clamp(0.8em, 2.5vw, 0.9em); color: #555; width: 90%; word-wrap: break-word;}
        .dark-mode #played-moves { color: #ccc; }
        #result { text-align: center; font-weight: bold; min-height: 1.2em; margin: 8px 0; font-size: clamp(0.95em, 3.2vw, 1.1em); }
        .betting-area { margin-top: 1.5vh; display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        .bet-selection { display: flex; align-items: center; justify-content: center; gap: 5px; flex-wrap: wrap; margin-bottom: 10px; }
        .bet-selection label, .bet-selection select, .bet-selection span { font-size: clamp(0.9em, 2.8vw, 1em); }
        .bet-buttons { display: flex; justify-content: center; align-items: center; gap: clamp(5px, 2vw, 10px); flex-wrap: wrap; }
        #help-modal, #secret-modal, #comment-modal, #history-modal, #premium-info-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1000; max-width: 90%; width: 500px; max-height: 85vh; overflow-y: auto; }
        #help-modal button, #secret-modal button, #comment-modal button, #history-modal button:not(.history-buttons button), #premium-info-modal button { margin-top: 15px; }
        #comment-modal { height: auto; min-height: 380px; }
        .comment-section { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        #comment-input { width: calc(100% - 10px); height: 100px; resize: vertical; padding: 5px; margin-bottom: 5px; border: 1px solid #ccc;}
        .checkbox-section { margin-top: 5px; }
        .checkbox-section label { display: flex; align-items: center; margin-bottom: 6px; cursor: pointer;}
        .checkbox-section input[type="checkbox"] { margin-right: 8px;}
        #history-content { margin-bottom: 10px; font-family: monospace; }
        .history-buttons { display: flex; justify-content: space-between; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .history-entry { border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; background-color: #f9f9f9; }
        .history-entry summary { padding: 10px; font-weight: bold; cursor: pointer; background-color: #eee; border-radius: 5px 5px 0 0; outline: none; display: flex; justify-content: space-between; align-items: center;}
        .history-entry summary::before { content: '‚ñ∂ '; display: inline-block; margin-right: 5px; transition: transform 0.2s; order: -1;}
        .history-entry summary::-webkit-details-marker { display: none; }
        .history-entry[open] summary::before { transform: rotate(90deg); }
        .history-details { padding: 10px; border-top: 1px solid #ddd; }
        .history-details h4 { margin-top: 0; margin-bottom: 5px; font-size: 1em; }
        .comment-entry, .error-entry { margin-bottom: 8px; padding-left: 15px; position: relative; font-size: 0.9em; line-height: 1.4; word-break: break-word; }
        .comment-entry::before, .error-entry::before { content: '‚Ä¢'; position: absolute; left: 0; color: #555; }
        .comment-options { font-style: italic; color: #333; margin-left: 5px; }
        .error-detail { color: #c00; font-weight: bold;}
        .confetti { position: fixed; width: 8px; height: 8px; pointer-events: none; animation: fall 3s ease-out forwards; border-radius: 50%; transform: rotate(0deg); z-index: 9999; }
        @keyframes fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        #premium-info-modal ul { list-style: disc; margin-left: 25px; margin-top: 10px;}
        #premium-info-modal li { margin-bottom: 8px; }
        #help-modal ul { list-style: disc; margin-left: 25px; margin-top: 10px;}
        #help-modal li { margin-bottom: 8px; }

        @media (max-width: 480px) { body { padding: 5px 0; } #game-area { width: 95vw; gap: 0.8vh;} .logo-row { gap: 10px; } .button-yellow, .button-next, .button-small { padding: 8px 10px; font-size: 0.9em; margin: 3px; } .bet-buttons { gap: 5px; } .history-buttons { justify-content: center; } .pot-container { gap: 8px; } #bet-pot-info, #success-rate { padding: 5px 8px; } #help-modal, #secret-modal, #comment-modal, #history-modal, #premium-info-modal { width: 95%; max-height: 80vh; } .hole, .board-label { width: 14vw; max-width: 60px; height: 14vw; max-height: 60px; margin: 0.4vw; font-size: clamp(0.9em, 3.5vw, 1.6em); } }
    </style>
</head>
<body>
    <!-- Structure HTML (inchang√©e) -->
    <div class="logo-container">
        <div id="secret-message"></div>
        <div class="logo-row">
            <img src="logo.jpg" alt="Logo" class="logo" onerror="this.style.display='none'">
            <button id="theme-toggle"></button>
            <button id="help-btn">i</button>
            <button id="cross-toggle-btn">+</button>
        </div>
    </div>
    <div class="selector-container">
        <div>
            <label for="language-select" id="language-label"></label>
            <select id="language-select" onchange="updateLanguage()">
                <option value="fr">Fran√ßais</option>
                <option value="en">English</option>
                <option value="es">Espa√±ol</option>
                <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                <option value="zh">‰∏≠Êñá</option>
            </select>
        </div>
        <div>
            <label for="level-select" id="level-label"></label>
            <select id="level-select" onchange="changeLevel()"></select>
        </div>
    </div>
    <div id="game-area">
        <h1 id="title"></h1>
        <div id="turn-indicator"></div>
        <div id="board">
            <div class="board-row"> <div class="board-label">f</div><div class="board-label">e</div><div class="board-label">d</div><div class="board-label">c</div><div class="board-label">b</div><div class="board-label">a</div> </div>
            <div id="player2-row" class="board-row"></div>
            <div id="player1-row" class="board-row"></div>
            <div class="board-row"> <div class="board-label">A</div><div class="board-label">B</div><div class="board-label">C</div><div class="board-label">D</div><div class="board-label">E</div><div class="board-label">F</div> </div>
            <div id="red-cross"> <div class="cross-line horizontal"></div> <div class="cross-line vertical"></div> </div>
        </div>
        <div id="move-info"></div>
        <div class="pot-container">
            <div id="bet-pot-info"></div>
            <div id="success-rate"></div>
        </div>
        <div id="played-moves"></div>
        <div id="result"></div>
        <div class="betting-area">
            <div class="bet-selection">
                <label id="bet-label" for="bet-amount"></label>
                <select id="bet-amount">
                    <option value="25">25 %</option>
                    <option value="50">50 %</option>
                    <option value="75">75 %</option>
                    <option value="100">100 %</option>
                </select>
                <span>‚Ç¨</span>
                <label id="bet-case-label" for="bet-input"></label>
                <select id="bet-input">
                    <option value="A">A</option><option value="B">B</option><option value="C">C</option>
                    <option value="D">D</option><option value="E">E</option><option value="F">F</option>
                </select>
            </div>
            <div class="bet-buttons">
                <button id="bet-and-verify-btn" class="button-yellow" onclick="betAndVerify()"></button>
                <button id="next-btn" class="button-next" onclick="moveNext()"></button>
                <button id="record-btn" class="button-small" onclick="openCommentModal()" style="display: none;"></button>
                <button id="history-btn" class="button-small history" onclick="openHistoryModal()" style="display: none;"></button>
            </div>
        </div>
    </div>

    <!-- Modals (structure inchang√©e) -->
    <div id="help-modal">
        <h2 id="help-title"></h2>
        <div id="help-text"></div>
        <button onclick="closeModal('help-modal')" class="button-close" id="help-modal-close"></button>
    </div>
    <div id="secret-modal">
        <h2 id="secret-tips-title"></h2>
        <ul id="secret-tips"></ul>
        <button onclick="closeModal('secret-modal')" class="button-close" id="secret-modal-close"></button>
    </div>
    <div id="comment-modal">
        <h3 id="comment-title"></h3>
        <div class="comment-section">
            <textarea id="comment-input" placeholder=""></textarea>
             <div class="checkbox-section">
                <label><input type="checkbox" name="comment-option" value="GoodMove"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="BadMove"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="Risky"> <span class="checkbox-label-text"></span></label>
                <label><input type="checkbox" name="comment-option" value="Safe"> <span class="checkbox-label-text"></span></label>
            </div>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="button-save" onclick="saveComment()" id="comment-save-btn"></button>
            <button class="button-close" onclick="closeModal('comment-modal')" id="comment-cancel-btn"></button>
        </div>
    </div>
    <div id="history-modal">
        <h3 id="history-title"></h3>
        <div id="history-content"></div>
        <div class="history-buttons">
            <button class="button-copy" onclick="copyHistoryContent()" id="history-copy-btn"></button>
            <button class="button-reset" onclick="resetHistory()" id="history-reset-btn"></button>
            <button class="button-close" onclick="closeModal('history-modal')" id="history-close-btn"></button>
        </div>
    </div>
    <div id="premium-info-modal">
        <h2 id="premium-modal-title"></h2>
        <p id="premium-modal-text"></p>
        <p><strong id="premium-modal-benefits-title"></strong></p>
        <ul>
            <li id="premium-benefit-levels"></li>
            <li id="premium-benefit-history"></li>
            <li id="premium-benefit-record"></li>
            <li id="premium-benefit-aids"></li>
            <li id="premium-benefit-cross"></li>
            <li id="premium-benefit-secrets"></li>
        </ul>
        <p id="premium-modal-howto"></p>
        <p style="text-align: center; margin-top:15px;">
            <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer" class="button-yellow" style="text-decoration: none;" id="premium-modal-action-link"></a>
        </p>
        <button onclick="closeModal('premium-info-modal')" class="button-close" id="premium-modal-close"></button>
    </div>

    <script>
        // --- Global Variables (inchang√©es) ---
        let isPremium = false;
        let areAidesEnabled = false;
        let isCrossVisible = false;
        const initialBoard = () => ({ player1: [4, 4, 4, 4, 4, 4], player2: [4, 4, 4, 4, 4, 4] });
        const initialScores = () => ({ player1: 0, player2: 0 });
        let board = {};
        let scores = {};
        const games = [ "FfCdAbBaDbCdDcBdAaBbDcCdDeEeDdCfEeFdBeFaD", "FfBaCfAbAfBdCfBcAfCeBfDfCeBdCeEfDbEcAdCaEbF", "FfBaCaAaCfBbAcCaBbCcAfAdAfCaBeDfEeBfAaEbCaEbF", "FfCcBbAaFaDaAcBdDbCfDaCdBcDbCcAeFdBeCfFaCbDaFbE", "FfBdBfDdAbAdDaBdDbAfAeAbDaBbDcEeDdBfAeCfEaDbEcBdF", "FfCcBbAcBbFaCfCeCcBbDfAcDdCfEfBeAfDbEcCdEeAaDbEcBdCeDfEaAbF", "FfBcEeBcDcCcEbAeDbCcBaEfDeEdEcDbCaEdDcEbFfEdFfAaBbCeAcCdDeBf", "FfCcBbAfFdAaEaFaCaEbBeEcCdAfEeCbDdAfAeAfEaCbBbEaDcAdCbEcDdEeAfFfCdBeAfDaE", "FfBaCbBdFbDbFdCfCcFdDfFaCdDcBdDbEfFbAaEdFaCaDfFaAcAeEaAdDbEeCdCcBdAfAeDbCdAdCbEcDdEeAfFfCdBeAfDaE", "FfCbDeDcCbAfAeFfAcDbEfFeCcDaAcEdCcEdDaEbBdDbCcAdBeBcEcDfDdCeAcDdBbEbFfEeBfCaFaAeCbBcCdEeAfD", "FfCbDbFbBeAfCcAaDaCeDbBdBcDaEeDfEaCaBbAcCdBeEfDaAbBcEdCeDfEaFfEeDdCcBeDdCeDfFaEaBbCcDdAeBfEaF", "FfCaFdBcFdDaFaBdAfFeFfDcCdDeBbBaDcAfAdAeCbAfDcAdBeCfFbAcDdEeBfFbDaCcDdEeAaFaBbDcEdCeDfFaBbCcAdBeCf", "FfBaCbBeDbCfCeDaBcCfDeEfAcDaBeEfCdAaEcDbAfAeAdBcCeEdDeFfEaDbCdBeAcCdBeCfFbEaDcBeAdCaFaEeBbDcCdDeEaF", "FfBcFbBdAeBbCcAdDbCeDdCeDaFaBaEeBfFbEdBfFeDfEbFaAfAaCeAfEbDcEeFaDbCeEdCcDfDeCdDeEfFaBaDbCcAdBeDfFaEaAbBcCdDeEaFfAaBbCcDdEeFf" ];
        let currentGame = [];
        let currentMoveIndex = -1;
        let moveHistory = [];
        let currentBet = null;
        let playedMoves = [];
        let betAmount = 0;
        let pot = 100;
        let currentLanguage = "fr";
        let successfulBets = 0;
        let totalPlayer1Bets = 0;
        let isBetLocked = false;
        let lockedBetPercentage = null;
        let isSuccessGuaranteed = false;
        let perfectGamesCount = 0;
        let currentGameIndex = 0;
        let gameStartTime = null;
        let errorLog = [];
        let lastIncorrectGuess = null;
        let lastCorrectMove = null;
        let highlightStartHole = null;
        let highlightEndHole = null;
        let animationTimeout = null;
        let gameRecords = [];
        let currentGameRecord = {};
        const holeMap = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5 };
        const opponentHoleCodes = ['a', 'b', 'c', 'd', 'e', 'f'];
        const playerHoleCodes = ['A', 'B', 'C', 'D', 'E', 'F'];
        let isGameOver = { confettiShown: false };


        // --- Translations Object (avec textes d'aide mis √† jour) ---
        const translations = {
             fr: {
                 pageTitle: "Dans la T√™te d'un Champion",
                 languageLabel: "Langue :",
                 levelLabel: "Partie :",
                 title: "Dans la T√™te d'un Champion !",
                 moveInfo: (p1, p2) => `Joueur üòä ‚Üì: ${p1} | Joueur üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `Cagnotte:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `R√©ussite:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | Derniers jeux: ${moves}`,
                 betLabel: "Je mise",
                 betCaseLabel: "sur",
                 betButton: "Je parie !",
                 nextButton: "Suivant",
                 recordButtonShort: "Enr",
                 historyButtonShort: "Histo",
                 closeButton: "Fermer",
                 saveButton: "Sauver",
                 cancelButton: "Annuler",
                 copyButton: "Copier (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Votre argent virtuel actuel",
                 tooltipSuccessRate: "Pourcentage de paris corrects sur cette partie",
                 tooltipRecord: "Enregistrer un commentaire pour ce coup (Premium)",
                 tooltipHistory: "Voir l'historique des parties jou√©es (Premium)",
                 tooltipHelp: "Afficher l'aide / R√®gles",
                 tooltipTheme: "Mode Sombre/Clair",
                 tooltipCross: "Options Premium (Croix / Aides)",
                 resultInvalidBet: "Mise invalide !",
                 resultWin: "Gagn√© !",
                 resultLose: "Perdu !",
                 resultGameOver: "Partie termin√©e !",
                 resetMessage: "Jeu r√©initialis√© !",
                 premiumUnlockedMessage: "Version Premium activ√©e ! Fonctionnalit√©s d√©bloqu√©es.",
                 successOnMessage: "Succ√®s garanti ACTIV√â",
                 successOffMessage: "Succ√®s garanti D√âSACTIV√â",
                 betLockedMessage: (pct) => `Mise verrouill√©e (${pct}%)`,
                 betUnlockedMessage: "Mise d√©verrouill√©e",
                 backMessage: "Retour arri√®re effectu√©",
                 opponentTurnMessage: "Clic Suivant (tour adverse)",
                 playerTurnIndicator: "√Ä vous : S√©lectionnez & misez !",
                 opponentTurnIndicator: "Tour adverse (Clic Suivant)",
                 emptyHoleMessage: "Case vide !",
                 notYourTurnMessage: "Pas votre tour ! Cliquez sur 'Suivant'.",
                 invalidHoleMessage: "Case invalide ou vide !",
                 internalErrorMessage: "Erreur interne de simulation.",
                 aidesEnabled: "Aides visuelles activ√©es",
                 aidesDisabled: "Aides visuelles d√©sactiv√©es",
                 crossEnabled: "Croix rouge activ√©e",
                 crossDisabled: "Croix rouge d√©sactiv√©e",
                 errorDisplayMessage: "Erreur d'affichage. Rechargez.",
                 confirmResetHistory: "Voulez-vous vraiment r√©initialiser tout l'historique ? Cette action est irr√©versible.",
                 historyResetSuccess: "Historique r√©initialis√© !",
                 copySuccess: "Contenu de l'historique copi√© !",
                 copyError: "Erreur lors de la copie.",
                 copyPrepareError: "Erreur lors de la pr√©paration de la copie.",
                 noHistory: "Aucun historique de partie enregistr√©.",
                 helpTitle: "Aide & Objectif",
                 helpTextStandard: `<strong>Bienvenue dans l'entra√Ænement c√©r√©bral Awal√© !</strong><br><br>Votre objectif est de <strong>penser comme un champion</strong> en devinant le coup qu'il a jou√© dans une partie r√©elle √† chaque fois que c'est votre tour (Joueur üòä ‚Üì).<br><br><strong>Comment jouer :</strong><br>1. Choisissez une langue et l'une des 3 premi√®res parties disponibles.<br>2. Quand c'est votre tour (üòä ‚Üì), observez le plateau.<br>3. Cliquez sur une de vos cases (A-F) contenant des graines pour la s√©lectionner.<br>4. Choisissez le pourcentage de votre cagnotte virtuelle √† miser sur ce choix.<br>5. Cliquez sur 'Je parie !'. Si votre choix est correct, vous gagnez votre mise. Sinon, vous la perdez.<br>6. Quand c'est le tour de l'adversaire (üòî ‚Üë), cliquez sur 'Suivant'.<br><br><strong>Passez √† la Version Premium !</strong><br>Pour une exp√©rience compl√®te et soutenir notre association, adh√©rez √† <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. La version Premium d√©bloque les fonctionnalit√©s suivantes :<ul><li>L'acc√®s √† <strong>toutes les parties</strong> d'entra√Ænement.</li><li>Les boutons <strong>"Histo"</strong> (historique) et <strong>"Enr"</strong> (prise de notes).</li><li>L'activation des <strong>aides visuelles</strong> (indications de capture/pression).</li><li>L'activation de la <strong>croix rouge</strong> d'alignement.</li><li>L'acc√®s aux <strong>astuces secr√®tes</strong>.</li></ul>`,
                 helpTextPremium: `<strong>Bienvenue dans la version Premium !</strong><br><br>Vous avez acc√®s √† toutes les fonctionnalit√©s pour vous entra√Æner √† penser comme un champion.<br><br><strong>Fonctionnalit√©s Premium :</strong><br><ul><li><strong>Toutes les Parties :</strong> Acc√©dez √† l'ensemble des parties via le s√©lecteur.</li><li><strong>Historique ("Histo") :</strong> Consultez vos parties pr√©c√©dentes, statistiques et commentaires.</li><li>
                     <strong>Coaching par IA via Export JSON :</strong> Utilisez le bouton "Copier (JSON)" dans l'historique. Collez le texte copi√© dans une Intelligence Artificielle conversationnelle (comme ChatGPT, Gemini, Mistral, etc.). Le prompt inclus demandera √† l'IA d'analyser vos parties (erreurs, commentaires) et de vous donner des conseils de coaching personnalis√©s, directement dans la langue s√©lectionn√©e dans l'application !
                 </li><li><strong>Enregistrement ("Enr") :</strong> Ajoutez des notes strat√©giques √† chaque coup jou√©.</li><li><strong>Aides Visuelles :</strong><ul><li>Activation/D√©sactivation : Appui long (3s) sur le bouton <strong>+</strong> en haut √† droite.</li><li>Case adverse orange clignotante : Votre coup s√©lectionn√© capture directement.</li><li>Case adverse avec bordure orange : Pression pour capture future possible.</li><li>Votre case avec bordure orange pointill√©e : Menace de capture par l'adversaire.</li></ul></li><li><strong>Croix Rouge :</strong><ul><li>Activation/D√©sactivation : Clic simple sur le bouton <strong>+</strong> en haut √† droite.</li><li>Aide √† visualiser les alignements de cases.</li></ul></li></ul><strong>Astuces Secr√®tes Activables :</strong><br><ul><li><strong>Logo x3 clics :</strong> R√©initialise la partie en cours.</li><li><strong>Cagnotte x3 clics :</strong> Active/D√©sactive le mode "Succ√®s Garanti" (tous les paris r√©ussissent).</li><li><strong>Texte "Je mise" x3 clics :</strong> Verrouille/D√©verrouille le pourcentage de mise s√©lectionn√©.</li><li><strong>Case 'a' adverse (appui 2s) :</strong> Annule le dernier coup jou√© (retour arri√®re).</li><li><strong>Cases 'f' + 'a' adverses (appui 3s simultan√©) :</strong> Affiche la liste des astuces secr√®tes.</li></ul>`,
                 secretMessage: "Bonjour Eric",
                 secretTipsTitle: "Astuces Secr√®tes (Premium)",
                 secretTips: [ "Logo x3 clics : Reset partie", "Cagnotte x3 clics : Succ√®s garanti ON/OFF", "'Je mise' x3 clics : Verrouille/D√©verrouille mise (%)", "Case 'f' adverse (appui 2s) : Bonjour Eric", "Case 'a' adverse (appui 2s) : Retour arri√®re (annule dernier coup)", "Cases 'f' + 'a' adverses (appui 3s simultan√©) : Montre cette liste" ],
                 commentModalTitle: "Ajouter un Commentaire",
                 commentInputPlaceholder: "Votre note strat√©gique ici...",
                 commentCheckboxGood: "Bon coup potentiel",
                 commentCheckboxBad: "Mauvais coup potentiel",
                 commentCheckboxRisky: "Risqu√©",
                 commentCheckboxSafe: "S√©curis√©",
                 historyTitle: "Historique des Parties",
                 historyRecordTitle: (name, date) => `Partie: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `R√©ussite: ${rate}% | Pot final: ${pot}‚Ç¨ | Dur√©e: ${duration}s`,
                 historyCommentsTitle: "Commentaires Enregistr√©s",
                 historyErrorsTitle: "Erreurs de Pari",
                 historyNoComments: "Aucun commentaire enregistr√© pour cette partie.",
                 historyNoErrors: "Aucune erreur de pari enregistr√©e pour cette partie.",
                 historyInProgress: "(En cours)",
                 historyMoveLabel: "Coup",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Pari√© <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pot ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "Fonctionnalit√© Premium",
                 premiumModalText: "Cette fonctionnalit√©, ainsi que d'autres avantages, sont r√©serv√©s aux membres Premium.",
                 premiumModalBenefitsTitle: "Avantages Premium :",
                 premiumBenefitLevels: "Acc√®s √† toutes les parties d'entra√Ænement.",
                 premiumBenefitHistory: "Bouton 'Histo' pour voir et analyser vos parties pr√©c√©dentes.",
                 premiumBenefitRecord: "Bouton 'Enr' pour ajouter des commentaires strat√©giques.",
                 premiumBenefitAids: "Activation des aides visuelles (captures/pression).",
                 premiumBenefitCross: "Activation de la croix rouge d'alignement.",
                 premiumBenefitSecrets: "Acc√®s aux astuces secr√®tes.",
                 premiumModalHowto: "Pour d√©bloquer la version Premium et soutenir notre association, devenez membre de <strong>Jeux Nomades France</strong> :",
                 premiumModalActionLink: "Adh√©rer √† l'association",
                 gameDropdownFormat: (index, moves) => `Partie ${index} (${moves} coups)`,
                 encouragingMessages: [ "Bravo!", "Super!", "Excellent!", "Continue!", "Impressionnant!", "Magnifique!", "Dou√©!", "Formidable!", "Incroyable!", "G√©nial!", "Parfait!", "√âpoustouflant!", "√âtoile montante!", "Sensationnel!", "Triomphe!", "Ma√Ætre!", "L√©gendaire!", "G√©nie!", "Champion!", "Immortel!" ]
             },
             en: {
                 pageTitle: "In the Mind of a Champion",
                 languageLabel: "Language:",
                 levelLabel: "Game:",
                 title: "In the Mind of a Champion!",
                 moveInfo: (p1, p2) => `Player üòä ‚Üì: ${p1} | Player üòî ‚Üë: ${p2}`,
                 betPotInfo: (pot) => `Pot:<BR>${pot} ‚Ç¨`,
                 successRate: (rate) => `Success:<BR>${rate} %`,
                 playedMoves: (index, total, moves) => `${index} / ${total} | Last moves: ${moves}`,
                 betLabel: "I bet",
                 betCaseLabel: "on",
                 betButton: "Bet!",
                 nextButton: "Next",
                 recordButtonShort: "Rec",
                 historyButtonShort: "Hist",
                 closeButton: "Close",
                 saveButton: "Save",
                 cancelButton: "Cancel",
                 copyButton: "Copy (JSON)",
                 resetButton: "Reset",
                 tooltipPot: "Your current virtual money",
                 tooltipSuccessRate: "Percentage of correct bets in this game",
                 tooltipRecord: "Record a comment for this move (Premium)",
                 tooltipHistory: "View history of played games (Premium)",
                 tooltipHelp: "Show Help / Rules",
                 tooltipTheme: "Dark/Light Mode",
                 tooltipCross: "Premium Options (Cross / Aids)",
                 resultInvalidBet: "Invalid bet!",
                 resultWin: "Win!",
                 resultLose: "Lost!",
                 resultGameOver: "Game Over!",
                 resetMessage: "Game reset!",
                 premiumUnlockedMessage: "Premium Version activated! Features unlocked.",
                 successOnMessage: "Guaranteed Success ON",
                 successOffMessage: "Guaranteed Success OFF",
                 betLockedMessage: (pct) => `Bet locked (${pct}%)`,
                 betUnlockedMessage: "Bet unlocked",
                 backMessage: "Undo successful",
                 opponentTurnMessage: "Click Next (opponent's turn)",
                 playerTurnIndicator: "Your turn: Select & Bet!",
                 opponentTurnIndicator: "Opponent's turn (Click Next)",
                 emptyHoleMessage: "Empty hole!",
                 notYourTurnMessage: "Not your turn! Click 'Next'.",
                 invalidHoleMessage: "Invalid or empty hole!",
                 internalErrorMessage: "Internal simulation error.",
                 aidesEnabled: "Visual aids enabled",
                 aidesDisabled: "Visual aids disabled",
                 crossEnabled: "Red cross enabled",
                 crossDisabled: "Red cross disabled",
                 errorDisplayMessage: "Display error. Please reload.",
                 confirmResetHistory: "Are you sure you want to reset all history? This action is irreversible.",
                 historyResetSuccess: "History reset!",
                 copySuccess: "History content copied!",
                 copyError: "Error during copy.",
                 copyPrepareError: "Error preparing copy.",
                 noHistory: "No game history recorded.",
                 helpTitle: "Help & Goal",
                 helpTextStandard: `<strong>Welcome to the Awale Brain Trainer!</strong><br><br>Your goal is to <strong>think like a champion</strong> by guessing the move they played in a real game each time it's your turn (Player üòä ‚Üì).<br><br><strong>How to play:</strong><br>1. Choose a language and one of the first 3 available games.<br>2. When it's your turn (üòä ‚Üì), observe the board.<br>3. Click on one of your holes (A-F) containing seeds to select it.<br>4. Choose the percentage of your virtual pot to bet on this choice.<br>5. Click 'Bet!'. If your choice is correct, you win your bet. Otherwise, you lose it.<br>6. When it's the opponent's turn (üòî ‚Üë), click 'Next'.<br><br><strong>Upgrade to Premium!</strong><br>For the full experience and to support our association, join <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. The Premium version unlocks the following features:<ul><li>Access to <strong>all training games</strong>.</li><li>The <strong>"Hist"</strong> (history) and <strong>"Rec"</strong> (record notes) buttons.</li><li>Activation of <strong>visual aids</strong> (capture/pressure indicators).</li><li>Activation of the <strong>red alignment cross</strong>.</li><li>Access to <strong>secret tips</strong>.</li></ul>`,
                 helpTextPremium: `<strong>Welcome to the Premium version!</strong><br><br>You have access to all features to train yourself to think like a champion.<br><br><strong>Premium Features:</strong><br><ul><li><strong>All Games:</strong> Access all games via the selector.</li><li><strong>History ("Hist"):</strong> View your previous games, stats, and comments.</li><li>
                     <strong>AI Coaching via JSON Export:</strong> Use the "Copy (JSON)" button in the history. Paste the copied text into a conversational AI (like ChatGPT, Gemini, Mistral, etc.). The included prompt will ask the AI to analyze your games (errors, comments) and provide personalized coaching tips, directly in the language selected in the app!
                 </li><li><strong>Record ("Rec"):</strong> Add strategic notes to each move played.</li><li><strong>Visual Aids:</strong><ul><li>Enable/Disable: Long press (3s) the <strong>+</strong> button at the top right.</li><li>Blinking orange opponent hole: Your selected move captures directly.</li><li>Opponent hole with orange border: Pressure for possible future capture.</li><li>Your hole with dotted orange border: Threat of capture by the opponent.</li></ul></li><li><strong>Red Cross:</strong><ul><li>Enable/Disable: Single click the <strong>+</strong> button at the top right.</li><li>Helps visualize hole alignments.</li></ul></li></ul><strong>Activatable Secret Tips:</strong><br><ul><li><strong>Logo x3 clicks:</strong> Resets the current game.</li><li><strong>Pot x3 clicks:</strong> Toggles "Guaranteed Success" mode (all bets succeed).</li><li><strong>"I bet" text x3 clicks:</strong> Locks/Unlocks the selected bet percentage.</li><li><strong>Opponent's 'a' hole (2s press):</strong> Undoes the last move played (go back).</li><li><strong>Opponent's 'f' + 'a' holes (3s simultaneous press):</strong> Shows the secret tips list.</li></ul>`,
                 secretMessage: "Hello Eric",
                 secretTipsTitle: "Secret Tips (Premium)",
                 secretTips: [ "Logo x3 clicks: Reset game", "Pot x3 clicks: Guaranteed Success ON/OFF", "'I bet' text x3 clicks: Lock/Unlock bet (%)", "Opponent's 'f' hole (2s press): Hello Eric", "Opponent's 'a' hole (2s press): Go back (undo last move)", "Opponent's 'f' + 'a' holes (3s simultaneous press): Show this list" ],
                 commentModalTitle: "Add Comment",
                 commentInputPlaceholder: "Your strategic note here...",
                 commentCheckboxGood: "Potential Good Move",
                 commentCheckboxBad: "Potential Bad Move",
                 commentCheckboxRisky: "Risky",
                 commentCheckboxSafe: "Safe",
                 historyTitle: "Game History",
                 historyRecordTitle: (name, date) => `Game: ${name} (${date})`,
                 historyStats: (rate, pot, duration) => `Success: ${rate}% | Final Pot: ${pot}‚Ç¨ | Duration: ${duration}s`,
                 historyCommentsTitle: "Recorded Comments",
                 historyErrorsTitle: "Betting Errors",
                 historyNoComments: "No comments recorded for this game.",
                 historyNoErrors: "No betting errors recorded for this game.",
                 historyInProgress: "(In Progress)",
                 historyMoveLabel: "Move",
                 historyBetErrorLabel: (bet, correct, potChange, date) => `Bet <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Pot ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                 premiumModalTitle: "Premium Feature",
                 premiumModalText: "This feature, along with other benefits, is reserved for Premium members.",
                 premiumModalBenefitsTitle: "Premium Benefits:",
                 premiumBenefitLevels: "Access to all training games.",
                 premiumBenefitHistory: "'Hist' button to view and analyze your previous games.",
                 premiumBenefitRecord: "'Rec' button to add strategic comments.",
                 premiumBenefitAids: "Activation of visual aids (capture/pressure).",
                 premiumBenefitCross: "Activation of the red alignment cross.",
                 premiumBenefitSecrets: "Access to secret tips.",
                 premiumModalHowto: "To unlock the Premium version and support our association, become a member of <strong>Jeux Nomades France</strong>:",
                 premiumModalActionLink: "Join the association",
                 gameDropdownFormat: (index, moves) => `Game ${index} (${moves} moves)`,
                 encouragingMessages: [ "Well done!", "Great!", "Excellent!", "Keep it up!", "Impressive!", "Magnificent!", "Skillful!", "Wonderful!", "Incredible!", "Awesome!", "Perfect!", "Breathtaking!", "Rising star!", "Sensational!", "Triumph!", "Master!", "Legendary!", "Genius!", "Champion!", "Immortal!" ]
             },
             es: {
                pageTitle: "En la Mente de un Campe√≥n",
                languageLabel: "Idioma:",
                levelLabel: "Partida:",
                title: "¬°En la Mente de un Campe√≥n!",
                moveInfo: (p1, p2) => `Jugador üòä ‚Üì: ${p1} | Jugador üòî ‚Üë: ${p2}`,
                betPotInfo: (pot) => `Bote:<BR>${pot} ‚Ç¨`,
                successRate: (rate) => `√âxito:<BR>${rate} %`,
                playedMoves: (index, total, moves) => `${index} / ${total} | √öltimos movs: ${moves}`,
                betLabel: "Apuesto",
                betCaseLabel: "en",
                betButton: "¬°Apostar!",
                nextButton: "Siguiente",
                recordButtonShort: "Nota",
                historyButtonShort: "Hist",
                closeButton: "Cerrar",
                saveButton: "Guardar",
                cancelButton: "Cancelar",
                copyButton: "Copiar (JSON)",
                resetButton: "Reset",
                tooltipPot: "Tu dinero virtual actual",
                tooltipSuccessRate: "Porcentaje de apuestas correctas en esta partida",
                tooltipRecord: "Guardar un comentario para este movimiento (Premium)",
                tooltipHistory: "Ver historial de partidas jugadas (Premium)",
                tooltipHelp: "Mostrar Ayuda / Reglas",
                tooltipTheme: "Modo Oscuro/Claro",
                tooltipCross: "Opciones Premium (Cruz / Ayudas)",
                resultInvalidBet: "¬°Apuesta inv√°lida!",
                resultWin: "¬°Ganaste!",
                resultLose: "¬°Perdiste!",
                resultGameOver: "¬°Partida terminada!",
                resetMessage: "¬°Juego reiniciado!",
                premiumUnlockedMessage: "¬°Versi√≥n Premium activada! Funciones desbloqueadas.",
                successOnMessage: "√âxito garantizado ACTIVADO",
                successOffMessage: "√âxito garantizado DESACTIVADO",
                betLockedMessage: (pct) => `Apuesta bloqueada (${pct}%)`,
                betUnlockedMessage: "Apuesta desbloqueada",
                backMessage: "Deshacer exitoso",
                opponentTurnMessage: "Clic Siguiente (turno del oponente)",
                playerTurnIndicator: "Tu turno: ¬°Selecciona y apuesta!",
                opponentTurnIndicator: "Turno del oponente (Clic Siguiente)",
                emptyHoleMessage: "¬°Casilla vac√≠a!",
                notYourTurnMessage: "¬°No es tu turno! Haz clic en 'Siguiente'.",
                invalidHoleMessage: "¬°Casilla inv√°lida o vac√≠a!",
                internalErrorMessage: "Error interno de simulaci√≥n.",
                aidesEnabled: "Ayudas visuales activadas",
                aidesDisabled: "Ayudas visuales desactivadas",
                crossEnabled: "Cruz roja activada",
                crossDisabled: "Cruz roja desactivada",
                errorDisplayMessage: "Error de visualizaci√≥n. Por favor, recarga.",
                confirmResetHistory: "¬øEst√°s seguro de que quieres reiniciar todo el historial? Esta acci√≥n es irreversible.",
                historyResetSuccess: "¬°Historial reiniciado!",
                copySuccess: "¬°Contenido del historial copiado!",
                copyError: "Error durante la copia.",
                copyPrepareError: "Error preparando la copia.",
                noHistory: "No hay historial de partidas registrado.",
                helpTitle: "Ayuda y Objetivo",
                helpTextStandard: `<strong>¬°Bienvenido al Entrenador Cerebral Awal√©!</strong><br><br>Tu objetivo es <strong>pensar como un campe√≥n</strong> adivinando el movimiento que jug√≥ en una partida real cada vez que sea tu turno (Jugador üòä ‚Üì).<br><br><strong>C√≥mo jugar:</strong><br>1. Elige un idioma y una de las 3 primeras partidas disponibles.<br>2. Cuando sea tu turno (üòä ‚Üì), observa el tablero.<br>3. Haz clic en una de tus casillas (A-F) que contenga semillas para seleccionarla.<br>4. Elige el porcentaje de tu bote virtual para apostar a esta elecci√≥n.<br>5. Haz clic en '¬°Apostar!'. Si tu elecci√≥n es correcta, ganas tu apuesta. Si no, la pierdes.<br>6. Cuando sea el turno del oponente (üòî ‚Üë), haz clic en 'Siguiente'.<br><br><strong>¬°Actualiza a Premium!</strong><br>Para la experiencia completa y apoyar nuestra asociaci√≥n, √∫nete a <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. La versi√≥n Premium desbloquea las siguientes funciones:<ul><li>Acceso a <strong>todas las partidas</strong> de entrenamiento.</li><li>Los botones <strong>"Hist"</strong> (historial) y <strong>"Nota"</strong> (tomar notas).</li><li>Activaci√≥n de <strong>ayudas visuales</strong> (indicadores de captura/presi√≥n).</li><li>Activaci√≥n de la <strong>cruz roja</strong> de alineaci√≥n.</li><li>Acceso a <strong>consejos secretos</strong>.</li></ul>`,
                helpTextPremium: `<strong>¬°Bienvenido a la versi√≥n Premium!</strong><br><br>Tienes acceso a todas las funciones para entrenarte a pensar como un campe√≥n.<br><br><strong>Funciones Premium:</strong><br><ul><li><strong>Todas las Partidas:</strong> Accede a todas las partidas a trav√©s del selector.</li><li><strong>Historial ("Hist"):</strong> Consulta tus partidas anteriores, estad√≠sticas y comentarios.</li><li>
                     <strong>Coaching por IA v√≠a Exportaci√≥n JSON:</strong> Usa el bot√≥n "Copiar (JSON)" en el historial. Pega el texto copiado en una IA conversacional (como ChatGPT, Gemini, Mistral, etc.). El prompt incluido pedir√° a la IA que analice tus partidas (errores, comentarios) y te d√© consejos de coaching personalizados, ¬°directamente en el idioma seleccionado en la aplicaci√≥n!
                 </li><li><strong>Grabar ("Nota"):</strong> A√±ade notas estrat√©gicas a cada movimiento jugado.</li><li><strong>Ayudas Visuales:</strong><ul><li>Activar/Desactivar: Mant√©n pulsado (3s) el bot√≥n <strong>+</strong> en la esquina superior derecha.</li><li>Casilla del oponente naranja parpadeante: Tu movimiento seleccionado captura directamente.</li><li>Casilla del oponente con borde naranja: Presi√≥n para posible captura futura.</li><li>Tu casilla con borde naranja punteado: Amenaza de captura por el oponente.</li></ul></li><li><strong>Cruz Roja:</strong><ul><li>Activar/Desactivar: Un solo clic en el bot√≥n <strong>+</strong> en la esquina superior derecha.</li><li>Ayuda a visualizar las alineaciones de las casillas.</li></ul></li></ul><strong>Consejos Secretos Activables:</strong><br><ul><li><strong>Logo x3 clics:</strong> Reinicia la partida actual.</li><li><strong>Bote x3 clics:</strong> Activa/Desactiva el modo "√âxito Garantizado" (todas las apuestas tienen √©xito).</li><li><strong>Texto "Apuesto" x3 clics:</strong> Bloquea/Desbloquea el porcentaje de apuesta seleccionado.</li><li><strong>Casilla 'a' del oponente (pulsaci√≥n 2s):</strong> Deshace el √∫ltimo movimiento jugado (retroceder).</li><li><strong>Casillas 'f' + 'a' del oponente (pulsaci√≥n simult√°nea 3s):</strong> Muestra la lista de consejos secretos.</li></ul>`,
                secretMessage: "Hola Eric",
                secretTipsTitle: "Consejos Secretos (Premium)",
                secretTips: [ "Logo x3 clics: Reiniciar partida", "Bote x3 clics: √âxito garantizado ON/OFF", "'Apuesto' x3 clics: Bloquear/Desbloquear apuesta (%)", "Casilla 'f' oponente (pulsar 2s): Hola Eric", "Casilla 'a' oponente (pulsar 2s): Retroceder (deshacer √∫ltimo mov.)", "Casillas 'f' + 'a' oponentes (pulsar 3s simult.): Muestra esta lista" ],
                commentModalTitle: "A√±adir Comentario",
                commentInputPlaceholder: "Tu nota estrat√©gica aqu√≠...",
                commentCheckboxGood: "Movimiento Potencialmente Bueno",
                commentCheckboxBad: "Movimiento Potencialmente Malo",
                commentCheckboxRisky: "Arriesgado",
                commentCheckboxSafe: "Seguro",
                historyTitle: "Historial de Partidas",
                historyRecordTitle: (name, date) => `Partida: ${name} (${date})`,
                historyStats: (rate, pot, duration) => `√âxito: ${rate}% | Bote final: ${pot}‚Ç¨ | Duraci√≥n: ${duration}s`,
                historyCommentsTitle: "Comentarios Guardados",
                historyErrorsTitle: "Errores de Apuesta",
                historyNoComments: "No hay comentarios guardados para esta partida.",
                historyNoErrors: "No hay errores de apuesta guardados para esta partida.",
                historyInProgress: "(En curso)",
                historyMoveLabel: "Mov.",
                historyBetErrorLabel: (bet, correct, potChange, date) => `Apostado <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (Bote ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                premiumModalTitle: "Funci√≥n Premium",
                premiumModalText: "Esta funci√≥n, junto con otros beneficios, est√° reservada para miembros Premium.",
                premiumModalBenefitsTitle: "Beneficios Premium:",
                premiumBenefitLevels: "Acceso a todas las partidas de entrenamiento.",
                premiumBenefitHistory: "Bot√≥n 'Hist' para ver y analizar tus partidas anteriores.",
                premiumBenefitRecord: "Bot√≥n 'Nota' para a√±adir comentarios estrat√©gicos.",
                premiumBenefitAids: "Activaci√≥n de ayudas visuales (capturas/presi√≥n).",
                premiumBenefitCross: "Activaci√≥n de la cruz roja de alineaci√≥n.",
                premiumBenefitSecrets: "Acceso a consejos secretos.",
                premiumModalHowto: "Para desbloquear la versi√≥n Premium y apoyar nuestra asociaci√≥n, hazte miembro de <strong>Jeux Nomades France</strong>:",
                premiumModalActionLink: "Unirse a la asociaci√≥n",
                gameDropdownFormat: (index, moves) => `Partida ${index} (${moves} movs)`,
                encouragingMessages: [ "¬°Bien hecho!", "¬°Genial!", "¬°Excelente!", "¬°Sigue as√≠!", "¬°Impresionante!", "¬°Magn√≠fico!", "¬°H√°bil!", "¬°Maravilloso!", "¬°Incre√≠ble!", "¬°Asombroso!", "¬°Perfecto!", "¬°Alucinante!", "¬°Estrella en ascenso!", "¬°Sensacional!", "¬°Triunfo!", "¬°Maestro!", "¬°Legendario!", "¬°Genio!", "¬°Campe√≥n!", "¬°Inmortal!" ]
             },
             ru: { // --- Russian (–†—É—Å—Å–∫–∏–π) Translations ---
                pageTitle: "–í –ú—ã—Å–ª—è—Ö –ß–µ–º–ø–∏–æ–Ω–∞",
                languageLabel: "–Ø–∑—ã–∫:",
                levelLabel: "–ò–≥—Ä–∞:",
                title: "–í –ú—ã—Å–ª—è—Ö –ß–µ–º–ø–∏–æ–Ω–∞!",
                moveInfo: (p1, p2) => `–ò–≥—Ä–æ–∫ üòä ‚Üì: ${p1} | –ò–≥—Ä–æ–∫ üòî ‚Üë: ${p2}`,
                betPotInfo: (pot) => `–ë–∞–Ω–∫:<BR>${pot} ‚Ç¨`,
                successRate: (rate) => `–£—Å–ø–µ—Ö:<BR>${rate} %`,
                playedMoves: (index, total, moves) => `${index} / ${total} | –ü–æ—Å–ª. —Ö–æ–¥—ã: ${moves}`,
                betLabel: "–°—Ç–∞–≤–ª—é",
                betCaseLabel: "–Ω–∞",
                betButton: "–°—Ç–∞–≤–∫–∞!",
                nextButton: "–î–∞–ª—å—à–µ",
                recordButtonShort: "–ó–∞–ø",
                historyButtonShort: "–ò—Å—Ç",
                closeButton: "–ó–∞–∫—Ä—ã—Ç—å",
                saveButton: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
                cancelButton: "–û—Ç–º–µ–Ω–∞",
                copyButton: "–ö–æ–ø–∏—Ä. (JSON)",
                resetButton: "–°–±—Ä–æ—Å",
                tooltipPot: "–í–∞—à–∏ —Ç–µ–∫—É—â–∏–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ –¥–µ–Ω—å–≥–∏",
                tooltipSuccessRate: "–ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å—Ç–∞–≤–æ–∫ –≤ —ç—Ç–æ–π –∏–≥—Ä–µ",
                tooltipRecord: "–ó–∞–ø–∏—Å–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ —ç—Ç–æ–º—É —Ö–æ–¥—É (–ü—Ä–µ–º–∏—É–º)",
                tooltipHistory: "–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –∏–≥—Ä (–ü—Ä–µ–º–∏—É–º)",
                tooltipHelp: "–ü–æ–∫–∞–∑–∞—Ç—å –ü–æ–º–æ—â—å / –ü—Ä–∞–≤–∏–ª–∞",
                tooltipTheme: "–¢–µ–º–Ω—ã–π/–°–≤–µ—Ç–ª—ã–π –†–µ–∂–∏–º",
                tooltipCross: "–ü—Ä–µ–º–∏—É–º –û–ø—Ü–∏–∏ (–ö—Ä–µ—Å—Ç / –ü–æ–º–æ—â—å)",
                resultInvalidBet: "–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–∞–≤–∫–∞!",
                resultWin: "–í—ã–∏–≥—Ä—ã—à!",
                resultLose: "–ü—Ä–æ–∏–≥—Ä—ã—à!",
                resultGameOver: "–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!",
                resetMessage: "–ò–≥—Ä–∞ —Å–±—Ä–æ—à–µ–Ω–∞!",
                premiumUnlockedMessage: "–ü—Ä–µ–º–∏—É–º –í–µ—Ä—Å–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞! –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.",
                successOnMessage: "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–ö–õ",
                successOffMessage: "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–´–ö–õ",
                betLockedMessage: (pct) => `–°—Ç–∞–≤–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ (${pct}%)`,
                betUnlockedMessage: "–°—Ç–∞–≤–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞",
                backMessage: "–û—Ç–º–µ–Ω–∞ —Ö–æ–¥–∞ —É—Å–ø–µ—à–Ω–∞",
                opponentTurnMessage: "–ù–∞–∂–º–∏—Ç–µ –î–∞–ª–µ–µ (—Ö–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞)",
                playerTurnIndicator: "–í–∞—à —Ö–æ–¥: –í—ã–±–µ—Ä–∏—Ç–µ –∏ —Å—Ç–∞–≤—å—Ç–µ!",
                opponentTurnIndicator: "–•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–ù–∞–∂–º–∏—Ç–µ –î–∞–ª–µ–µ)",
                emptyHoleMessage: "–ü—É—Å—Ç–∞—è –ª—É–Ω–∫–∞!",
                notYourTurnMessage: "–ù–µ –≤–∞—à —Ö–æ–¥! –ù–∞–∂–º–∏—Ç–µ '–î–∞–ª–µ–µ'.",
                invalidHoleMessage: "–ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ –ø—É—Å—Ç–∞—è –ª—É–Ω–∫–∞!",
                internalErrorMessage: "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–∏–º—É–ª—è—Ü–∏–∏.",
                aidesEnabled: "–í–∏–∑—É–∞–ª—å–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –≤–∫–ª—é—á–µ–Ω—ã",
                aidesDisabled: "–í–∏–∑—É–∞–ª—å–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –≤—ã–∫–ª—é—á–µ–Ω—ã",
                crossEnabled: "–ö—Ä–∞—Å–Ω—ã–π –∫—Ä–µ—Å—Ç –≤–∫–ª—é—á–µ–Ω",
                crossDisabled: "–ö—Ä–∞—Å–Ω—ã–π –∫—Ä–µ—Å—Ç –≤—ã–∫–ª—é—á–µ–Ω",
                errorDisplayMessage: "–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ.",
                confirmResetHistory: "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.",
                historyResetSuccess: "–ò—Å—Ç–æ—Ä–∏—è —Å–±—Ä–æ—à–µ–Ω–∞!",
                copySuccess: "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏—Å—Ç–æ—Ä–∏–∏ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!",
                copyError: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏.",
                copyPrepareError: "–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∫–æ–ø–∏–∏.",
                noHistory: "–ò—Å—Ç–æ—Ä–∏—è –∏–≥—Ä –Ω–µ –∑–∞–ø–∏—Å–∞–Ω–∞.",
                helpTitle: "–ü–æ–º–æ—â—å –∏ –¶–µ–ª—å",
                helpTextStandard: `<strong>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ç—Ä–µ–Ω–∞–∂–µ—Ä –¥–ª—è –º–æ–∑–≥–∞ –ê–≤–∞–ª–µ!</strong><br><br>–í–∞—à–∞ —Ü–µ–ª—å - <strong>–¥—É–º–∞—Ç—å –∫–∞–∫ —á–µ–º–ø–∏–æ–Ω</strong>, —É–≥–∞–¥—ã–≤–∞—è —Ö–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –æ–Ω —Å–¥–µ–ª–∞–ª –≤ —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ, –∫–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –≤–∞—à —Ö–æ–¥ (–ò–≥—Ä–æ–∫ üòä ‚Üì).<br><br><strong>–ö–∞–∫ –∏–≥—Ä–∞—Ç—å:</strong><br>1. –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∏ –æ–¥–Ω—É –∏–∑ –ø–µ—Ä–≤—ã—Ö 3 –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–≥—Ä.<br>2. –ö–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç –≤–∞—à —Ö–æ–¥ (üòä ‚Üì), –Ω–∞–±–ª—é–¥–∞–π—Ç–µ –∑–∞ –¥–æ—Å–∫–æ–π.<br>3. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –æ–¥–Ω—É –∏–∑ –≤–∞—à–∏—Ö –ª—É–Ω–æ–∫ (A-F), —Å–æ–¥–µ—Ä–∂–∞—â—É—é —Å–µ–º–µ–Ω–∞, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –µ—ë.<br>4. –í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ—Ü–µ–Ω—Ç –≤–∞—à–µ–≥–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –±–∞–Ω–∫–∞ –¥–ª—è —Å—Ç–∞–≤–∫–∏ –Ω–∞ —ç—Ç–æ—Ç –≤—ã–±–æ—Ä.<br>5. –ù–∞–∂–º–∏—Ç–µ '–°—Ç–∞–≤–∫–∞!'. –ï—Å–ª–∏ –≤–∞—à –≤—ã–±–æ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π, –≤—ã –≤—ã–∏–≥—Ä—ã–≤–∞–µ—Ç–µ —Å—Ç–∞–≤–∫—É. –ò–Ω–∞—á–µ, –≤—ã –µ—ë —Ç–µ—Ä—è–µ—Ç–µ.<br>6. –ö–æ–≥–¥–∞ –Ω–∞—Å—Ç—É–ø–∞–µ—Ç —Ö–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (üòî ‚Üë), –Ω–∞–∂–º–∏—Ç–µ '–î–∞–ª—å—à–µ'.<br><br><strong>–ü–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ –Ω–∞ –ü—Ä–µ–º–∏—É–º!</strong><br>–î–ª—è –ø–æ–ª–Ω–æ–≥–æ –æ–ø—ã—Ç–∞ –∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –Ω–∞—à–µ–π –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏, –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>. –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—è –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:<ul><li>–î–æ—Å—Ç—É–ø –∫–æ <strong>–≤—Å–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º –∏–≥—Ä–∞–º</strong>.</li><li>–ö–Ω–æ–ø–∫–∏ <strong>"–ò—Å—Ç"</strong> (–∏—Å—Ç–æ—Ä–∏—è) –∏ <strong>"–ó–∞–ø"</strong> (–∑–∞–ø–∏—Å—å –∑–∞–º–µ—Ç–æ–∫).</li><li>–ê–∫—Ç–∏–≤–∞—Ü–∏—è <strong>–≤–∏–∑—É–∞–ª—å–Ω—ã—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫</strong> (–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∑–∞—Ö–≤–∞—Ç–∞/–¥–∞–≤–ª–µ–Ω–∏—è).</li><li>–ê–∫—Ç–∏–≤–∞—Ü–∏—è <strong>–∫—Ä–∞—Å–Ω–æ–≥–æ –∫—Ä–µ—Å—Ç–∞</strong> –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è.</li><li>–î–æ—Å—Ç—É–ø –∫ <strong>—Å–µ–∫—Ä–µ—Ç–Ω—ã–º —Å–æ–≤–µ—Ç–∞–º</strong>.</li></ul>`,
                helpTextPremium: `<strong>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—é!</strong><br><br>–£ –≤–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º, —á—Ç–æ–±—ã —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è –¥—É–º–∞—Ç—å –∫–∞–∫ —á–µ–º–ø–∏–æ–Ω.<br><br><strong>–ü—Ä–µ–º–∏—É–º –§—É–Ω–∫—Ü–∏–∏:</strong><br><ul><li><strong>–í—Å–µ –ò–≥—Ä—ã:</strong> –î–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∏–≥—Ä–∞–º —á–µ—Ä–µ–∑ —Å–µ–ª–µ–∫—Ç–æ—Ä.</li><li><strong>–ò—Å—Ç–æ—Ä–∏—è ("–ò—Å—Ç"):</strong> –ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ –≤–∞—à–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –∏–≥—Ä—ã, —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏.</li><li>
                     <strong>–ö–æ—É—á–∏–Ω–≥ –æ—Ç –ò–ò —á–µ—Ä–µ–∑ –≠–∫—Å–ø–æ—Ä—Ç JSON:</strong> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É "–ö–æ–ø–∏—Ä. (JSON)" –≤ –∏—Å—Ç–æ—Ä–∏–∏. –í—Å—Ç–∞–≤—å—Ç–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ –¥–∏–∞–ª–æ–≥–æ–≤—ã–π –ò–ò (–Ω–∞–ø—Ä–∏–º–µ—Ä, ChatGPT, Gemini, Mistral –∏ —Ç.–¥.). –í–∫–ª—é—á–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –ø–æ–ø—Ä–æ—Å–∏—Ç –ò–ò –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–∏ –∏–≥—Ä—ã (–æ—à–∏–±–∫–∏, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏) –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Å–æ–≤–µ—Ç—ã –ø–æ –∫–æ—É—á–∏–Ω–≥—É, –ø—Ä—è–º–æ –Ω–∞ —è–∑—ã–∫–µ, –≤—ã–±—Ä–∞–Ω–Ω–æ–º –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏!
                 </li><li><strong>–ó–∞–ø–∏—Å—å ("–ó–∞–ø"):</strong> –î–æ–±–∞–≤–ª—è–π—Ç–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ –∑–∞–º–µ—Ç–∫–∏ –∫ –∫–∞–∂–¥–æ–º—É —Å—ã–≥—Ä–∞–Ω–Ω–æ–º—É —Ö–æ–¥—É.</li><li><strong>–í–∏–∑—É–∞–ª—å–Ω—ã–µ –ü–æ–¥—Å–∫–∞–∑–∫–∏:</strong><ul><li>–í–∫–ª—é—á–µ–Ω–∏–µ/–í—ã–∫–ª—é—á–µ–Ω–∏–µ: –î–ª–∏—Ç–µ–ª—å–Ω–æ–µ –Ω–∞–∂–∞—Ç–∏–µ (3—Å) –Ω–∞ –∫–Ω–æ–ø–∫—É <strong>+</strong> –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É.</li><li>–ú–∏–≥–∞—é—â–∞—è –æ—Ä–∞–Ω–∂–µ–≤–∞—è –ª—É–Ω–∫–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞: –í–∞—à –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ö–æ–¥ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–ø—Ä—è–º—É—é.</li><li>–õ—É–Ω–∫–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ —Å –æ—Ä–∞–Ω–∂–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ–π: –î–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –±—É–¥—É—â–µ–≥–æ –∑–∞—Ö–≤–∞—Ç–∞.</li><li>–í–∞—à–∞ –ª—É–Ω–∫–∞ —Å –ø—É–Ω–∫—Ç–∏—Ä–Ω–æ–π –æ—Ä–∞–Ω–∂–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ–π: –£–≥—Ä–æ–∑–∞ –∑–∞—Ö–≤–∞—Ç–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–º.</li></ul></li><li><strong>–ö—Ä–∞—Å–Ω—ã–π –ö—Ä–µ—Å—Ç:</strong><ul><li>–í–∫–ª—é—á–µ–Ω–∏–µ/–í—ã–∫–ª—é—á–µ–Ω–∏–µ: –û–¥–∏–Ω–æ—á–Ω—ã–π –∫–ª–∏–∫ –Ω–∞ –∫–Ω–æ–ø–∫—É <strong>+</strong> –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É.</li><li>–ü–æ–º–æ–≥–∞–µ—Ç –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ª—É–Ω–æ–∫.</li></ul></li></ul><strong>–ê–∫—Ç–∏–≤–∏—Ä—É–µ–º—ã–µ –°–µ–∫—Ä–µ—Ç–Ω—ã–µ –°–æ–≤–µ—Ç—ã:</strong><br><ul><li><strong>–õ–æ–≥–æ x3 –∫–ª–∏–∫–∞:</strong> –°–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â—É—é –∏–≥—Ä—É.</li><li><strong>–ë–∞–Ω–∫ x3 –∫–ª–∏–∫–∞:</strong> –í–∫–ª/–í—ã–∫–ª —Ä–µ–∂–∏–º "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö" (–≤—Å–µ —Å—Ç–∞–≤–∫–∏ —É—Å–ø–µ—à–Ω—ã).</li><li><strong>–¢–µ–∫—Å—Ç "–°—Ç–∞–≤–ª—é" x3 –∫–ª–∏–∫–∞:</strong> –ë–ª–æ–∫–∏—Ä—É–µ—Ç/–†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç —Å—Ç–∞–≤–∫–∏.</li><li><strong>–õ—É–Ω–∫–∞ 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç–∏–µ 2—Å):</strong> –û—Ç–º–µ–Ω—è–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å—ã–≥—Ä–∞–Ω–Ω—ã–π —Ö–æ–¥ (–Ω–∞–∑–∞–¥).</li><li><strong>–õ—É–Ω–∫–∏ 'f' + 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ –Ω–∞–∂–∞—Ç–∏–µ 3—Å):</strong> –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö —Å–æ–≤–µ—Ç–æ–≤.</li></ul>`,
                secretMessage: "–ü—Ä–∏–≤–µ—Ç, –≠—Ä–∏–∫",
                secretTipsTitle: "–°–µ–∫—Ä–µ—Ç–Ω—ã–µ –°–æ–≤–µ—Ç—ã (–ü—Ä–µ–º–∏—É–º)",
                secretTips: [ "–õ–æ–≥–æ x3 –∫–ª–∏–∫–∞: –°–±—Ä–æ—Å –∏–≥—Ä—ã", "–ë–∞–Ω–∫ x3 –∫–ª–∏–∫–∞: –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –£—Å–ø–µ—Ö –í–ö–õ/–í–´–ö–õ", "'–°—Ç–∞–≤–ª—é' x3 –∫–ª–∏–∫–∞: –ë–ª–æ–∫/–†–∞–∑–±–ª–æ–∫ —Å—Ç–∞–≤–∫–∏ (%)", "–õ—É–Ω–∫–∞ 'f' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç—å 2—Å): –ü—Ä–∏–≤–µ—Ç, –≠—Ä–∏–∫", "–õ—É–Ω–∫–∞ 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç—å 2—Å): –ù–∞–∑–∞–¥ (–æ—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª. —Ö–æ–¥)", "–õ—É–Ω–∫–∏ 'f' + 'a' –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–Ω–∞–∂–∞—Ç—å 3—Å –æ–¥–Ω–æ–≤—Ä.): –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ—Ç —Å–ø–∏—Å–æ–∫" ],
                commentModalTitle: "–î–æ–±–∞–≤–∏—Ç—å –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π",
                commentInputPlaceholder: "–í–∞—à–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∞—è –∑–∞–º–µ—Ç–∫–∞ –∑–¥–µ—Å—å...",
                commentCheckboxGood: "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –•–æ—Ä–æ—à–∏–π –•–æ–¥",
                commentCheckboxBad: "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –ü–ª–æ—Ö–æ–π –•–æ–¥",
                commentCheckboxRisky: "–†–∏—Å–∫–æ–≤–∞–Ω–Ω—ã–π",
                commentCheckboxSafe: "–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π",
                historyTitle: "–ò—Å—Ç–æ—Ä–∏—è –ò–≥—Ä",
                historyRecordTitle: (name, date) => `–ò–≥—Ä–∞: ${name} (${date})`,
                historyStats: (rate, pot, duration) => `–£—Å–ø–µ—Ö: ${rate}% | –§–∏–Ω–∞–ª. –±–∞–Ω–∫: ${pot}‚Ç¨ | –î–ª–∏—Ç.: ${duration}—Å`,
                historyCommentsTitle: "–ó–∞–ø–∏—Å–∞–Ω–Ω—ã–µ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏",
                historyErrorsTitle: "–û—à–∏–±–∫–∏ –°—Ç–∞–≤–æ–∫",
                historyNoComments: "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –¥–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã –Ω–µ –∑–∞–ø–∏—Å–∞–Ω—ã.",
                historyNoErrors: "–û—à–∏–±–∫–∏ —Å—Ç–∞–≤–æ–∫ –¥–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã –Ω–µ –∑–∞–ø–∏—Å–∞–Ω—ã.",
                historyInProgress: "(–í –ø—Ä–æ—Ü–µ—Å—Å–µ)",
                historyMoveLabel: "–•–æ–¥",
                historyBetErrorLabel: (bet, correct, potChange, date) => `–°—Ç–∞–≤–∫–∞ <span class="error-detail">${bet}</span> –ø—Ä–æ—Ç–∏–≤ <span class="error-detail">${correct}</span> (–ë–∞–Ω–∫ ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                premiumModalTitle: "–ü—Ä–µ–º–∏—É–º –§—É–Ω–∫—Ü–∏—è",
                premiumModalText: "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è, –∞ —Ç–∞–∫–∂–µ –¥—Ä—É–≥–∏–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞, –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –¥–ª—è –ü—Ä–µ–º–∏—É–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.",
                premiumModalBenefitsTitle: "–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –ü—Ä–µ–º–∏—É–º:",
                premiumBenefitLevels: "–î–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º –∏–≥—Ä–∞–º.",
                premiumBenefitHistory: "–ö–Ω–æ–ø–∫–∞ '–ò—Å—Ç' –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏ –∞–Ω–∞–ª–∏–∑–∞ –≤–∞—à–∏—Ö –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –∏–≥—Ä.",
                premiumBenefitRecord: "–ö–Ω–æ–ø–∫–∞ '–ó–∞–ø' –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.",
                premiumBenefitAids: "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫ (–∑–∞—Ö–≤–∞—Ç/–¥–∞–≤–ª–µ–Ω–∏–µ).",
                premiumBenefitCross: "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –∫—Ä–∞—Å–Ω–æ–≥–æ –∫—Ä–µ—Å—Ç–∞ –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è.",
                premiumBenefitSecrets: "–î–æ—Å—Ç—É–ø –∫ —Å–µ–∫—Ä–µ—Ç–Ω—ã–º —Å–æ–≤–µ—Ç–∞–º.",
                premiumModalHowto: "–ß—Ç–æ–±—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ü—Ä–µ–º–∏—É–º –≤–µ—Ä—Å–∏—é –∏ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –Ω–∞—à—É –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—é, —Å—Ç–∞–Ω—å—Ç–µ —á–ª–µ–Ω–æ–º <strong>Jeux Nomades France</strong>:",
                premiumModalActionLink: "–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏",
                gameDropdownFormat: (index, moves) => `–ò–≥—Ä–∞ ${index} (${moves} —Ö–æ–¥–æ–≤)`,
                encouragingMessages: [ "–ú–æ–ª–æ–¥–µ—Ü!", "–û—Ç–ª–∏—á–Ω–æ!", "–ü—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω–æ!", "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!", "–í–ø–µ—á–∞—Ç–ª—è—é—â–µ!", "–í–µ–ª–∏–∫–æ–ª–µ–ø–Ω–æ!", "–ò—Å–∫—É—Å–Ω–æ!", "–ó–∞–º–µ—á–∞—Ç–µ–ª—å–Ω–æ!", "–ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!", "–ö—Ä—É—Ç–æ!", "–ò–¥–µ–∞–ª—å–Ω–æ!", "–£–º–æ–ø–æ–º—Ä–∞—á–∏—Ç–µ–ª—å–Ω–æ!", "–í–æ—Å—Ö–æ–¥—è—â–∞—è –∑–≤–µ–∑–¥–∞!", "–°–µ–Ω—Å–∞—Ü–∏–æ–Ω–Ω–æ!", "–¢—Ä–∏—É–º—Ñ!", "–ú–∞—Å—Ç–µ—Ä!", "–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ!", "–ì–µ–Ω–∏–π!", "–ß–µ–º–ø–∏–æ–Ω!", "–ë–µ—Å—Å–º–µ—Ä—Ç–Ω—ã–π!" ]
             },
             zh: { // --- Chinese (‰∏≠Êñá) Translations ---
                pageTitle: "ÂÜ†ÂÜõÁöÑÊÄùÁª¥",
                languageLabel: "ËØ≠Ë®Ä:",
                levelLabel: "Ê£ãÂ±Ä:",
                title: "ÂÜ†ÂÜõÁöÑÊÄùÁª¥!",
                moveInfo: (p1, p2) => `Áé©ÂÆ∂ üòä ‚Üì: ${p1} | Áé©ÂÆ∂ üòî ‚Üë: ${p2}`,
                betPotInfo: (pot) => `ÂΩ©Ê±†:<BR>${pot} ‚Ç¨`,
                successRate: (rate) => `ÊàêÂäüÁéá:<BR>${rate} %`,
                playedMoves: (index, total, moves) => `${index} / ${total} | ÊúÄËøëÊ≠•Êï∞: ${moves}`,
                betLabel: "Êàë‰∏ãÊ≥®",
                betCaseLabel: "Âú®",
                betButton: "‰∏ãÊ≥®!",
                nextButton: "‰∏ã‰∏ÄÊ≠•",
                recordButtonShort: "ËÆ∞ÂΩï",
                historyButtonShort: "ÂéÜÂè≤",
                closeButton: "ÂÖ≥Èó≠",
                saveButton: "‰øùÂ≠ò",
                cancelButton: "ÂèñÊ∂à",
                copyButton: "Â§çÂà∂ (JSON)",
                resetButton: "ÈáçÁΩÆ",
                tooltipPot: "ÊÇ®ÂΩìÂâçÁöÑËôöÊãüËµÑÈáë",
                tooltipSuccessRate: "Ê≠§Â±ÄÊ∏∏Êàè‰∏≠Ê≠£Á°Æ‰∏ãÊ≥®ÁöÑÁôæÂàÜÊØî",
                tooltipRecord: "ËÆ∞ÂΩïÊ≠§Ê≠•ÁöÑËØÑËÆ∫ (È´òÁ∫ßÁâà)",
                tooltipHistory: "Êü•ÁúãÂ∑≤Áé©Ê£ãÂ±ÄÁöÑÂéÜÂè≤ËÆ∞ÂΩï (È´òÁ∫ßÁâà)",
                tooltipHelp: "ÊòæÁ§∫Â∏ÆÂä© / ËßÑÂàô",
                tooltipTheme: "Ê∑±Ëâ≤/ÊµÖËâ≤Ê®°Âºè",
                tooltipCross: "È´òÁ∫ßÈÄâÈ°π (ÂçÅÂ≠óÁ∫ø / ËæÖÂä©)",
                resultInvalidBet: "Êó†Êïà‰∏ãÊ≥®!",
                resultWin: "Ëµ¢‰∫Ü!",
                resultLose: "Ëæì‰∫Ü!",
                resultGameOver: "Ê∏∏ÊàèÁªìÊùü!",
                resetMessage: "Ê∏∏ÊàèÂ∑≤ÈáçÁΩÆ!",
                premiumUnlockedMessage: "È´òÁ∫ßÁâàÂ∑≤ÊøÄÊ¥ªÔºÅÂäüËÉΩÂ∑≤Ëß£ÈîÅ„ÄÇ",
                successOnMessage: "‰øùËØÅÊàêÂäü Â∑≤ÂºÄÂêØ",
                successOffMessage: "‰øùËØÅÊàêÂäü Â∑≤ÂÖ≥Èó≠",
                betLockedMessage: (pct) => `‰∏ãÊ≥®Â∑≤ÈîÅÂÆö (${pct}%)`,
                betUnlockedMessage: "‰∏ãÊ≥®Â∑≤Ëß£ÈîÅ",
                backMessage: "Êí§ÈîÄÊàêÂäü",
                opponentTurnMessage: "ÁÇπÂáª‰∏ã‰∏ÄÊ≠• (ÂØπÊñπÂõûÂêà)",
                playerTurnIndicator: "ËΩÆÂà∞ÊÇ®: ÈÄâÊã©Âπ∂‰∏ãÊ≥®!",
                opponentTurnIndicator: "ÂØπÊñπÂõûÂêà (ÁÇπÂáª‰∏ã‰∏ÄÊ≠•)",
                emptyHoleMessage: "Á©∫Á©¥!",
                notYourTurnMessage: "ËøòÊ≤°ËΩÆÂà∞ÊÇ®ÔºÅÁÇπÂáª'‰∏ã‰∏ÄÊ≠•'„ÄÇ",
                invalidHoleMessage: "Êó†ÊïàÊàñÁ©∫ÁöÑÁ©¥‰Ωç!",
                internalErrorMessage: "ÂÜÖÈÉ®Ê®°ÊãüÈîôËØØ„ÄÇ",
                aidesEnabled: "ËßÜËßâËæÖÂä©Â∑≤ÂêØÁî®",
                aidesDisabled: "ËßÜËßâËæÖÂä©Â∑≤Á¶ÅÁî®",
                crossEnabled: "Á∫¢ÂçÅÂ≠óÁ∫øÂ∑≤ÂêØÁî®",
                crossDisabled: "Á∫¢ÂçÅÂ≠óÁ∫øÂ∑≤Á¶ÅÁî®",
                errorDisplayMessage: "ÊòæÁ§∫ÈîôËØØ„ÄÇËØ∑ÈáçÊñ∞Âä†ËΩΩ„ÄÇ",
                confirmResetHistory: "ÊÇ®Á°ÆÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâÂéÜÂè≤ËÆ∞ÂΩïÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÈÄÜ„ÄÇ",
                historyResetSuccess: "ÂéÜÂè≤ËÆ∞ÂΩïÂ∑≤ÈáçÁΩÆ!",
                copySuccess: "ÂéÜÂè≤ËÆ∞ÂΩïÂÜÖÂÆπÂ∑≤Â§çÂà∂!",
                copyError: "Â§çÂà∂Êó∂Âá∫Èîô„ÄÇ",
                copyPrepareError: "ÂáÜÂ§áÂ§çÂà∂Êó∂Âá∫Èîô„ÄÇ",
                noHistory: "Ê≤°ÊúâËÆ∞ÂΩïÁöÑÊ∏∏ÊàèÂéÜÂè≤„ÄÇ",
                helpTitle: "Â∏ÆÂä©‰∏éÁõÆÊ†á",
                helpTextStandard: `<strong>Ê¨¢ËøéÊù•Âà∞ Awale Â§ßËÑëËÆ≠ÁªÉÂô®ÔºÅ</strong><br><br>ÊÇ®ÁöÑÁõÆÊ†áÊòØ<strong>ÂÉèÂÜ†ÂÜõ‰∏ÄÊ†∑ÊÄùËÄÉ</strong>ÔºåÂú®ÊØèÊ¨°ËΩÆÂà∞ÊÇ®Êó∂ (Áé©ÂÆ∂ üòä ‚Üì) ÁåúÊµã‰ªñ‰ª¨Âú®ÁúüÂÆûÊ£ãÂ±Ä‰∏≠Ëµ∞Âá∫ÁöÑÈÇ£‰∏ÄÊ≠•„ÄÇ<br><br><strong>Áé©Ê≥ïËØ¥Êòé:</strong><br>1. ÈÄâÊã©‰∏ÄÁßçËØ≠Ë®ÄÂíåÂâç 3 ‰∏™ÂèØÁî®Ê£ãÂ±Ä‰πã‰∏Ä„ÄÇ<br>2. ËΩÆÂà∞ÊÇ®Êó∂ (üòä ‚Üì)ÔºåËßÇÂØüÊ£ãÁõò„ÄÇ<br>3. ÁÇπÂáªÊÇ®ÂÖ∂‰∏≠‰∏Ä‰∏™ÂåÖÂê´ÁßçÂ≠êÁöÑÁ©¥‰Ωç (A-F) ËøõË°åÈÄâÊã©„ÄÇ<br>4. ÈÄâÊã©ÊÇ®ËôöÊãüÂΩ©Ê±†ÁöÑÁôæÂàÜÊØîÔºåÂØπÊ≠§ÈÄâÊã©‰∏ãÊ≥®„ÄÇ<br>5. ÁÇπÂáª'‰∏ãÊ≥®!'„ÄÇÂ¶ÇÊûúÊÇ®ÁöÑÈÄâÊã©Ê≠£Á°ÆÔºåÊÇ®Â∞ÜËµ¢ÂæóÊÇ®ÁöÑËµåÊ≥®„ÄÇÂê¶ÂàôÔºåÊÇ®Â∞ÜÂ§±ÂéªÂÆÉ„ÄÇ<br>6. ËΩÆÂà∞ÂØπÊâãÊó∂ (üòî ‚Üë)ÔºåÁÇπÂáª'‰∏ã‰∏ÄÊ≠•'„ÄÇ<br><br><strong>ÂçáÁ∫ßÂà∞È´òÁ∫ßÁâà!</strong><br>‰∏∫‰∫ÜËé∑ÂæóÂÆåÊï¥‰ΩìÈ™åÂπ∂ÊîØÊåÅÊàë‰ª¨ÁöÑÂçè‰ºöÔºåËØ∑Âä†ÂÖ• <a href="https://jeuxnomadesfrance.jimdofree.com/" target="_blank" rel="noopener noreferrer">Jeux Nomades France</a>„ÄÇÈ´òÁ∫ßÁâàËß£ÈîÅ‰ª•‰∏ãÂäüËÉΩÔºö<ul><li>ËÆøÈóÆ<strong>ÊâÄÊúâËÆ≠ÁªÉÊ£ãÂ±Ä</strong>„ÄÇ</li><li><strong>"ÂéÜÂè≤"</strong> (ÂéÜÂè≤ËÆ∞ÂΩï) Âíå <strong>"ËÆ∞ÂΩï"</strong> (ËÆ∞ÂΩïÁ¨îËÆ∞) ÊåâÈíÆ„ÄÇ</li><li>ÊøÄÊ¥ª<strong>ËßÜËßâËæÖÂä©</strong> (ÂêÉÂ≠ê/ÂéãÂäõÊåáÁ§∫Âô®)„ÄÇ</li><li>ÊøÄÊ¥ª<strong>Á∫¢Ëâ≤ÂØπÈΩêÂçÅÂ≠óÁ∫ø</strong>„ÄÇ</li><li>ËÆøÈóÆ<strong>ÁßòÂØÜÊèêÁ§∫</strong>„ÄÇ</li></ul>`,
                helpTextPremium: `<strong>Ê¨¢ËøéÊù•Âà∞È´òÁ∫ßÁâàÔºÅ</strong><br><br>ÊÇ®ÂèØ‰ª•‰ΩøÁî®ÊâÄÊúâÂäüËÉΩÊù•ËÆ≠ÁªÉËá™Â∑±ÂÉèÂÜ†ÂÜõ‰∏ÄÊ†∑ÊÄùËÄÉ„ÄÇ<br><br><strong>È´òÁ∫ßÂäüËÉΩ:</strong><br><ul><li><strong>ÊâÄÊúâÊ£ãÂ±Ä:</strong> ÈÄöËøáÈÄâÊã©Âô®ËÆøÈóÆÊâÄÊúâÊ£ãÂ±Ä„ÄÇ</li><li><strong>ÂéÜÂè≤ ("ÂéÜÂè≤"):</strong> Êü•ÁúãÊÇ®‰πãÂâçÁöÑÊ£ãÂ±Ä„ÄÅÁªüËÆ°Êï∞ÊçÆÂíåËØÑËÆ∫„ÄÇ</li><li>
                    <strong>AI ÊïôÁªÉÈÄöËøá JSON ÂØºÂá∫:</strong> Âú®ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠‰ΩøÁî®‚ÄúÂ§çÂà∂ (JSON)‚ÄùÊåâÈíÆ„ÄÇÂ∞ÜÂ§çÂà∂ÁöÑÊñáÊú¨Á≤òË¥¥Âà∞ÂØπËØùÂºè AIÔºà‰æãÂ¶Ç ChatGPT„ÄÅGemini„ÄÅMistral Á≠âÔºâ‰∏≠„ÄÇÂåÖÂê´ÁöÑÊèêÁ§∫Â∞ÜË¶ÅÊ±Ç AI ÂàÜÊûêÊÇ®ÁöÑÊ∏∏ÊàèÔºàÈîôËØØ„ÄÅËØÑËÆ∫ÔºâÂπ∂Êèê‰æõ‰∏™ÊÄßÂåñÁöÑÊïôÁªÉÊèêÁ§∫ÔºåÁõ¥Êé•‰ΩøÁî®Â∫îÁî®Á®ãÂ∫è‰∏≠ÈÄâÊã©ÁöÑËØ≠Ë®ÄÔºÅ
                </li><li><strong>ËÆ∞ÂΩï ("ËÆ∞ÂΩï"):</strong> ‰∏∫ÊØè‰∏ÄÊ≠•Ê£ãÊ∑ªÂä†ÊàòÁï•ÊÄßÁ¨îËÆ∞„ÄÇ</li><li><strong>ËßÜËßâËæÖÂä©:</strong><ul><li>ÂêØÁî®/Á¶ÅÁî®: ÈïøÊåâ (3Áßí) Âè≥‰∏äËßíÁöÑ <strong>+</strong> ÊåâÈíÆ„ÄÇ</li><li>Èó™ÁÉÅÁöÑÊ©ôËâ≤ÂØπÊñπÁ©¥‰Ωç: ÊÇ®ÈÄâÊã©ÁöÑÊ≠•Êï∞Áõ¥Êé•ÂêÉÂ≠ê„ÄÇ</li><li>Â∏¶ÊúâÊ©ôËâ≤ËæπÊ°ÜÁöÑÂØπÊñπÁ©¥‰Ωç: Â≠òÂú®Êú™Êù•ÂèØËÉΩÂêÉÂ≠êÁöÑÂéãÂäõ„ÄÇ</li><li>Â∏¶ÊúâËôöÁ∫øÊ©ôËâ≤ËæπÊ°ÜÁöÑÊÇ®ÁöÑÁ©¥‰Ωç: Â≠òÂú®Ë¢´ÂØπÊâãÂêÉÂ≠êÁöÑÂ®ÅËÉÅ„ÄÇ</li></ul></li><li><strong>Á∫¢Ëâ≤ÂçÅÂ≠óÁ∫ø:</strong><ul><li>ÂêØÁî®/Á¶ÅÁî®: ÂçïÂáªÂè≥‰∏äËßíÁöÑ <strong>+</strong> ÊåâÈíÆ„ÄÇ</li><li>Â∏ÆÂä©ÂèØËßÜÂåñÁ©¥‰ΩçÂØπÈΩê„ÄÇ</li></ul></li></ul><strong>ÂèØÊøÄÊ¥ªÁöÑÁßòÂØÜÊèêÁ§∫:</strong><br><ul><li><strong>Logo x3 Ê¨°ÁÇπÂáª:</strong> ÈáçÁΩÆÂΩìÂâçÊ£ãÂ±Ä„ÄÇ</li><li><strong>ÂΩ©Ê±† x3 Ê¨°ÁÇπÂáª:</strong> ÂàáÊç¢ "‰øùËØÅÊàêÂäü" Ê®°Âºè (ÊâÄÊúâ‰∏ãÊ≥®ÈÉΩÊàêÂäü)„ÄÇ</li><li><strong>"Êàë‰∏ãÊ≥®" ÊñáÊú¨ x3 Ê¨°ÁÇπÂáª:</strong> ÈîÅÂÆö/Ëß£ÈîÅÈÄâÂÆöÁöÑ‰∏ãÊ≥®ÁôæÂàÜÊØî„ÄÇ</li><li><strong>ÂØπÊñπÁöÑ 'a' Á©¥‰Ωç (Êåâ‰Ωè 2Áßí):</strong> Êí§ÈîÄ‰∏ä‰∏ÄÊ≠•Ê£ã (ËøîÂõû)„ÄÇ</li><li><strong>ÂØπÊñπÁöÑ 'f' + 'a' Á©¥‰Ωç (ÂêåÊó∂Êåâ‰Ωè 3Áßí):</strong> ÊòæÁ§∫ÁßòÂØÜÊèêÁ§∫ÂàóË°®„ÄÇ</li></ul>`,
                secretMessage: "‰Ω†Â•Ω, Eric",
                secretTipsTitle: "ÁßòÂØÜÊèêÁ§∫ (È´òÁ∫ßÁâà)",
                secretTips: [ "Logo x3 Ê¨°ÁÇπÂáª: ÈáçÁΩÆÊ£ãÂ±Ä", "ÂΩ©Ê±† x3 Ê¨°ÁÇπÂáª: ‰øùËØÅÊàêÂäü ÂºÄ/ÂÖ≥", "'Êàë‰∏ãÊ≥®' x3 Ê¨°ÁÇπÂáª: ÈîÅÂÆö/Ëß£ÈîÅ‰∏ãÊ≥® (%)", "ÂØπÊñπÁöÑ 'f' Á©¥‰Ωç (Êåâ‰Ωè 2Áßí): ‰Ω†Â•Ω, Eric", "ÂØπÊñπÁöÑ 'a' Á©¥‰Ωç (Êåâ‰Ωè 2Áßí): ËøîÂõû (Êí§ÈîÄ‰∏ä‰∏ÄÊ≠•)", "ÂØπÊñπÁöÑ 'f' + 'a' Á©¥‰Ωç (ÂêåÊó∂Êåâ‰Ωè 3Áßí): ÊòæÁ§∫Ê≠§ÂàóË°®" ],
                commentModalTitle: "Ê∑ªÂä†ËØÑËÆ∫",
                commentInputPlaceholder: "Âú®Ê≠§ËæìÂÖ•ÊÇ®ÁöÑÊàòÁï•Á¨îËÆ∞...",
                commentCheckboxGood: "ÊΩúÂú®Â•ΩÊ£ã",
                commentCheckboxBad: "ÊΩúÂú®ÂùèÊ£ã",
                commentCheckboxRisky: "ÊúâÈ£éÈô©",
                commentCheckboxSafe: "ÂÆâÂÖ®",
                historyTitle: "Ê£ãÂ±ÄÂéÜÂè≤",
                historyRecordTitle: (name, date) => `Ê£ãÂ±Ä: ${name} (${date})`,
                historyStats: (rate, pot, duration) => `ÊàêÂäüÁéá: ${rate}% | ÊúÄÁªàÂΩ©Ê±†: ${pot}‚Ç¨ | Êó∂Èïø: ${duration}Áßí`,
                historyCommentsTitle: "Â∑≤ËÆ∞ÂΩïÁöÑËØÑËÆ∫",
                historyErrorsTitle: "‰∏ãÊ≥®ÈîôËØØ",
                historyNoComments: "Ê≠§Ê£ãÂ±ÄÊ≤°ÊúâËÆ∞ÂΩïËØÑËÆ∫„ÄÇ",
                historyNoErrors: "Ê≠§Ê£ãÂ±ÄÊ≤°ÊúâËÆ∞ÂΩï‰∏ãÊ≥®ÈîôËØØ„ÄÇ",
                historyInProgress: "(ËøõË°å‰∏≠)",
                historyMoveLabel: "Ê≠•",
                historyBetErrorLabel: (bet, correct, potChange, date) => `‰∏ãÊ≥® <span class="error-detail">${bet}</span> vs <span class="error-detail">${correct}</span> (ÂΩ©Ê±† ${potChange > 0 ? '+' : ''}${potChange}‚Ç¨) <small>(${date})</small>`,
                premiumModalTitle: "È´òÁ∫ßÂäüËÉΩ",
                premiumModalText: "Ê≠§ÂäüËÉΩ‰ª•ÂèäÂÖ∂‰ªñÂ•ΩÂ§Ñ‰ªÖ‰æõÈ´òÁ∫ß‰ºöÂëò‰ΩøÁî®„ÄÇ",
                premiumModalBenefitsTitle: "È´òÁ∫ßÁâàÂ•ΩÂ§Ñ:",
                premiumBenefitLevels: "ËÆøÈóÆÊâÄÊúâËÆ≠ÁªÉÊ£ãÂ±Ä„ÄÇ",
                premiumBenefitHistory: "'ÂéÜÂè≤'ÊåâÈíÆÔºåÁî®‰∫éÊü•ÁúãÂíåÂàÜÊûêÊÇ®‰πãÂâçÁöÑÊ£ãÂ±Ä„ÄÇ",
                premiumBenefitRecord: "'ËÆ∞ÂΩï'ÊåâÈíÆÔºåÁî®‰∫éÊ∑ªÂä†ÊàòÁï•ËØÑËÆ∫„ÄÇ",
                premiumBenefitAids: "ÊøÄÊ¥ªËßÜËßâËæÖÂä© (ÂêÉÂ≠ê/ÂéãÂäõ)„ÄÇ",
                premiumBenefitCross: "ÊøÄÊ¥ªÁ∫¢Ëâ≤ÂØπÈΩêÂçÅÂ≠óÁ∫ø„ÄÇ",
                premiumBenefitSecrets: "ËÆøÈóÆÁßòÂØÜÊèêÁ§∫„ÄÇ",
                premiumModalHowto: "Ë¶ÅËß£ÈîÅÈ´òÁ∫ßÁâàÂπ∂ÊîØÊåÅÊàë‰ª¨ÁöÑÂçè‰ºöÔºåËØ∑Êàê‰∏∫ <strong>Jeux Nomades France</strong> ÁöÑ‰ºöÂëò:",
                premiumModalActionLink: "Âä†ÂÖ•Âçè‰ºö",
                gameDropdownFormat: (index, moves) => `Ê£ãÂ±Ä ${index} (${moves} Ê≠•)`,
                encouragingMessages: [ "ÂÅöÂæóÂ•Ω!", "ÂæàÊ£í!", "‰ºòÁßÄ!", "ÁªßÁª≠Âä™Âäõ!", "‰ª§‰∫∫Âç∞Ë±°Ê∑±Âàª!", "Â§™Ê£í‰∫Ü!", "ÊäÄÊúØÂ®¥ÁÜü!", "Á≤æÂΩ©!", "Èöæ‰ª•ÁΩÆ‰ø°!", "ÁúüÊ£í!", "ÂÆåÁæé!", "ÊÉä‰∫∫!", "ÂêéËµ∑‰πãÁßÄ!", "ËΩ∞Âä®!", "ËÉúÂà©!", "Â§ßÂ∏à!", "‰º†Â•á!", "Â§©Êâç!", "ÂÜ†ÂÜõ!", "‰∏çÊúΩ!" ]
             }
        };


        // --- Utility Functions (inchang√©es sauf showPremiumInfoModal) ---
        function closeModal(modalId) {
             const modal = document.getElementById(modalId);
             if (modal) modal.style.display = 'none';
        }

        function showPremiumInfoModal() {
             const t = translations[currentLanguage] || translations.en;
             document.getElementById('premium-modal-title').textContent = t.premiumModalTitle;
             document.getElementById('premium-modal-text').textContent = t.premiumModalText;
             document.getElementById('premium-modal-benefits-title').textContent = t.premiumModalBenefitsTitle;
             document.getElementById('premium-benefit-levels').textContent = t.premiumBenefitLevels;
             document.getElementById('premium-benefit-history').textContent = t.premiumBenefitHistory;
             document.getElementById('premium-benefit-record').textContent = t.premiumBenefitRecord;
             document.getElementById('premium-benefit-aids').textContent = t.premiumBenefitAids;
             document.getElementById('premium-benefit-cross').textContent = t.premiumBenefitCross;
             document.getElementById('premium-benefit-secrets').textContent = t.premiumBenefitSecrets;
             document.getElementById('premium-modal-howto').innerHTML = t.premiumModalHowto;
             document.getElementById('premium-modal-action-link').textContent = t.premiumModalActionLink;
             document.getElementById('premium-modal-close').textContent = t.closeButton;
             const modal = document.getElementById('premium-info-modal');
             if (modal) modal.style.display = 'block';
        }

        function toggleCrossVisibility() {
             const t = translations[currentLanguage] || translations.en;
             if (!isPremium) { showPremiumInfoModal(); return; }
             isCrossVisible = !isCrossVisible;
             applyCrossVisibility();
             // showTemporaryMessage(isCrossVisible ? t.crossEnabled : t.crossDisabled);
        }

        function applyCrossVisibility() {
            const crossElement = document.getElementById('red-cross');
            if (crossElement) { crossElement.style.display = (isPremium && isCrossVisible) ? 'flex' : 'none'; }
        }

        function toggleAides() {
             const t = translations[currentLanguage] || translations.en;
             if (!isPremium) { showPremiumInfoModal(); return; }
             areAidesEnabled = !areAidesEnabled;
             showTemporaryMessage(areAidesEnabled ? t.aidesEnabled : t.aidesDisabled);
             renderBoard();
        }

        function showTemporaryMessage(message) {
             const resultEl = document.getElementById('result');
             if (resultEl) {
                 const originalText = resultEl.textContent;
                 const originalColor = resultEl.style.color;
                 resultEl.textContent = message;
                 resultEl.style.color = '#17a2b8';
                 setTimeout(() => {
                     if (resultEl.textContent === message) {
                         resultEl.textContent = originalText;
                         resultEl.style.color = originalColor;
                     }
                 }, 2000);
             }
        }

        function loadGameRecords() {
            const savedRecords = localStorage.getItem('awaleGameRecords');
            if (savedRecords) {
                try {
                     gameRecords = JSON.parse(savedRecords);
                     if (!Array.isArray(gameRecords)) gameRecords = [];
                } catch (e) { console.error("Error parsing saved records:", e); gameRecords = []; }
            } else { gameRecords = []; }
        }

        function saveGameRecords() {
            try { localStorage.setItem('awaleGameRecords', JSON.stringify(gameRecords)); }
            catch (e) { console.error("Error saving game records:", e); }
        }

        // --- Language Update Function (inchang√©e) ---
        function updateLanguage() {
            currentLanguage = document.getElementById("language-select").value || "fr";
            const t = translations[currentLanguage] || translations.en;

            console.log(`Updating language to: ${currentLanguage}`);

            document.documentElement.lang = currentLanguage;
            document.title = t.pageTitle;

            try {
                document.getElementById("language-label").textContent = t.languageLabel;
                document.getElementById("level-label").textContent = t.levelLabel;
                document.getElementById("title").textContent = t.title;
                document.getElementById("bet-label").textContent = t.betLabel;
                document.getElementById("bet-case-label").textContent = t.betCaseLabel;
                document.getElementById("bet-and-verify-btn").textContent = t.betButton;
                document.getElementById("next-btn").textContent = t.nextButton;

                const recordBtn = document.getElementById('record-btn');
                if (recordBtn) { recordBtn.textContent = t.recordButtonShort; recordBtn.title = t.tooltipRecord; }
                const historyBtn = document.getElementById('history-btn');
                if (historyBtn) { historyBtn.textContent = t.historyButtonShort; historyBtn.title = t.tooltipHistory; }
                document.getElementById("help-btn").title = t.tooltipHelp;
                document.getElementById("theme-toggle").title = t.tooltipTheme;
                document.getElementById("cross-toggle-btn").title = t.tooltipCross;

                const betPotInfoEl = document.getElementById('bet-pot-info');
                if (betPotInfoEl) betPotInfoEl.title = t.tooltipPot;
                const successRateEl = document.getElementById('success-rate');
                if (successRateEl) successRateEl.title = t.tooltipSuccessRate;

                document.getElementById("help-title").textContent = t.helpTitle;
                const helpTextElement = document.getElementById("help-text");
                if (helpTextElement) {
                    const helpTextContent = isPremium ? (t.helpTextPremium || t.helpTextStandard) : t.helpTextStandard;
                    helpTextElement.innerHTML = helpTextContent;
                }
                const helpCloseBtn = document.getElementById('help-modal-close');
                if(helpCloseBtn) helpCloseBtn.textContent = t.closeButton;

                document.getElementById("secret-tips-title").textContent = t.secretTipsTitle;
                const secretCloseBtn = document.getElementById('secret-modal-close');
                if(secretCloseBtn) secretCloseBtn.textContent = t.closeButton;

                document.getElementById("history-title").textContent = t.historyTitle;
                const historyCopyBtn = document.getElementById('history-copy-btn');
                if(historyCopyBtn) historyCopyBtn.textContent = t.copyButton;
                const historyResetBtn = document.getElementById('history-reset-btn');
                if(historyResetBtn) historyResetBtn.textContent = t.resetButton;
                const historyCloseBtn = document.getElementById('history-close-btn');
                if(historyCloseBtn) historyCloseBtn.textContent = t.closeButton;

                document.getElementById("comment-title").textContent = t.commentModalTitle;
                const commentInput = document.getElementById("comment-input");
                if(commentInput) commentInput.placeholder = t.commentInputPlaceholder;
                const commentSaveBtn = document.getElementById('comment-save-btn');
                if(commentSaveBtn) commentSaveBtn.textContent = t.saveButton;
                const commentCancelBtn = document.getElementById('comment-cancel-btn');
                if(commentCancelBtn) commentCancelBtn.textContent = t.cancelButton;
                document.querySelector('input[name="comment-option"][value="GoodMove"] + .checkbox-label-text').textContent = t.commentCheckboxGood;
                document.querySelector('input[name="comment-option"][value="BadMove"] + .checkbox-label-text').textContent = t.commentCheckboxBad;
                document.querySelector('input[name="comment-option"][value="Risky"] + .checkbox-label-text').textContent = t.commentCheckboxRisky;
                document.querySelector('input[name="comment-option"][value="Safe"] + .checkbox-label-text').textContent = t.commentCheckboxSafe;

                if (document.getElementById('premium-info-modal').style.display === 'block') {
                    showPremiumInfoModal();
                }

            } catch (error) { console.error("Error updating static text elements:", error); }

            populateGameSelect();
            renderBoard();

            console.log("Language update finished for:", currentLanguage);
        }


        // --- Game Setup and State (inchang√©es) ---
        function populateGameSelect() {
            const select = document.getElementById("level-select");
            if (!select) { console.error("Level select element not found"); return; }
            const t = translations[currentLanguage] || translations.en;
            const currentSelectedIndex = select.value ? parseInt(select.value) : currentGameIndex;

            select.innerHTML = "";
            const maxGamesToShow = isPremium ? games.length : 3;
            const gamesToShowCount = Math.min(maxGamesToShow, games.length);
            const visibleGames = games.slice(0, Math.max(1, gamesToShowCount));

            visibleGames.forEach((game, index) => {
                const option = document.createElement("option");
                option.value = index;
                option.textContent = t.gameDropdownFormat(index + 1, game.length);
                select.appendChild(option);
            });

            if (select.options.length > 0) {
                 const validIndex = Math.min(currentSelectedIndex, select.options.length - 1);
                 select.value = select.options[validIndex] ? validIndex : 0;
             }
        }

        function changeLevel() {
            const select = document.getElementById("level-select");
            if (!select) return;
            const selectedValue = select.value;
            let potentialNewIndex = parseInt(selectedValue);
            const maxAllowedIndex = isPremium ? games.length - 1 : Math.min(2, games.length - 1);

            if (isNaN(potentialNewIndex) || potentialNewIndex < 0 || potentialNewIndex > maxAllowedIndex) {
                potentialNewIndex = 0; select.value = 0;
            }
            if (currentGameIndex !== potentialNewIndex || currentGame.length === 0) {
                currentGameIndex = potentialNewIndex;
                if (games[currentGameIndex]) { currentGame = games[currentGameIndex].split(''); restartGame(); }
                else { console.error("Selected game data not found:", currentGameIndex); currentGameIndex = 0; select.value = 0; currentGame = games[0] ? games[0].split('') : []; restartGame(); }
            }
        }

        function setDefaultBet() {
            const select = document.getElementById('bet-amount');
            if (select) {
                if (isBetLocked && lockedBetPercentage !== null) { select.value = lockedBetPercentage; select.disabled = true; }
                else { isBetLocked = false; lockedBetPercentage = null; select.value = "75"; select.disabled = false; }
            }
        }

        // --- Board Rendering (inchang√©e) ---
        function renderBoard() {
            try {
                const t = translations[currentLanguage] || translations.en;
                const player1Row = document.getElementById('player1-row');
                const player2Row = document.getElementById('player2-row');
                if (!player1Row || !player2Row) { console.error("CRITICAL: #player1-row or #player2-row not found."); document.getElementById('result').textContent = t.errorDisplayMessage; return; }

                player1Row.innerHTML = ''; player2Row.innerHTML = '';

                 if (!board || !Array.isArray(board.player1) || !Array.isArray(board.player2) || !scores || typeof scores.player1 !== 'number' || typeof scores.player2 !== 'number') {
                     console.error("CRITICAL: Board or scores data is invalid.", board, scores); document.getElementById('result').textContent = t.errorDisplayMessage; return;
                 }

                const betInput = document.getElementById('bet-input');
                const selectedBetCode = betInput ? betInput.value : null;
                const isCurrentlyGameOver = currentMoveIndex + 1 >= currentGame.length;
                isGameOver.confettiShown = isGameOver.confettiShown && isCurrentlyGameOver;
                const nextMoveCode = isCurrentlyGameOver ? null : currentGame[currentMoveIndex + 1];
                const isPlayer1Turn = !isCurrentlyGameOver && /[A-F]/.test(nextMoveCode);

                clearTimeout(animationTimeout);

                let capturedOpponentHolesIndices = []; let pressuredOpponentHolesIndices = []; let threatenedPlayer1HolesIndices = [];
                if (isPremium && areAidesEnabled && isPlayer1Turn && board.player1 && board.player2) {
                    if (selectedBetCode) {
                        const selectedIndex = holeMap[selectedBetCode];
                        if (selectedIndex !== undefined && board.player1[selectedIndex] > 0) {
                            const simResultP1 = simulateMove(selectedBetCode, { simulateOnly: true, currentBoard: board, currentScores: scores });
                            if (simResultP1 && Array.isArray(simResultP1.capturedHoles)) {
                                capturedOpponentHolesIndices = simResultP1.capturedHoles.filter(h => h.player === 2).map(h => h.index);
                                if (capturedOpponentHolesIndices.length === 0) { pressuredOpponentHolesIndices = analyzeFuturePressure(simResultP1.board, simResultP1.scores); }
                            }
                        }
                    }
                    opponentHoleCodes.forEach((opponentMoveCode) => {
                        const opponentHoleIndex = holeMap[opponentMoveCode];
                        if (opponentHoleIndex !== undefined && board.player2[opponentHoleIndex] > 0) {
                            const simResultP2 = simulateMove(opponentMoveCode, { simulateOnly: true, currentBoard: board, currentScores: scores });
                            if (simResultP2 && Array.isArray(simResultP2.capturedHoles)) {
                                const capturedP1Holes = simResultP2.capturedHoles.filter(h => h.player === 1).map(h => h.index);
                                capturedP1Holes.forEach(threatIndex => { if (!threatenedPlayer1HolesIndices.includes(threatIndex)) threatenedPlayer1HolesIndices.push(threatIndex); });
                            }
                        }
                    });
                }

                const turnIndicator = document.getElementById('turn-indicator');
                if (turnIndicator) {
                    if (isCurrentlyGameOver) { turnIndicator.textContent = ""; turnIndicator.className = ""; }
                    else { turnIndicator.textContent = isPlayer1Turn ? t.playerTurnIndicator : t.opponentTurnIndicator; turnIndicator.className = isPlayer1Turn ? 'player-turn' : 'opponent-turn'; }
                }

                board.player1.forEach((seeds, index) => {
                    const hole = document.createElement('div'); const holeCode = playerHoleCodes[index]; hole.className = 'hole player1-hole'; hole.textContent = seeds; hole.dataset.code = holeCode;
                    const isClickable = isPlayer1Turn && seeds > 0;
                    if (isClickable) hole.classList.add('clickable');
                    if (!isClickable && isPlayer1Turn) hole.classList.add('disabled');
                    hole.addEventListener('click', () => {
                        if (isClickable) { if (betInput) betInput.value = holeCode; renderBoard(); }
                        else if (isPlayer1Turn && seeds === 0) { showTemporaryMessage(t.emptyHoleMessage); }
                        else if (!isPlayer1Turn) { showTemporaryMessage(t.opponentTurnMessage); }
                    });
                    if (holeCode === selectedBetCode && isPlayer1Turn) hole.classList.add('selected-bet');
                    if (isPremium && areAidesEnabled && isPlayer1Turn && threatenedPlayer1HolesIndices.includes(index)) hole.classList.add('highlight-pressure-enabled');
                    if (holeCode === lastIncorrectGuess) hole.classList.add('highlight-incorrect');
                    if (holeCode === lastCorrectMove) hole.classList.add('highlight-correct');
                    if (highlightStartHole?.player === 1 && highlightStartHole?.index === index) hole.classList.add('highlight-start');
                    if (highlightEndHole?.player === 1 && highlightEndHole?.index === index) hole.classList.add('highlight-end');
                    player1Row.appendChild(hole);
                });

                const reversedPlayer2 = [...board.player2].reverse();
                reversedPlayer2.forEach((seeds, visualIndex) => {
                    const actualIndex = 5 - visualIndex; const holeCode = opponentHoleCodes[actualIndex]; const hole = document.createElement('div'); hole.className = 'hole player2-hole'; hole.textContent = seeds; hole.dataset.index = actualIndex; hole.dataset.code = holeCode;
                    addLongPressListenerForSecrets(hole, actualIndex);
                    if (isPremium && areAidesEnabled && isPlayer1Turn) {
                        if (capturedOpponentHolesIndices.includes(actualIndex)) hole.classList.add('highlight-capture-enabled');
                        else if (pressuredOpponentHolesIndices.includes(actualIndex)) hole.classList.add('highlight-pressure-enabled');
                    }
                    if (highlightStartHole?.player === 2 && highlightStartHole?.index === actualIndex) hole.classList.add('highlight-start');
                    if (highlightEndHole?.player === 2 && highlightEndHole?.index === actualIndex) hole.classList.add('highlight-end');
                    player2Row.appendChild(hole);
                });

                const recordBtn = document.getElementById('record-btn'); const historyBtn = document.getElementById('history-btn');
                if(recordBtn) recordBtn.style.display = isPremium ? 'inline-block' : 'none';
                if(historyBtn) historyBtn.style.display = isPremium ? 'inline-block' : 'none';

                const moveInfoEl = document.getElementById('move-info'); if (moveInfoEl) moveInfoEl.textContent = t.moveInfo(scores.player1, scores.player2);
                const betPotInfoEl = document.getElementById('bet-pot-info'); if (betPotInfoEl) betPotInfoEl.innerHTML = t.betPotInfo(pot);
                const successRateEl = document.getElementById('success-rate');
                if (successRateEl) { const rate = totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100); successRateEl.innerHTML = t.successRate(rate); }
                const playedMovesEl = document.getElementById('played-moves'); if (playedMovesEl) playedMovesEl.textContent = t.playedMoves(currentMoveIndex + 1, currentGame.length, playedMoves.slice(-10).join(' '));

                const betButton = document.getElementById('bet-and-verify-btn'); const nextButton = document.getElementById('next-btn'); const resultEl = document.getElementById('result');
                if (betButton && nextButton && resultEl) {
                    if (isCurrentlyGameOver) {
                        betButton.style.display = 'none'; nextButton.style.display = 'none';
                         if (!resultEl.textContent.includes(t.resultWin) && !resultEl.textContent.includes(t.resultLose)) {
                              if (resultEl.textContent !== t.resultGameOver && resultEl.style.color !== 'rgb(23, 162, 184)') { resultEl.textContent = t.resultGameOver; resultEl.style.color = '#ff0000'; }
                         }
                        if (totalPlayer1Bets > 0 && successfulBets === totalPlayer1Bets && pot > 100 && !isGameOver.confettiShown) {
                             perfectGamesCount++; rainConfetti(); isGameOver.confettiShown = true;
                             const messages = t.encouragingMessages || translations.en.encouragingMessages;
                             const messageIndex = Math.min(perfectGamesCount - 1, messages.length - 1);
                             setTimeout(() => { const resEl = document.getElementById('result'); if (resEl && resEl.textContent.startsWith(t.resultGameOver)) { resEl.textContent = t.resultGameOver + " " + messages[messageIndex]; resEl.style.color = '#008000'; } }, 2500);
                        }
                        if (currentGameRecord.startTime && !currentGameRecord.endTime) { finalizeGameRecord(); }
                    } else {
                        betButton.style.display = isPlayer1Turn ? 'inline-block' : 'none'; nextButton.style.display = isPlayer1Turn ? 'none' : 'inline-block';
                        if (resultEl.textContent === t.resultGameOver) resultEl.textContent = "";
                    }
                }
                if (betInput) betInput.onchange = () => renderBoard();
                applyCrossVisibility();

            } catch (error) {
                 console.error("Error during renderBoard:", error); const t = translations[currentLanguage] || translations.en; const resultEl = document.getElementById('result');
                 if (resultEl) { resultEl.textContent = t.errorDisplayMessage; resultEl.style.color = "red"; }
                 clearTimeout(animationTimeout);
             }
        }


        // --- Game Logic Functions (inchang√©es) ---
        function simulateMove(moveCode, options = {}) {
             const { simulateOnly = false, currentBoard = board, currentScores = scores } = options;
             let tempBoard, tempScores; const t = translations[currentLanguage] || translations.en;
             try {
                 if (simulateOnly) { tempBoard = JSON.parse(JSON.stringify(currentBoard)); tempScores = JSON.parse(JSON.stringify(currentScores)); }
                 else { tempBoard = board; tempScores = scores; }
                 if (!tempBoard?.player1 || !tempBoard?.player2 || !tempScores) { console.error("Invalid board/scores", tempBoard, tempScores); return null; }
                 const isPlayer1 = /[A-F]/.test(moveCode); const playerBoard = isPlayer1 ? tempBoard.player1 : tempBoard.player2; const opponentBoard = isPlayer1 ? tempBoard.player2 : tempBoard.player1; const holeIndex = holeMap[moveCode];
                 if (holeIndex === undefined || holeIndex < 0 || holeIndex > 5 || !playerBoard || playerBoard[holeIndex] === undefined || playerBoard[holeIndex] <= 0) {
                     console.warn(`SimulateMove invalid: ${moveCode} (hole ${holeIndex}) player ${isPlayer1 ? 1 : 2} seeds ${playerBoard ? playerBoard[holeIndex] : 'N/A'}`);
                     return { board: tempBoard, scores: tempScores, startHole: { player: isPlayer1 ? 1 : 2, index: holeIndex }, endHole: { player: isPlayer1 ? 1 : 2, index: holeIndex }, captured: 0, capturedHoles: [] };
                 }
                 const startHole = { player: isPlayer1 ? 1 : 2, index: holeIndex }; let seeds = playerBoard[holeIndex]; playerBoard[holeIndex] = 0;
                 let currentPlayer = isPlayer1 ? 1 : 2; let currentHole = holeIndex; let seedsToDistribute = seeds; let lastHole = null; const originalOpponentTotal = opponentBoard.reduce((a, b) => a + b, 0);
                 while (seedsToDistribute > 0) {
                     if (currentPlayer === 1) { currentHole++; if (currentHole > 5) { currentPlayer = 2; currentHole = 0; } }
                     else { currentHole++; if (currentHole > 5) { currentPlayer = 1; currentHole = 0; } }
                     const isStartingHole = (isPlayer1 && currentPlayer === 1 && currentHole === holeIndex) || (!isPlayer1 && currentPlayer === 2 && currentHole === holeIndex);
                     if (!(seeds >= 12 && isStartingHole)) {
                         if (currentPlayer === 1) tempBoard.player1[currentHole]++; else tempBoard.player2[currentHole]++;
                         seedsToDistribute--;
                     }
                     if (seedsToDistribute === 0) { lastHole = { player: currentPlayer, index: currentHole }; }
                 }
                 const endHole = lastHole || startHole; let capturedSeeds = 0; let capturedHoles = [];
                 if (lastHole && ((isPlayer1 && lastHole.player === 2) || (!isPlayer1 && lastHole.player === 1))) {
                     let boardToCaptureFrom = lastHole.player === 1 ? tempBoard.player1 : tempBoard.player2; let capturePos = lastHole.index; let tempCapturedValue = 0; let tempCapturePath = [];
                     while (capturePos >= 0 && (boardToCaptureFrom[capturePos] === 2 || boardToCaptureFrom[capturePos] === 3)) {
                         const seedsInHole = boardToCaptureFrom[capturePos]; tempCapturedValue += seedsInHole; tempCapturePath.push({ index: capturePos, player: lastHole.player, value: seedsInHole });
                         capturePos--;
                     }
                     const opponentTotalAfterPotentialCapture = originalOpponentTotal - tempCapturedValue;
                     if (tempCapturedValue > 0 && opponentTotalAfterPotentialCapture > 0) {
                         capturedSeeds = tempCapturedValue; capturedHoles = tempCapturePath;
                         capturedHoles.forEach(holeInfo => { let boardToUpdate = holeInfo.player === 1 ? tempBoard.player1 : tempBoard.player2; boardToUpdate[holeInfo.index] = 0; });
                         if (isPlayer1) tempScores.player1 += capturedSeeds; else tempScores.player2 += capturedSeeds;
                     } else if (tempCapturedValue > 0 && opponentTotalAfterPotentialCapture === 0) { capturedHoles = []; }
                 }
                 return { board: tempBoard, scores: tempScores, startHole, endHole, captured: capturedSeeds, capturedHoles };
             } catch (error) { console.error("Error during simulateMove:", error, moveCode, currentBoard); showTemporaryMessage(t.internalErrorMessage); return null; }
        }

        function analyzeFuturePressure(simulatedBoard, simulatedScores) {
            const pressurePoints = []; const opponentPlayer = 2; if (!simulatedBoard?.player2) return [];
            const vulnerableHolesIndices = simulatedBoard.player2.reduce((acc, seeds, index) => { if (seeds === 1 || seeds === 2) acc.push(index); return acc; }, []);
            if (vulnerableHolesIndices.length === 0) return []; if (!simulatedBoard?.player1) return [];
            for (let playerHoleIndex = 0; playerHoleIndex < playerHoleCodes.length; playerHoleIndex++) {
                 const playerSeeds = simulatedBoard.player1[playerHoleIndex];
                 if (playerSeeds > 0) {
                     const potentialNextMoveCode = playerHoleCodes[playerHoleIndex];
                     const nextSimResult = simulateMove(potentialNextMoveCode, { simulateOnly: true, currentBoard: simulatedBoard, currentScores: simulatedScores });
                      if (nextSimResult && Array.isArray(nextSimResult.capturedHoles)) {
                         const capturedByThisNextMove = nextSimResult.capturedHoles.filter(h => h.player === opponentPlayer).map(h => h.index);
                         vulnerableHolesIndices.forEach(vulnIndex => { if (capturedByThisNextMove.includes(vulnIndex) && !pressurePoints.includes(vulnIndex)) { pressurePoints.push(vulnIndex); } });
                     }
                 }
                 if (pressurePoints.length === vulnerableHolesIndices.length) break;
            } return pressurePoints;
        }

        function betAndVerify() {
            const t = translations[currentLanguage] || translations.en; const betInput = document.getElementById('bet-input'); if (!betInput) return; currentBet = betInput.value;
            const betSelect = document.getElementById('bet-amount'); if (!betSelect) return; let betPercentage = parseInt(betSelect.value);
            if (isNaN(betPercentage) || betPercentage <= 0 || betPercentage > 100) { showTemporaryMessage(t.resultInvalidBet + " (%)"); return; }
            if (isNaN(pot)) pot = 100; betAmount = Math.max(0, Math.floor(pot * (betPercentage / 100)));
            if ((betAmount <= 0 && pot > 0) || betAmount > pot) { showTemporaryMessage(t.resultInvalidBet + " (Amount/Funds)"); return; }
            if (currentMoveIndex + 1 >= currentGame.length) { showTemporaryMessage(t.resultGameOver); return; }
            const nextMove = currentGame[currentMoveIndex + 1]; const isPlayer1Next = /[A-F]/.test(nextMove); if (!isPlayer1Next) { showTemporaryMessage(t.notYourTurnMessage); return; }
            const currentBetIndex = holeMap[currentBet]; if (currentBetIndex === undefined || !board?.player1 || board.player1[currentBetIndex] === undefined || board.player1[currentBetIndex] <= 0) { showTemporaryMessage(t.invalidHoleMessage); return; }
            document.getElementById('result').textContent = ""; lastIncorrectGuess = null; lastCorrectMove = null;
            currentMoveIndex++; totalPlayer1Bets++; playedMoves.push(nextMove);
            if (totalPlayer1Bets === 1 && currentMoveIndex === 0) { startNewGameRecord(); }
            moveHistory.push({ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: nextMove });
            const moveResult = simulateMove(nextMove, { simulateOnly: false });
            if (!moveResult) {
                console.error("Sim failed correct move:", nextMove); moveHistory.pop(); const prevState = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
                if (prevState) { board = JSON.parse(JSON.stringify(prevState.board)); scores = JSON.parse(JSON.stringify(prevState.scores)); }
                else { board = initialBoard(); scores = initialScores(); }
                currentMoveIndex--; totalPlayer1Bets--; playedMoves.pop(); showTemporaryMessage(t.internalErrorMessage); renderBoard(); return;
            }
            triggerAnimation(moveResult.startHole, moveResult.endHole);
            const resultEl = document.getElementById('result');
            if (isSuccessGuaranteed || currentBet === nextMove) {
                pot = Math.round(pot + betAmount); successfulBets++; if (resultEl) { resultEl.textContent = t.resultWin; resultEl.style.color = '#008000'; }
            } else {
                pot = Math.max(0, Math.round(pot - betAmount)); if (resultEl) { resultEl.textContent = t.resultLose + ` (${nextMove})`; resultEl.style.color = '#ff0000'; }
                lastIncorrectGuess = currentBet; lastCorrectMove = nextMove;
                const errorData = { moveIndex: currentMoveIndex, bet: currentBet, correctMove: nextMove, potChange: -betAmount, betAmount: betAmount, timestamp: Date.now() }; // Store betAmount for undo logic
                errorLog.push(errorData); if (currentGameRecord && Array.isArray(currentGameRecord.errors)) { currentGameRecord.errors.push(errorData); }
            } setDefaultBet(); renderBoard();
        }

        function moveNext() {
            const t = translations[currentLanguage] || translations.en; if (currentMoveIndex + 1 >= currentGame.length) { showTemporaryMessage(t.resultGameOver); return; }
            const nextMove = currentGame[currentMoveIndex + 1]; const isPlayer1Next = /[A-F]/.test(nextMove); if (isPlayer1Next) { showTemporaryMessage(t.playerTurnIndicator); return; }
            document.getElementById('result').textContent = ""; lastIncorrectGuess = null; lastCorrectMove = null;
            currentMoveIndex++; playedMoves.push(nextMove);
            if (currentMoveIndex === 0 && totalPlayer1Bets === 0) { startNewGameRecord(); }
             moveHistory.push({ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: nextMove });
            const moveResult = simulateMove(nextMove, { simulateOnly: false });
            if (!moveResult) {
                 console.error("Sim failed opponent move:", nextMove); moveHistory.pop(); const prevState = moveHistory.length > 0 ? moveHistory[moveHistory.length-1] : null;
                 if (prevState) { board = JSON.parse(JSON.stringify(prevState.board)); scores = JSON.parse(JSON.stringify(prevState.scores)); }
                 else { board = initialBoard(); scores = initialScores(); }
                 currentMoveIndex--; playedMoves.pop(); showTemporaryMessage(t.internalErrorMessage); renderBoard(); return;
            }
            triggerAnimation(moveResult.startHole, moveResult.endHole); setDefaultBet(); renderBoard();
        }

        function triggerAnimation(startHole, endHole) {
            clearTimeout(animationTimeout); highlightStartHole = startHole; highlightEndHole = endHole; renderBoard();
            animationTimeout = setTimeout(() => { highlightStartHole = null; highlightEndHole = null; renderBoard(); }, 800);
        }

        // --- History, Comments, Records (inchang√©es sauf copyHistoryContent) ---
        function startNewGameRecord() {
            if (currentGameRecord.startTime && !currentGameRecord.endTime) { finalizeGameRecord(); }
            gameStartTime = Date.now(); const t = translations[currentLanguage] || translations.en;
            currentGameRecord = { gameId: `game-${currentGameIndex + 1}-${gameStartTime}`, gameName: t.gameDropdownFormat(currentGameIndex + 1, currentGame.length), totalMoves: currentGame.length, startTime: gameStartTime, endTime: null, duration: 0, successRate: 0, finalPot: pot, comments: [], errors: [] };
            errorLog = []; console.log("Started new game record:", currentGameRecord.gameId);
        }

        function finalizeGameRecord() {
            if (!currentGameRecord || !currentGameRecord.startTime || currentGameRecord.endTime) { return; }
            console.log("Finalizing game record:", currentGameRecord.gameId);
            currentGameRecord.endTime = Date.now(); currentGameRecord.duration = Math.round((currentGameRecord.endTime - currentGameRecord.startTime) / 1000);
            currentGameRecord.successRate = totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100);
            currentGameRecord.finalPot = pot; currentGameRecord.errors = [...errorLog];
            const existingIndex = gameRecords.findIndex(r => r.gameId === currentGameRecord.gameId);
            if (existingIndex > -1) { gameRecords[existingIndex] = { ...currentGameRecord }; }
            else { gameRecords.push({ ...currentGameRecord }); }
            saveGameRecords(); currentGameRecord = {}; gameStartTime = null; errorLog = [];
        }

        function restartGame() {
            finalizeGameRecord(); board = initialBoard(); scores = initialScores(); currentMoveIndex = -1;
            moveHistory = [{ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: null }];
            currentBet = null; playedMoves = []; pot = 100; successfulBets = 0; totalPlayer1Bets = 0; errorLog = []; gameStartTime = null; currentGameRecord = {};
            lastIncorrectGuess = null; lastCorrectMove = null; highlightStartHole = null; highlightEndHole = null; clearTimeout(animationTimeout); isGameOver.confettiShown = false;
            const resultEl = document.getElementById('result'); if (resultEl) resultEl.textContent = "";
            const secretMsgEl = document.getElementById('secret-message'); if (secretMsgEl) secretMsgEl.textContent = "";
            setDefaultBet();
            if (games[currentGameIndex]) { currentGame = games[currentGameIndex].split(''); }
            else { console.error(`Game index ${currentGameIndex} invalid. Defaulting to 0.`); currentGameIndex = 0; currentGame = games[0] ? games[0].split('') : []; const levelSelect = document.getElementById('level-select'); if(levelSelect) levelSelect.value = 0; }
            renderBoard();
        }

         function openCommentModal() {
            if (!isPremium) { showPremiumInfoModal(); return; }
            const modal = document.getElementById('comment-modal'); if (modal) modal.style.display = 'block';
            const commentInput = document.getElementById('comment-input'); if (commentInput) commentInput.value = '';
            document.querySelectorAll('input[name="comment-option"]').forEach(checkbox => checkbox.checked = false);
        }

        function saveComment() {
            if (!currentGameRecord || !currentGameRecord.startTime) { console.warn("No active game record."); closeModal('comment-modal'); return; }
            const t = translations[currentLanguage] || translations.en; const commentInput = document.getElementById('comment-input'); const checkboxes = document.querySelectorAll('input[name="comment-option"]:checked');
            let commentText = commentInput ? commentInput.value.trim() : '';
             const checkedOptions = Array.from(checkboxes).map(checkbox => {
                 switch (checkbox.value) {
                     case 'GoodMove': return t.commentCheckboxGood; case 'BadMove': return t.commentCheckboxBad;
                     case 'Risky': return t.commentCheckboxRisky; case 'Safe': return t.commentCheckboxSafe;
                     default: return checkbox.value;
                 }
             });
            if (commentText || checkedOptions.length > 0) {
                 const moveIndexForLabel = currentMoveIndex >= 0 ? currentMoveIndex + 1 : 0; const moveLabel = moveIndexForLabel > 0 ? `${moveIndexForLabel}/${currentGame.length}` : "Start";
                 const moveCodePlayed = currentMoveIndex >= 0 ? currentGame[currentMoveIndex] : null;
                 const fullComment = { move: moveLabel, moveCode: moveCodePlayed, timestamp: Date.now(), text: commentText, options: checkedOptions };
                 if (!Array.isArray(currentGameRecord.comments)) { currentGameRecord.comments = []; }
                 currentGameRecord.comments.push(fullComment);
            } closeModal('comment-modal');
        }

        function openHistoryModal() {
            if (!isPremium) { showPremiumInfoModal(); return; }
            const t = translations[currentLanguage] || translations.en; const historyContent = document.getElementById('history-content'); const historyModal = document.getElementById('history-modal');
            if (!historyContent || !historyModal) { console.error("History modal elements not found"); return;}
            historyContent.innerHTML = ''; const tempRecords = [...gameRecords];
            if (currentGameRecord && currentGameRecord.startTime && !currentGameRecord.endTime) {
                const currentSnapshot = { ...currentGameRecord, endTime: Date.now(), duration: Math.round((Date.now() - currentGameRecord.startTime) / 1000), finalPot: pot, successRate: totalPlayer1Bets === 0 ? 0 : Math.round((successfulBets / totalPlayer1Bets) * 100), errors: [...errorLog], comments: [...(currentGameRecord.comments || [])], isInProgress: true };
                tempRecords.push(currentSnapshot);
            }
            tempRecords.sort((a, b) => (b.startTime || 0) - (a.startTime || 0));
            if (tempRecords.length === 0) { historyContent.textContent = t.noHistory; }
            else {
                tempRecords.forEach(record => {
                    if (!record || !record.startTime) return;
                    const entryDetails = document.createElement('details'); entryDetails.className = 'history-entry'; const entrySummary = document.createElement('summary'); entrySummary.className = 'history-summary';
                    const gameDate = new Date(record.startTime).toLocaleString(currentLanguage, { dateStyle: 'short', timeStyle: 'short' });
                    const titleText = t.historyRecordTitle(record.gameName || `Game ID ${record.gameId}`, gameDate); const statsText = t.historyStats(record.successRate ?? 0, record.finalPot ?? 0, record.duration ?? 0);
                    const inProgressText = record.isInProgress ? ` <em style="color: #007bff;font-size:0.9em;">${t.historyInProgress}</em>` : '';
                    entrySummary.innerHTML = `<span style="flex-grow: 1;">${titleText} <span style="font-weight:normal; font-size:0.9em;">(${statsText})</span></span>${inProgressText}`;
                    entryDetails.appendChild(entrySummary); const detailsDiv = document.createElement('div'); detailsDiv.className = 'history-details';
                    const commentsTitle = document.createElement('h4'); commentsTitle.textContent = t.historyCommentsTitle; detailsDiv.appendChild(commentsTitle);
                    if (record.comments && record.comments.length > 0) {
                        record.comments.forEach(comment => {
                            const commentP = document.createElement('p'); commentP.className = 'comment-entry'; const commentDate = new Date(comment.timestamp).toLocaleTimeString(currentLanguage, { timeStyle: 'short' });
                            let optionsText = comment.options && comment.options.length > 0 ? ` [${comment.options.join(', ')}]` : ''; const moveLabel = t.historyMoveLabel;
                            commentP.innerHTML = `<strong>${moveLabel} ${comment.move || '?'} (${comment.moveCode || 'N/A'}):</strong> ${comment.text || ''}<span class="comment-options">${optionsText}</span> <small>(${commentDate})</small>`;
                            detailsDiv.appendChild(commentP);
                        });
                    } else { const noCommentP = document.createElement('p'); noCommentP.textContent = t.historyNoComments; noCommentP.style.fontStyle = 'italic'; detailsDiv.appendChild(noCommentP); }
                    const errorsTitle = document.createElement('h4'); errorsTitle.textContent = t.historyErrorsTitle; errorsTitle.style.marginTop = '15px'; detailsDiv.appendChild(errorsTitle);
                    if (record.errors && record.errors.length > 0) {
                        record.errors.forEach(error => {
                            const errorP = document.createElement('p'); errorP.className = 'error-entry'; const errorDate = new Date(error.timestamp).toLocaleTimeString(currentLanguage, { timeStyle: 'short' });
                             const moveLabel = t.historyMoveLabel; const errorMoveNumber = (typeof error.moveIndex === 'number' && error.moveIndex >= 0) ? error.moveIndex + 1 : '?';
                             errorP.innerHTML = `<strong>${moveLabel} ${errorMoveNumber}:</strong> ${t.historyBetErrorLabel(error.bet, error.correctMove, error.potChange, errorDate)}`;
                            detailsDiv.appendChild(errorP);
                        });
                    } else { const noErrorP = document.createElement('p'); noErrorP.textContent = t.historyNoErrors; noErrorP.style.fontStyle = 'italic'; detailsDiv.appendChild(noErrorP); }
                    entryDetails.appendChild(detailsDiv); historyContent.appendChild(entryDetails);
                });
            } historyModal.style.display = 'block';
        }

        // --- MODIFIED copyHistoryContent ---
        function copyHistoryContent() {
            const t = translations[currentLanguage] || translations.en;
            try {
                // Construire le prompt dynamiquement avec la langue actuelle
                const dynamicPrompt = `You are an Awale expert and strategic coach specialized in analyzing champion games. Here is the history of games played by a user trying to guess the champion's move. Analyze their performance, common mistakes (errors array shows their incorrect bet vs the correct move), strengths, and comments. Provide constructive feedback and coaching tips to help them improve their ability to think like the champion.
IMPORTANT: Please formulate your response exclusively in the following language: ${currentLanguage}.`; // Ajout dynamique de la langue

                const dataToCopy = {
                    prompt: dynamicPrompt, // Utilisation du prompt dynamique
                    language_preference: currentLanguage, // Ajout explicite de la langue pr√©f√©r√©e
                    games: [...gameRecords] // Ensure a copy is used
                };

                const historyJson = JSON.stringify(dataToCopy, null, 2);
                navigator.clipboard.writeText(historyJson).then(() => {
                    alert(t.copySuccess);
                }).catch(err => {
                    console.error('Clipboard write error:', err);
                    alert(t.copyError);
                });
            } catch (e) {
                console.error("Error preparing history for copying:", e);
                alert(t.copyPrepareError);
            }
        }
        // --- END MODIFIED copyHistoryContent ---

        function resetHistory() {
            const t = translations[currentLanguage] || translations.en; if (confirm(t.confirmResetHistory)) {
                gameRecords = []; localStorage.removeItem('awaleGameRecords'); const historyContent = document.getElementById('history-content');
                if (historyContent) historyContent.textContent = t.noHistory; closeModal('history-modal'); alert(t.historyResetSuccess);
            }
        }

        function rainConfetti() {
            const container = document.body; for (let i = 0; i < 150; i++) { let c=document.createElement('div'); c.className='confetti'; const s=Math.random()*8+4; c.style.width=s+'px'; c.style.height=s+'px'; c.style.left=Math.random()*100+'vw'; c.style.top='-10px'; c.style.backgroundColor=`hsl(${Math.random()*360},100%,70%)`; c.style.animationDuration=(Math.random()*3+2)+'s'; c.style.animationDelay=Math.random()*1+'s'; c.style.transform=`rotate(${Math.random()*360}deg)`; container.appendChild(c); c.addEventListener('animationend',()=>{if(c.parentNode)c.parentNode.removeChild(c);});}
        }


        // --- Secrets and Listeners Setup (inchang√©es) ---
        function addTripleClickListener(element, callback) {
             let c = 0, l = 0; element?.addEventListener('click', (e) => { const t = Date.now(); if (t - l < 500) c++; else c = 1; l = t; if (c === 3) { callback(element); c = 0; } });
         }
        function handleTripleClick(element) {
            const t = translations[currentLanguage] || translations.en; if (!element) return;
            if (element.classList.contains('logo')) { restartGame(); showTemporaryMessage(t.resetMessage); }
            else if (element.id === 'bet-pot-info') { isSuccessGuaranteed = !isSuccessGuaranteed; showTemporaryMessage(isSuccessGuaranteed ? t.successOnMessage : t.successOffMessage); }
            else if (element.id === 'bet-label') {
                 const select = document.getElementById('bet-amount'); if(select){ isBetLocked = !isBetLocked; if (isBetLocked) { lockedBetPercentage = select.value; showTemporaryMessage(t.betLockedMessage(lockedBetPercentage)); select.disabled = true; } else { lockedBetPercentage = null; showTemporaryMessage(t.betUnlockedMessage); select.disabled = false; select.value = "75"; } } }
         }
        function addLongPressListener(element, duration, callback) {
             let p = null; const s = (e) => { if (e.button === 2) return; clearTimeout(p); p = setTimeout(() => { if(callback) callback(); p = null; }, duration); }; const c = () => { clearTimeout(p); p = null; }; const o = { passive: true }; element?.addEventListener('touchstart', s, o); element?.addEventListener('touchend', c); element?.addEventListener('touchcancel', c); element?.addEventListener('mousedown', s); element?.addEventListener('mouseup', c); element?.addEventListener('mouseleave', c);
         }
        function activatePremium() {
             if (!isPremium) { isPremium = true; localStorage.setItem('isPremiumVersion', 'true'); const t = translations[currentLanguage] || translations.en; showTemporaryMessage(t.premiumUnlockedMessage); updateLanguage(); }
         }
        function handleLongPressSecret(index) {
            const t = translations[currentLanguage] || translations.en; const secretMsgEl = document.getElementById('secret-message');
            if (index === 5) { if(secretMsgEl) secretMsgEl.textContent = t.secretMessage; }
            else if (index === 0) {
                 if (!isPremium) { showPremiumInfoModal(); return; }
                 if (currentMoveIndex >= 0 && moveHistory.length > 1) {
                      const moveBeingUndone = playedMoves.length > 0 ? playedMoves[playedMoves.length - 1] : null;
                      const wasPlayerBet = moveBeingUndone ? /[A-F]/.test(moveBeingUndone) : false;

                      moveHistory.pop(); const previousState = moveHistory[moveHistory.length - 1];
                      board = JSON.parse(JSON.stringify(previousState.board)); scores = JSON.parse(JSON.stringify(previousState.scores));
                      currentMoveIndex--; if (playedMoves.length > 0) playedMoves.pop();

                      if (wasPlayerBet) {
                          totalPlayer1Bets = Math.max(0, totalPlayer1Bets - 1);
                          const errorIndex = errorLog.findIndex(err => err.moveIndex === currentMoveIndex + 1);
                          if (errorIndex === -1) { // Successful bet undone
                              successfulBets = Math.max(0, successfulBets - 1);
                              // Find the bet amount from error log if possible (might not be there if success)
                              // Need a more robust way to restore pot accurately. For now, it might drift.
                              console.warn("Pot reversal on successful undo might be inaccurate.");
                          } else { // Error undone, remove log and pot was already reduced.
                             // Restore pot based on the stored betAmount in the error log entry
                             const undoneError = errorLog[errorIndex];
                             if (undoneError && typeof undoneError.betAmount === 'number') {
                                 pot = Math.round(pot + undoneError.betAmount); // Add back the lost amount
                             } else {
                                 console.warn("Could not find bet amount to restore pot on error undo.");
                             }
                             errorLog.splice(errorIndex, 1);
                          }
                      }
                      lastIncorrectGuess = null; lastCorrectMove = null; showTemporaryMessage(t.backMessage); renderBoard();
                 }
             }
         }
        function addLongPressListenerForSecrets(element, index) {
             if (index === 5 || index === 0) { addLongPressListener(element, 2000, () => handleLongPressSecret(index)); }
         }
        function showSecretTips() {
             if (!isPremium) { showPremiumInfoModal(); return; } const t = translations[currentLanguage] || translations.en; const secretModal = document.getElementById('secret-modal'); const tipsTitle = document.getElementById('secret-tips-title'); const tipsList = document.getElementById('secret-tips'); const closeBtn = document.getElementById('secret-modal-close');
             if(secretModal && tipsTitle && tipsList && closeBtn) { tipsList.innerHTML = (t.secretTips || []).map(tip => `<li>${tip}</li>`).join(''); secretModal.style.display = 'block'; }
        }
        function setupCombinedSecretListener() {
             const boardElement = document.getElementById('board'); if (!boardElement) return; let f = false, a = false; let p = null; let tF = null, tA = null;
             const c = () => { if (p) clearTimeout(p); p = null; }; const h = (e, i) => { if (!isPremium) return; const l = e.target.closest('.hole.player2-hole'); if (!l) return; const d = l.dataset.code; if (d === 'f') { f = i; tF = i ? l : null; } else if (d === 'a') { a = i; tA = i ? l : null; } else return; if (f && a) { c(); p = setTimeout(() => { if(f && a) showSecretTips(); }, 3000); } else { c(); } };
             boardElement.addEventListener('touchstart', (e) => h(e, true), {passive: true}); boardElement.addEventListener('touchend', (e) => h(e, false)); boardElement.addEventListener('touchcancel', (e) => h(e, false)); boardElement.addEventListener('mousedown', (e) => {if(e.button!==2) h(e, true);}); boardElement.addEventListener('mouseup', (e) => {if(e.button!==2) h(e, false);});
             boardElement.addEventListener('mouseleave', (e) => { if (e.target === tF) h(e, false); if (e.target === tA) h(e, false); }, true);
        }


        // --- Game Initialization (inchang√©e) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing Application...");
            isPremium = localStorage.getItem('isPremiumVersion') === 'true';
            console.log("Premium Status:", isPremium);

            document.getElementById('theme-toggle')?.addEventListener('click', () => { document.body.classList.toggle('dark-mode'); renderBoard(); });
            document.getElementById('help-btn')?.addEventListener('click', () => {
                 const t = translations[currentLanguage] || translations.en; const helpTextElement = document.getElementById("help-text");
                 if (helpTextElement) { const c = isPremium ? (t.helpTextPremium || t.helpTextStandard) : t.helpTextStandard; helpTextElement.innerHTML = c; }
                 const modal = document.getElementById('help-modal'); if(modal) modal.style.display = 'block';
            });
            addLongPressListener(document.getElementById('title'), 10000, activatePremium);
            const crossBtn = document.getElementById('cross-toggle-btn'); if (crossBtn) { crossBtn.addEventListener('click', toggleCrossVisibility); addLongPressListener(crossBtn, 3000, toggleAides); }
            document.querySelectorAll('.logo, #bet-pot-info, #bet-label').forEach(element => { if(element) addTripleClickListener(element, handleTripleClick); });
            setupCombinedSecretListener();
            const langSelect = document.getElementById("language-select"); if(langSelect) langSelect.addEventListener('change', updateLanguage);
            const levelSelect = document.getElementById("level-select"); if(levelSelect) levelSelect.addEventListener('change', changeLevel);

            loadGameRecords();
            board = initialBoard(); scores = initialScores();
            currentGameIndex = 0; currentGame = games[currentGameIndex] ? games[currentGameIndex].split('') : [];
            moveHistory = [{ board: JSON.parse(JSON.stringify(board)), scores: JSON.parse(JSON.stringify(scores)), moveCode: null }];
            console.log("Initial board state set.");

            currentLanguage = langSelect ? (langSelect.value || "fr") : "fr";
            updateLanguage(); // Initial setup

            console.log("Initialization complete. Current Language:", currentLanguage);
        });
    </script>
</body>
</html>
